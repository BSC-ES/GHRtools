[
  {
    "objectID": "content/upload-instructions.html",
    "href": "content/upload-instructions.html",
    "title": "Vignettes",
    "section": "",
    "text": "Vignettes\nRun in the R package project:\nrmarkdown::render(\n  input = \"~/Documents/ghrexplore/vignettes/GHRexplore.Rmd\",\n  output_format = \"github_document\",\n  output_file = \"GHRexplore-vignette.md\"\n)\nMove the .md file and depending image files to the website repo and link in the index.\nCopy paste header, badges and hex sticker from main page to the vignette.\nChange the file extension from .md to .qmd\n\n\nREADME\nCopy/paste the README file content taking into account the different grid configuration of the website vs.¬†the raw README file.\nChange the extensions to quarto (.qmd) and apply the website quarto header.\n\n\nChangelog\nRun in the R package project: generate-news.R\ncopy/paste the resulting file in the respective docs folder\nAdd the link to the reference in the main page\nCustomize the index page, e.g.¬†add sections and logo\n\n\nReference\nInstall package locally.\nRun in the R package project: generate-reference.R\ncopy/paste the index and function files in the respective docs folder\nAdd the link to the reference in the main page\nCustomize the index page, e.g.¬†add sections and logo"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_DLNM.html#prepare-data",
    "href": "docs/GHRmodel/GHRmodel_DLNM.html#prepare-data",
    "title": "Distributed Lag Nonlinear Models in GHRmodel",
    "section": "0. Prepare data",
    "text": "0. Prepare data\n\nLoad libraries\n# Load necessary package dependencies\nlibrary(dplyr)        # Data manipulation\nlibrary(tidyr)        # Data tidying\nlibrary(tidyselect)   # Helpers for selecting variables programmatically\nlibrary(rlang)        # Tools for tidy evaluation and non-standard evaluation in tidyverse code\nlibrary(ggplot2)      # Data visualization: creating plots and graphs\nlibrary(cowplot)      # Combining and arranging multiple ggplot2 plots into a single figure\nlibrary(grDevices)    # Base R graphics device functions (e.g., color palettes, saving plots)\nlibrary(RColorBrewer) # Predefined color palettes for plots\nlibrary(colorspace)   # Advanced color space manipulation and palettes\nlibrary(sf)           # Handling spatial vector data (simple features)\nlibrary(spdep)        # Spatial dependence and autocorrelation analysis\nlibrary(sn)           # Skew-normal and skew-t distributions (for modelling skewed data)\nlibrary(INLA)         # Integrated Nested Laplace Approximation for Bayesian models\nlibrary(GHRexplore)   # Exploratory analysis of health data\nlibrary(dlnm)         # Distributed linear and nonlinear models\n\n# Load GHRmodel\nlibrary(GHRmodel)     \n\n\nData pre-processing\nCreate numeric ID variables for categorical features (such as year, month, or spatial units) that may be included as random effects, in line with R-INLA‚Äôs requirements:\n# Load data \ndata(\"dengue_MS\")\ndf &lt;- dengue_MS\n\n# Create ID variables\ndf &lt;- df |&gt;  \n  # Filter out the year 2000 \n  filter(year &gt; 2000) |&gt;  \n  # Create numeric IDs for year, month and various spatial units.\n  mutate(\n    year_id = as.numeric(as.factor(year)),\n    month_id = as.numeric(as.factor(month)),\n    spat_id = as.numeric(as.factor(micro_code)), \n    spat_meso_id = as.numeric(as.factor(meso_code))\n  )\n\n\nSpatial data and graphs\nTo perform spatial analysis, polygon geometries must be provided as an sf object. For the dengue_MS data set, the areal polygons are already included in the package in the map_MS object. In map_MS, the code variable corresponds to the micro_code area identifier in the dengue_MS object.\n# Load map included in package\ndata(\"map_MS\")\n\n# Create adjacency Matrix\nnb &lt;- spdep::poly2nb(map_MS)\ng &lt;- spdep::nb2mat(nb, style = \"B\")"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_DLNM.html#model-development",
    "href": "docs/GHRmodel/GHRmodel_DLNM.html#model-development",
    "title": "Distributed Lag Nonlinear Models in GHRmodel",
    "section": "1. Model development",
    "text": "1. Model development\nIn this example we demonstrate how to use the GHRmodel helper functions to streamline writing INLA-compatible formulas including DLNM matrices.\n\nOne-dimensional basis matrix\nThe onebasis_inla() function is a wrapper around dlnm::onebasis(), which creates a one-dimensional basis matrix - a function used to model the nonlinear relationship of the outcome across a single dimension, in this case exposure values. This wrapper enhances the original function by allowing users to specify a custom prefix for the column names using the basis_name argument. This is particularly useful when multiple basis matrices (e.g., for different covariates) are included in the same model formula, as it ensures that each set of basis variables can be easily identified in the model formula by the INLA framework.\nThe covariate to be transformed is passed as a numeric vector to the covariate argument. The transformation applied to the covariate is controlled by the fun argument, which accepts the same options as dlnm::onebasis() and the splines package, including natural cubic splines (\"ns\"), B-splines (\"bs\"), and polynomial (\"poly\") functions, among others. The smoothness and flexibility of these spline basis functions are controlled through arguments such as degree (the polynomial degree of each piece), knots (the internal breakpoints that define where spline pieces join), and df (the degrees of freedom). The final nonlinear effect of the covariate is obtained by taking a weighted sum of the basis functions.\nFor detailed information about the available transformation functions, see ?onebasis.\n\nüí° Tip: You can define a spline either by specifying the degrees of freedom (df) or the exact knot locations (knots). When df is used, the number of internal knots is determined differently for natural splines (ns()) and B-splines (bs()):\n\nns(): internal knots = df ‚Äì 1 ‚Äì intercept.\nExample: For a natural cubic spline where degree is always 3,\nlibrary(splines)\nns(x = 1:10, df = 5)\nproduces 5 basis functions with 4 internal knots (5 ‚Äì 1).\nbs(): internal knots = df ‚Äì degree (‚Äì 1 if an intercept is included).\nExample: For a cubic B-spline (degree = 3),\nlibrary(splines)\nbs(x = 1:10, df = 5, degree = 3)\nproduces 5 basis functions with 2 internal knots (5 ‚Äì 3).\n\n\n\nüìù Note: In addition to onebasis_inla, GHRmodel supports nonlinear transformation of covariates via the cov_nl() function. cov_nl() uses inla.group() to discretize a covariate into intervals and then model the relationship as a random walk of order 1 (\"rw1\") or 2 (\"rw2\"). For more information about one-basis terms see the Complex Covariate Structures in GHRmodel vignette by typing vignette(\"GHRmodel_covariates\").\n\nHere we apply a cubic B-spline basis transformation to the tmin variable, measuring the minimum temperature, in order to include it as a nonlinear effect in the INLA-compatible model formula:\n# Place 3 internal knots at the 25th, 50th, and 95th percentiles of tmin. \ntminknots = quantile(df$tmin,c(25,50,95)/100, na.rm=T)\n\n# Construct a one-dimensional basis for modeling the nonlinear effect of minimum temperature (tmin).\nob_tmin &lt;- onebasis_inla(\n  covariate   = df$tmin,     # Numeric vector of the covariate values to transform.\n  fun         = \"bs\",        # Basis function type: B-spline.\n  knots       = tminknots,   # Internal knots for the spline\n  degree      = 3,           # Polynomial degree (cubic spline)\n  basis_name  = \"tmin\"       # Prefix for the generated basis matrix column names.\n)\n\n# Display the first few rows of the basis matrix to inspect the transformation.\nhead(ob_tmin)\n#&gt;      tmin1        tmin2      tmin3     tmin4      tmin5        tmin6\n#&gt; [1,]     0 0.0000000000 0.03110108 0.3486913 0.58255507 0.0376525251\n#&gt; [2,]     0 0.0000000000 0.08824823 0.5280018 0.38354678 0.0002031681\n#&gt; [3,]     0 0.0005560503 0.19951665 0.6092978 0.19062947 0.0000000000\n#&gt; [4,]     0 0.0106996786 0.39954732 0.5387557 0.05099734 0.0000000000\n#&gt; [5,]     0 0.0184877161 0.46489629 0.4880934 0.02852261 0.0000000000\n#&gt; [6,]     0 0.0014234095 0.24044045 0.6086812 0.14945494 0.0000000000\n\n\nCross-basis matrix\nThe crossbasis_inla() function is a wrapper around dlnm::crossbasis(), which creates a cross-basis matrix which models the nonlinear relationship of the outcome in two dimensions: the exposure (covariate or predictor) dimension and the lag dimension. The column names of the resulting matrix can be customized using the basis_name argument, to ensure that each set of cross-basis variables (for example, for different covariates) can be easily distinguishable in a model formula or output.\nThe covariate to be transformed is passed as a numeric matrix of lagged values to the covariate argument. The shape of the exposure-response dimension is controlled by the argvar argument and the shape of the lag-response dimension is defined by the arglag argument. These arguments are passed to the underlying onebasis and support the same options. Common choices are natural splines (\"ns\"), B-splines (\"bs\"), and polynomial (\"poly\") functions, among others (see ?onebasis). Finally, the lag argument defines the lag range to include in the cross-basis matrix.\nTo produce cross-basis matrices for tmin and pdsi, the first step is to produce the lagged-covariate matrix, which can be easily done using the lag_cov() function with the argument add = FALSE:\n# Lagged covariate matrix for tmin \nlagged_tmin &lt;- lag_cov(data = df,\n                       name = \"tmin\",\n                       time = \"date\",        \n                       lag = c(1:2),         # 1 to 2-month lags\n                       group = \"micro_code\", # Independent time-series for each microregion\n                       add = FALSE)\n\n# Lagged covariate matrix for pdsi\nlagged_pdsi &lt;- lag_cov(data = df,\n                       name = \"pdsi\",\n                       time = \"date\",        \n                       lag = c(1:2),         # 1 to 2-month lags\n                       group = \"micro_code\", # Independent time-series for each microregion\n                       add = FALSE)\nHere we create a cross-basis matrix for the response to tmin exposure across a lag period of 1 to 2 months. This matrix captures the relationship between both the level of exposure and the timing of its effect (lag).\n# 2-dimensional nonlinear effect of dengue risk across tmin values and lags\ncb_tmin &lt;- crossbasis_inla(\n  covariate = lagged_tmin,              # Matrix of lagged tmin values\n  lag = c(1, 2),                        # Lags from 1 to 2 months\n  basis_name = \"tmin\",                  # Prefix for output column names\n  argvar  = list(fun = \"bs\"),           # Polynomial degree (cubic spline)\n  arglag  = list(fun = \"ns\",            # Natural cubic splines for lag-response\n                 knots=logknots(2,      # Maximum lag (here 2)\n                                nk=1))  # Number of knots \n\n\n)\n\n# Inspect the resulting matrix\ndim(cb_tmin)\ncolnames(cb_tmin)\ncb_tmin &lt;- readRDS(system.file(\"examples\", \"cb_tmin.rds\", package = \"GHRmodel\"))\nHere we produce a similar cross-basis object for the pdsi variable:\n# 2-dimensional nonlinear effect of dengue risk across pdsi values and lags\ncb_pdsi &lt;- crossbasis_inla(\n  covariate = lagged_pdsi,\n  lag = c(1, 2),\n  basis_name = \"pdsi\",\n  argvar  = list(fun = \"bs\"), # Default B-spline for exposure-response\n  arglag  = list(fun = \"bs\")  # Default B-spline for lag-response\n)\n\n\nModel formulas including DLNM terms\n\nDefine priors\n\nBayesian models require priors to be assigned to parameters that the model will estimate. For more details regarding these prior choices, see GHRmodel_overview. For more details about priors in R-INLA, see this book chapter (G√≥mez-Rubio, 2020).\nThe monthly and yearly random effects are assigned weakly informative Gamma priors on the precision with parameters 0.01 and 0.01 (G√≥mez-Rubio, 2020).\n# Define Gamma priors for the precision of temporal random effects\nprior_t &lt;- list(prec = list(prior = 'loggamma', param = c(0.01, 0.01))) \nThe spatial random effect is specified using the BYM2 model, which facilitates assigning Penalized Complexity (PC) priors to its hyperparameters (Simpson et al., 2017). These priors are conservative and weakly informative, thus allowing the data to drive the inclusion of spatial structure (Moraga, 2019).\n# Define penalized complexity (PC) priors for spatial random effects using BYM2\nprior_sp &lt;- list(\n  prec = list(prior = 'pc.prec', param = c(0.5 / 0.31, 0.01)),  # Precision of spatial effect\n  phi  = list(prior = 'pc', param = c(0.5, 2 / 3))              # Mixing parameter: structured vs unstructured\n)\nHere we construct a set of model formulas including DLNM terms using the write_inla_formulas() function. The resulting formulas are then standardized into a GHRformulas object for use with the fit_models() function.\n# Write INLA-compatible model formulas including DLNM terms\nformulas_dlnm &lt;- write_inla_formulas(\n  outcome = \"dengue_cases\",\n  covariates = list(\n    c(\"ob_tmin\"),                 # Model 1: includes one-basis object (minimum temperature)\n    c(\"cb_tmin\"),                 # Model 2: includes cross-basis for temperature\n    c(\"cb_tmin\", \"cb_pdsi\")       # Model 3: includes cross-basis for temperature and drought index\n    \n  ),\n  # First random effect: monthly seasonality\n  re1 = list(\n    id        = \"month_id\",      # Time index for monthly effect\n    model     = \"rw1\",           # First-order random walk model\n    cyclic    = TRUE,            # Enforce cyclicity over months (Dec ‚Üí Jan wrap-around)\n    hyper     = \"prior_t\",       # Hyperprior object for precision\n    replicate = \"spat_meso_id\"   # Separate seasonal pattern per mesoregion\n  ),\n  # Second random effect: inter-annual trend\n  re2 = list(\n    id    = \"year_id\",           # Year index\n    model = \"iid\",               # Independent and identically distributed\n    hyper = \"prior_t\"            # Hyperprior for temporal smoothness\n  ),\n  # Third random effect: spatial autocorrelation\n  re3 = list(\n    id    = \"spat_id\",           # Spatial unit identifier\n    model = \"bym2\",              # BYM2 spatial model (structured + unstructured)\n    graph = \"g\",                 # Pre-computed spatial adjacency graph\n    hyper = \"prior_sp\"           # PC priors for BYM2 model parameters\n  ),\n)\n\n# Convert formulas list into a GHRformulas object for model fitting\nformulas_dlnm_ghr &lt;- as_GHRformulas(formulas_dlnm)\n\n# Output is a GHRformulas object\nclass(formulas_dlnm_ghr)\n#&gt; [1] \"GHRformulas\" \"list\""
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_DLNM.html#fit-dlnms-with-inla",
    "href": "docs/GHRmodel/GHRmodel_DLNM.html#fit-dlnms-with-inla",
    "title": "Distributed Lag Nonlinear Models in GHRmodel",
    "section": "2. Fit DLNMs with INLA",
    "text": "2. Fit DLNMs with INLA\nTo fit a DLNM using INLA, you must first create the necessary basis functions using appropriate spline or polynomial transformations. These should be available in your working environment prior to model fitting (see 1. Model development).\nWhen fitting DLNMs, it is essential to include the variance-covariance matrix of fixed effects in the model output to enable interpretation of the combined effects across lag dimensions. This is done by setting vcov = TRUE within the control_compute argument of fit_models().\n# Fitting a DLNM model using a previously defined formula and basis objects\n# Note: vcov = TRUE is required for DLNM interpretation and plotting\nmodel_dlnm &lt;-fit_models(\n  formulas = formulas_dlnm_ghr, \n  name =\"mod\", \n  data = df, \n  family =\"nbinomial\",\n  offset = \"population\",\n  control_compute = list (config = TRUE, vcov = TRUE), \n  pb = TRUE) \n\nclass(model_dlnm)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_DLNM.html#dlnm-output",
    "href": "docs/GHRmodel/GHRmodel_DLNM.html#dlnm-output",
    "title": "Distributed Lag Nonlinear Models in GHRmodel",
    "section": "3. DLNM output",
    "text": "3. DLNM output\nTo interpret DLNM model results, predictions over a range of exposure and lag values can be generated using the crosspred_inla() function. crosspred_inla() extracts the relevant estimated coefficients and variance-covariance matrix from a GHRmodels object and passes them to the dlnm::crosspred() function to return a GHRcrosspred object that can be used to compute predictions and uncertainty intervals. It requires the fitted model to include a variance-covariance matrix (vcov = TRUE in fit_models()). The range of exposure values over which predictions are generated can be adjusted using the from, to and at arguments.\nThe plot_coef_crosspred() function provides flexible plotting options for visualizing DLNM results from a GHRcrosspred object. The output is a ggplot2 object, allowing the user to further customize the output. It supports multiple plot types depending on the structure of the basis used (one-basis or cross-basis):\n\ntype = \"overall\": Plots the overall exposure-response relationship across all lags.\ntype = \"slices\": Plots slices across lags (for a given exposure level) or exposures (for a given lag).\ntype = \"heatmap\": A two-dimensional heatmap of the effect surface over exposure and lag (for cross-basis only). This visualization provides a clear overview of the joint effect pattern but does not depict uncertainty, such as credible intervals.\n\nHere we show the model_dlnm$mod_gof element to provide a convenient overview of all fitted models describing identifiers for each model and the one-basis or cross-basis objects included.\n\n\n\nmodel_id\ncovariate_1\ncovariate_2\n\n\n\n\nmod1\n\n\n\n\nmod2\nob_tmin\n\n\n\nmod3\ncb_tmin\n\n\n\nmod4\ncb_tmin\ncb_pdsi\n\n\n\nDLNM terms in model_dlnm\n\nOne-basis terms\nThe following example demonstrates how to extract and visualize the nonlinear effect of the tmin variable at lag 0 from a fitted model using crosspred_inla() and plot_coef_crosspred().\nFirst, we generate predictions for the nonlinear effect of tmin using the corresponding one-basis object estimates (ob_tmin) from the second model in the model_dlnm object (mod2). The effect is centered at a reference value of 19¬∞C (the mean of tmin mean(df$tmin)) to aid interpretability, meaning all effect estimates are relative to that value.\n\nüí° Tip: The reference value sets the baseline for interpreting the estimated effect. This can be the mean of the covariate, a specific threshold of interest, or 0 when variables are centered at 0 (such as SPI or PDSI).\n\n# Generate dengue risk predictions for a range of tmin values. \ncpred_ob_tmin &lt;- crosspred_inla(\n  model = model_dlnm,   # GHRmodels object\n  basis = ob_tmin,      # One-basis object for the `tmin` variable\n  mod_id = \"mod2\",      # Identifier to select the correct model component\n  cen = 19,             # Temperature centered at the mean of tmin 19¬∞C\n  from = 15,            # Predictions are generated for temperature values above 15\n  to = 24               # Predictions are generated for temperature values below 24\n)\n\n# Output a GHRcrosspred object\nclass(cpred_ob_tmin)\n#&gt; [1] \"GHRcrosspred\" \"crosspred\"\nNext, we visualize the predicted nonlinear effect across a range of tmin values (15¬∞C to 25¬∞C) at lag 0 using the \"slices\" plot type. This slice plot shows how the effect of minimum temperature on dengue risk varies at different values, with credible intervals highlighting uncertainty. Here we observe that minimum temperatures of 21¬∞C and 22¬∞C increase risk of dengue compared to the mean minimum temperature of 19¬∞C.\n# Plot the predicted dengue risk values against the tmin values\nplot_coef_crosspred(\n  cpred_ob_tmin,           # The cross-predicted object from crosspred_inla()\n  type = \"slices\",         # Plot type: shows effect as a continuous curve\n  var = seq(15,24),        # Range of tmin values to display on the x-axis\n  line_color = \"red\",      # Color of the fitted effect line\n  line_size = 0.8,         # Thickness of the effect line\n  ribbon_color = \"red\",    # Color of the credible interval (ribbon)\n  ribbon_alpha = 0.3,      # Transparency level of the ribbon (0 = invisible)\n  title = \"Effect of minimum temperature on dengue risk\",  # Plot title\n  xlab = \"Minimum temperature\",   # Label for the x-axis\n  ylab = \"Effect\"                 # Label for the y-axis \n)\n\n\n\nCross-basis terms\nThis section demonstrates how to evaluate and visualize the effects from cross-basis DLNM estimates fit in an INLA model. In this case we use these estimates to assess how the effects of minimum temperature (tmin) on dengue risk change over time lag period and over a range of temperature values.\ncrosspred_inla() extracts model predictions for the cross-basis of minimum temperature (cb_tmin) across lags from the fitted model model_dlnm. The effect estimates are centered at 19¬∞C (the mean minimum temperature).\n# Generate dengue risk predictions for a range of tmin values and lags. \ncpred_cb_tmin &lt;- crosspred_inla(\n  models = model_dlnm, # GHRmodels object\n  basis = cb_tmin,     # Cross-basis from tmin\n  mod_id = \"mod3\",     # Model identifier\n  cen = 19,            # Centering value (mean minimum temperature 20¬∞C)\n  from = 17,           # Start predicting at \n  to= 24\n)\n\n# Output a GHRcrosspred object\nclass(cpred_cb_tmin)\n#&gt; [1] \"GHRcrosspred\" \"crosspred\"\nHere we visualize the estimated relative risks (i.e., exponentiated effects) (exp = TRUE) across lags 1 to 2 for a range of temperature values using slice plots (type = \"slices\") with smooth interpolation across lags. These plots illustrate how the effect of temperature on dengue risk evolves over different lag times. We observe that high minimum temperatures of 23¬∞C and 24¬∞C, particularly at a one-month lag, are associated with a notable increase in dengue relative risk.\n# Plot the predicted dengue risk values against the tmin values and lags\nplot_coef_crosspred(\n  crosspred = cpred_cb_tmin,  # Crosspred object with model predictions\n  type = \"slices\",            # Plot lag-specific slices of exposure-response curves\n  exp = TRUE,                 # Exponentiate the coefficients,\n  lag = 1:2,                  # Display results for lags 1 through 6\n  line_color = \"red\",         # Red color for the lines representing effect estimates\n  line_size = 0.8,            # Line thickness set to 0.8 for better visibility\n  ribbon_color = \"red\",       # Red shading for credible interval ribbons\n  ribbon_alpha = 0.3,         # Set ribbon transparency to 30%\n  title = \"Effect of minimum temperature on dengue relative risk by lag\",  # Main plot title\n  xlab = \"Mean minimum temperature exposure\",    # Label for the x-axis (exposure variable)\n  ylab = \"Relative Risk (RR)\" # Label for the y-axis (effect estimate scale)\n)\n \nHere we focus on the estimated relative risk for specific temperature values, between 19¬∞C and 24¬∞C, specified in the var argument and displayed in the facets. In this plot we can observe that mean minimum temperatures 24¬∞C at 1 month lag have a positive effect on dengue.\n# Plot the predicted dengue risk values against the tmin values and lags\nplot_coef_crosspred(\n  crosspred = cpred_cb_tmin,  # Crosspred object with model predictions\n  type = \"slices\",            # Plot temperature-specific slices of exposure-response curves\n  exp = TRUE,                 # Exponentiate the coefficients (to relative risk scale)\n  var = c(20:24),             # Display results for temperature 19¬∞C to 24¬∞C\n  line_color = \"red\",         # Red color for the lines representing effect estimates\n  line_size = 0.8,            # Line thickness set to 0.8 for better visibility\n  ribbon_color = \"red\",       # Red shading for credible interval ribbons\n  ribbon_alpha = 0.3,         # Set ribbon transparency to 30%\n  title = \"Effect of minimum temperatures 19¬∞C to 24¬∞C on dengue relative risk by lag\",  # Main plot title\n  xlab = \"Lag\",               # Label for the x-axis (exposure variable)\n  ylab = \"Relative Risk (RR)\" # Label for the y-axis (effect estimate scale)\n)\n \nHere we visualize the estimated relative risks using type = \"heatmap\" to examine how the association between temperature and dengue varies jointly across different temperature values and lag periods. The plot reveals that the most pronounced effects occur at a lag of approximately one month: higher minimum temperatures at this lag are associated with an increased risk of dengue, while lower temperatures, around the mean temperature, are linked to a decreased risk.\n# Plot the predicted dengue risk values against the tmin values and lags\nplot_coef_crosspred(\n  crosspred = cpred_cb_tmin,  # Crosspred object containing model predictions\n  type = \"heatmap\",           # Create a 2D heatmap of effects over exposure and lag values\n  exp = TRUE,                 # Exponentiate effects to show relative risks\n  palette = \"-RdBu\",          # Use the inverted \"RdBu\" color palette for the heatmap (blue for lower values)\n  title = \"Effect of minimum temperature on dengue relative risk by lag\",  # Main plot title\n  xlab = \"Mean minimum temperature exposure\",    # Label for the x-axis (exposure variable)\n)\n \n\nüí° Tip: To produce a smoother exposure-lag heatmap, you can fine-tune both the prediction resolution and the plotting interpolation\n\n\nSmoother x-axis (exposure): Increase the granularity of predicted exposure values by specifying a dense sequence via the at argument in crosspred_inla(). This results in more prediction points across the exposure range.\nSmoother y-axis (lag): Increase the number of interpolated lag points using the n_lag_smooth argument in plot_coef_crosspred(). This controls how finely the effects are interpolated across lags for the heatmap.\n\n# Generate predictions using a higher-resolution range of temperature values\ncpred_cb_tmin_smooth &lt;- crosspred_inla(\n  models = model_dlnm,    # GHRmodels object\n  basis = cb_tmin,        # Cross-basis from tmin\n  mod_id = \"mod3\",        # Model identifier\n  cen = 19,               # Centering value (mean minimum temperature 19¬∞C)\n  at = seq(17,24, by=0.05), # Increase the number of temperature points for prediction\n  from = 17, \n  to= 24\n)\n\n# Plot a more granular heatmap with increased number of temperature values for prediction\n# and increased number of lag interpolation values\nplot_coef_crosspred(\n  crosspred = cpred_cb_tmin_smooth,   # Crosspred object containing model predictions\n  type = \"heatmap\",           # Create a 2D heatmap of effects over exposure and lag\n  exp = TRUE,                 # Exponentiate effects to show relative risks\n  n_lag_smooth = 200,         # Smooth across lag with 200 interpolation points\n  palette = \"-RdBu\",          # Use the inverted \"RdBu\" color palette\n  title = \"Effect of minimum temperature on dengue relative risk by lag\",  # Main plot title\n  xlab = \"Mean minimum temperature exposure\",    # Label for the x-axis (exposure variable)\n)\n \nLastly, the type = \"overall\" displays the overall effect of the exposure variable (tmin) aggregated across all lag times, summarizing the total exposure-response relationship. This plot helps in understanding the net impact of the exposure on the outcome without focusing on individual lag effects. In this example, we observe that mean minimum temperatures above 22¬∞C are associated with an increased risk of dengue. However, this plot does not reveal that this effect is primarily driven by temperatures at a one-month lag, which is clearer in the lag-specific plots.\n# Plot overall effect of tmin on dengue across lags\nplot_coef_crosspred(crosspred = cpred_cb_tmin,\n                    type = \"overall\",\n                    exp= TRUE, # Exponentiate effects to show relative risks\n                    line_color = \"Red\", # Red color for the lines representing effect estimates\n                    line_size = 0.8, # Line thickness set to 0.8 for better visibility\n                    ribbon_color = \"Red\", # Red shading for credible interval ribbons\n                    ribbon_alpha = 0.3, # Set ribbon transparency to 30%\n                    xlab = \"Mean minimum temperature exposure\", # Label for the x-axis\n                    ylab = \"Effect\" # Label for the y-axis (effect estimate scale)\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_fit.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_fit.Rd.html",
    "title": "Plot Observed vs.¬†Fitted Cases",
    "section": "",
    "text": "This function creates a time-series plot comparing observed cases with fitted values from one or more models in a GHRmodels object. The plot supports faceting by model and/or group.\nplot_fit(\n  models = NULL,\n  mod_id = NULL,\n  time = NULL,\n  group = NULL,\n  group_id = NULL,\n  mod_label = NULL,\n  mod_facet = FALSE,\n  palette = \"IDE2\",\n  ref_color = NULL,\n  obs_color = NULL,\n  obs_label = NULL,\n  title = \"\",\n  ci = FALSE,\n  transform = \"identity\",\n  xlab = \"Time\",\n  ylab = \"Cases\",\n  xlim = NULL,\n  legend = \"Model\"\n)\n\n\n\n\nmodels: A GHRmodels object containing fitted model output.\nmod_id: Character vector of model identifiers (from models$mod_gof$model_id) to plot.\ntime: Character; name of the time-variable column in models$data.\ngroup: Optional; character name of the column defining independent time series (e.g., spatial areas).\ngroup_id: Optional vector of specific group values to subset if group is provided.\nmod_label: Optional custom labels for each model. Can be a named vector (e.g., c(\"mod1\" = \"Base\")) or an unnamed vector with the same length and order as mod_id.\nmod_facet: Logical; if TRUE, faceting is applied by model. Can be combined with group.\npalette: Character; name of the color palette for fitted lines. Default is \"IDE2\".\nref_color: Optional color to override the first model‚Äôs line (reference model).\nobs_color: Color for observed data line. Default is \"black\".\nobs_label: Legend label for observed data. Default is \"Observed\".\ntitle: Character; title of the plot.\nci: Logical; if TRUE, adds 95% credible interval ribbons for model fits.\ntransform: Character string for y-axis transformation. Defaults to \"identity\" (no transform). Other options include \"log10p1\", \"log1p\", \"sqrt\", etc.\nxlab: Label for the x-axis. Default is \"Time\".\nylab: Label for the y-axis. Default is \"Cases\".\nxlim: Character vector of length two in ‚Äúyyyy-mm-dd‚Äù format (e.g., c(\"2010-01-01\", \"2020-12-31\")). Use NA to leave one side open (e.g., c(\"2015-01-01\", NA)).\nlegend: Legend title for model lines. Default is \"Model\".\n\n\n\n\n\nFaceting is flexible: if mod_facet = TRUE and group is provided, both are used.\nIf ci = TRUE, ribbons are plotted for fitted model uncertainty.\nmod_label, ref_color, and obs_color allow full customization of the legend.\nThe function automatically sums values across replicates for grouped time series.\n\n\n\n\nA ggplot2 object:\n\nTime-series line plot of observed vs fitted cases\nOptionally includes credible intervals and facets by model or group\nX-axis can be limited by xlim; Y-axis can be transformed for readability\n\n\n\n\nfit_models to generate GHRmodels.\n\n\n\n## Not run:\n\n# Load example GHRmodels object from the package: \nmodel_list_file &lt;- system.file(\"examples\", \"model_list.rds\", package = \"GHRmodel\")\nmodel_list &lt;- readRDS(model_list_file)\n\n# Plot observed vs. fitted cases over time for three selected models\nplot_fit(\n  models = model_list,                         # A GHRmodels object containing the fitted models\n  mod_id = c(\"mod1\", \"mod3\", \"mod5\"),          # Vector of model IDs to plot\n  mod_label = c(\"Baseline\",                    # Custom display names \n                \"tmin.l1.nl\",                  \n                \"pdsi.l1.nl_tmin.l1.nl\"),            \n  ref_color = \"grey\",                          # Color for the reference model \n  time = \"date\",                               # Name of the time variable \n  palette = \"Set2\",                            # Color palette for fitted lines\n  xlim = c(\"2010-01-01\", \"2020-01-01\"),        # Limit x-axis to this date range\n  title = \"Fitted vs Observed\"                 # Main plot title\n)  \n## End(Not run)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_fit.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_fit.Rd.html#description",
    "title": "Plot Observed vs.¬†Fitted Cases",
    "section": "",
    "text": "This function creates a time-series plot comparing observed cases with fitted values from one or more models in a GHRmodels object. The plot supports faceting by model and/or group.\nplot_fit(\n  models = NULL,\n  mod_id = NULL,\n  time = NULL,\n  group = NULL,\n  group_id = NULL,\n  mod_label = NULL,\n  mod_facet = FALSE,\n  palette = \"IDE2\",\n  ref_color = NULL,\n  obs_color = NULL,\n  obs_label = NULL,\n  title = \"\",\n  ci = FALSE,\n  transform = \"identity\",\n  xlab = \"Time\",\n  ylab = \"Cases\",\n  xlim = NULL,\n  legend = \"Model\"\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_fit.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_fit.Rd.html#arguments",
    "title": "Plot Observed vs.¬†Fitted Cases",
    "section": "",
    "text": "models: A GHRmodels object containing fitted model output.\nmod_id: Character vector of model identifiers (from models$mod_gof$model_id) to plot.\ntime: Character; name of the time-variable column in models$data.\ngroup: Optional; character name of the column defining independent time series (e.g., spatial areas).\ngroup_id: Optional vector of specific group values to subset if group is provided.\nmod_label: Optional custom labels for each model. Can be a named vector (e.g., c(\"mod1\" = \"Base\")) or an unnamed vector with the same length and order as mod_id.\nmod_facet: Logical; if TRUE, faceting is applied by model. Can be combined with group.\npalette: Character; name of the color palette for fitted lines. Default is \"IDE2\".\nref_color: Optional color to override the first model‚Äôs line (reference model).\nobs_color: Color for observed data line. Default is \"black\".\nobs_label: Legend label for observed data. Default is \"Observed\".\ntitle: Character; title of the plot.\nci: Logical; if TRUE, adds 95% credible interval ribbons for model fits.\ntransform: Character string for y-axis transformation. Defaults to \"identity\" (no transform). Other options include \"log10p1\", \"log1p\", \"sqrt\", etc.\nxlab: Label for the x-axis. Default is \"Time\".\nylab: Label for the y-axis. Default is \"Cases\".\nxlim: Character vector of length two in ‚Äúyyyy-mm-dd‚Äù format (e.g., c(\"2010-01-01\", \"2020-12-31\")). Use NA to leave one side open (e.g., c(\"2015-01-01\", NA)).\nlegend: Legend title for model lines. Default is \"Model\"."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_fit.Rd.html#details",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_fit.Rd.html#details",
    "title": "Plot Observed vs.¬†Fitted Cases",
    "section": "",
    "text": "Faceting is flexible: if mod_facet = TRUE and group is provided, both are used.\nIf ci = TRUE, ribbons are plotted for fitted model uncertainty.\nmod_label, ref_color, and obs_color allow full customization of the legend.\nThe function automatically sums values across replicates for grouped time series."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_fit.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_fit.Rd.html#returns",
    "title": "Plot Observed vs.¬†Fitted Cases",
    "section": "",
    "text": "A ggplot2 object:\n\nTime-series line plot of observed vs fitted cases\nOptionally includes credible intervals and facets by model or group\nX-axis can be limited by xlim; Y-axis can be transformed for readability"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_fit.Rd.html#see-also",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_fit.Rd.html#see-also",
    "title": "Plot Observed vs.¬†Fitted Cases",
    "section": "",
    "text": "fit_models to generate GHRmodels."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_fit.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_fit.Rd.html#examples",
    "title": "Plot Observed vs.¬†Fitted Cases",
    "section": "",
    "text": "## Not run:\n\n# Load example GHRmodels object from the package: \nmodel_list_file &lt;- system.file(\"examples\", \"model_list.rds\", package = \"GHRmodel\")\nmodel_list &lt;- readRDS(model_list_file)\n\n# Plot observed vs. fitted cases over time for three selected models\nplot_fit(\n  models = model_list,                         # A GHRmodels object containing the fitted models\n  mod_id = c(\"mod1\", \"mod3\", \"mod5\"),          # Vector of model IDs to plot\n  mod_label = c(\"Baseline\",                    # Custom display names \n                \"tmin.l1.nl\",                  \n                \"pdsi.l1.nl_tmin.l1.nl\"),            \n  ref_color = \"grey\",                          # Color for the reference model \n  time = \"date\",                               # Name of the time variable \n  palette = \"Set2\",                            # Color palette for fitted lines\n  xlim = c(\"2010-01-01\", \"2020-01-01\"),        # Limit x-axis to this date range\n  title = \"Fitted vs Observed\"                 # Main plot title\n)  \n## End(Not run)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_re.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_re.Rd.html",
    "title": "Plot Random Effects",
    "section": "",
    "text": "Generates plots of random effects from one or more fitted models contained within a GHRmodels object. The function supports two main display modes:\n\nCaterpillar plot of effect sizes with uncertainty intervals (the default).\nChoropleth map (when a spatial map (sf object) is provided in the map argument).\n\nIt also supports visualization of replicated or grouped effects via the rep_id argument.\nplot_re(\n  models,\n  mod_id,\n  re_id,\n  rep_id = NULL,\n  map = NULL,\n  map_area = NULL,\n  mod_label = NULL,\n  re_label = NULL,\n  rep_label = NULL,\n  ref_color = NULL,\n  palette = NULL,\n  var_arrange = \"ID\",\n  title = \"\",\n  xlab = \"Re ID\",\n  ylab = \"Effect Size\",\n  legend = \"Effect Size\",\n  centering = 0,\n  exp = FALSE\n)\n\n\n\n\nmodels: A GHRmodels object containing fitted models and random effects.\nmod_id: Character vector of model IDs to plot (must match entries in models$mod_gof$model_id).\nre_id: Character; name of the variable defining the random effect (from models$re).\nrep_id: Optional character string; name of a grouping variable if random effects are replicated. Default is NULL.\nmap: Optional sf object providing spatial geometry. If NULL, returns a caterpillar plot.\nmap_area: Character; column name in map indicating spatial units (must match re_id order).\nmod_label: Optional labels for models. Can be a named vector (e.g., c(\"mod1\" = \"Baseline\", \"mod2\" = \"Adjusted\")) or an unnamed vector with the same order as mod_id.\nre_label: Optional; variable in the data to label the random effect units (e.g., year names instead of numeric IDs).\nrep_label: Optional; label for replicated grouping variable (e.g., for years or time periods).\nref_color: Color used for the reference model. If specified, this will apply to the first model in mod_id.\npalette: Character; name of the color palette to use. Defaults to \"IDE1\" for maps and \"IDE2\" otherwise.\nvar_arrange: Character; how to arrange REs on the x-axis. Options: \"median\" or \"ID\". Default is \"ID\".\ntitle: Title for the plot.\nxlab: Label for the x-axis. Default is \"Re ID\".\nylab: Label for the y-axis. Default is \"Effect Size\".\nlegend: Label for the legend in map plots. Default is \"Effect Size\".\ncentering: Value at which to center the color scale for map plots. Default is 0.\nexp: Logical; if TRUE, exponentiates the effects (useful for log-scale models). Default is FALSE.\n\n\n\n\nPlot Random Effects from GHRmodels\n\nIf map is used, map_area must match a column in map and correspond in order to the RE unit.\nFor BYM/BYM2 models, only the total random effect is plotted (structured/unstructured parts are merged).\nWhen no map is used, the plot compares models via colored points and intervals for each RE unit.\nReplicated REs (e.g., for years) can be plotted across facets using rep_label.\nModel comparison is visually aided using distinct colors; the first model in mod_id is the reference.\n\n\n\n\nA ggplot2 plot object:\n\nIf map is NULL, returns a caterpillar plot showing median REs with 95% uncertainty intervals.\nIf map is provided, returns a faceted choropleth map showing RE medians by area and (optionally) replicate.\n\n\n\n\nfit_models for model fitting; as_GHRformulas for formula setup.\n\n\n\n## Not run:\n\n\n# Load example GHRmodels object from the package: \nmodel_list_file &lt;- system.file(\"examples\", \"model_list.rds\", package = \"GHRmodel\")\nmodel_list &lt;- readRDS(model_list_file)\n\n#  Plot the estimated yearly random effects for three different models.\nplot_re(\nmodel = model_list,                          # A GHRmodels object \nmod_id = c(\"mod1\", \"mod3\", \"mod5\"),          # IDs of the models \n\nmod_label = c(\"Baseline\",                    # Custom labels for the models\n              \"tmin.l1_nl\",           \n              \"pdsi.l1_nl + tmin.l1_nl\"),     \n\nre_id = \"year_id\",                           # Name of the random effect variable \nre_label = \"year\",                           # Label to map year_id to calendar years\n\nref_color = \"grey\",                          # Color for the reference model‚Äôs effects\npalette = \"IDE2\",                            # Color for other model effects\n\ntitle = \"Yearly Random Effect\",              # Title for the plot\nxlab = \"Year\"                                # Label for the x-axis \n)\n## End(Not run)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_re.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_re.Rd.html#description",
    "title": "Plot Random Effects",
    "section": "",
    "text": "Generates plots of random effects from one or more fitted models contained within a GHRmodels object. The function supports two main display modes:\n\nCaterpillar plot of effect sizes with uncertainty intervals (the default).\nChoropleth map (when a spatial map (sf object) is provided in the map argument).\n\nIt also supports visualization of replicated or grouped effects via the rep_id argument.\nplot_re(\n  models,\n  mod_id,\n  re_id,\n  rep_id = NULL,\n  map = NULL,\n  map_area = NULL,\n  mod_label = NULL,\n  re_label = NULL,\n  rep_label = NULL,\n  ref_color = NULL,\n  palette = NULL,\n  var_arrange = \"ID\",\n  title = \"\",\n  xlab = \"Re ID\",\n  ylab = \"Effect Size\",\n  legend = \"Effect Size\",\n  centering = 0,\n  exp = FALSE\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_re.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_re.Rd.html#arguments",
    "title": "Plot Random Effects",
    "section": "",
    "text": "models: A GHRmodels object containing fitted models and random effects.\nmod_id: Character vector of model IDs to plot (must match entries in models$mod_gof$model_id).\nre_id: Character; name of the variable defining the random effect (from models$re).\nrep_id: Optional character string; name of a grouping variable if random effects are replicated. Default is NULL.\nmap: Optional sf object providing spatial geometry. If NULL, returns a caterpillar plot.\nmap_area: Character; column name in map indicating spatial units (must match re_id order).\nmod_label: Optional labels for models. Can be a named vector (e.g., c(\"mod1\" = \"Baseline\", \"mod2\" = \"Adjusted\")) or an unnamed vector with the same order as mod_id.\nre_label: Optional; variable in the data to label the random effect units (e.g., year names instead of numeric IDs).\nrep_label: Optional; label for replicated grouping variable (e.g., for years or time periods).\nref_color: Color used for the reference model. If specified, this will apply to the first model in mod_id.\npalette: Character; name of the color palette to use. Defaults to \"IDE1\" for maps and \"IDE2\" otherwise.\nvar_arrange: Character; how to arrange REs on the x-axis. Options: \"median\" or \"ID\". Default is \"ID\".\ntitle: Title for the plot.\nxlab: Label for the x-axis. Default is \"Re ID\".\nylab: Label for the y-axis. Default is \"Effect Size\".\nlegend: Label for the legend in map plots. Default is \"Effect Size\".\ncentering: Value at which to center the color scale for map plots. Default is 0.\nexp: Logical; if TRUE, exponentiates the effects (useful for log-scale models). Default is FALSE."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_re.Rd.html#details",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_re.Rd.html#details",
    "title": "Plot Random Effects",
    "section": "",
    "text": "Plot Random Effects from GHRmodels\n\nIf map is used, map_area must match a column in map and correspond in order to the RE unit.\nFor BYM/BYM2 models, only the total random effect is plotted (structured/unstructured parts are merged).\nWhen no map is used, the plot compares models via colored points and intervals for each RE unit.\nReplicated REs (e.g., for years) can be plotted across facets using rep_label.\nModel comparison is visually aided using distinct colors; the first model in mod_id is the reference."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_re.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_re.Rd.html#returns",
    "title": "Plot Random Effects",
    "section": "",
    "text": "A ggplot2 plot object:\n\nIf map is NULL, returns a caterpillar plot showing median REs with 95% uncertainty intervals.\nIf map is provided, returns a faceted choropleth map showing RE medians by area and (optionally) replicate."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_re.Rd.html#see-also",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_re.Rd.html#see-also",
    "title": "Plot Random Effects",
    "section": "",
    "text": "fit_models for model fitting; as_GHRformulas for formula setup."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_re.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_re.Rd.html#examples",
    "title": "Plot Random Effects",
    "section": "",
    "text": "## Not run:\n\n\n# Load example GHRmodels object from the package: \nmodel_list_file &lt;- system.file(\"examples\", \"model_list.rds\", package = \"GHRmodel\")\nmodel_list &lt;- readRDS(model_list_file)\n\n#  Plot the estimated yearly random effects for three different models.\nplot_re(\nmodel = model_list,                          # A GHRmodels object \nmod_id = c(\"mod1\", \"mod3\", \"mod5\"),          # IDs of the models \n\nmod_label = c(\"Baseline\",                    # Custom labels for the models\n              \"tmin.l1_nl\",           \n              \"pdsi.l1_nl + tmin.l1_nl\"),     \n\nre_id = \"year_id\",                           # Name of the random effect variable \nre_label = \"year\",                           # Label to map year_id to calendar years\n\nref_color = \"grey\",                          # Color for the reference model‚Äôs effects\npalette = \"IDE2\",                            # Color for other model effects\n\ntitle = \"Yearly Random Effect\",              # Title for the plot\nxlab = \"Year\"                                # Label for the x-axis \n)\n## End(Not run)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/rank_models.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/rank_models.Rd.html",
    "title": "Rank Models by Goodness-of-Fit",
    "section": "",
    "text": "This function ranks fitted models in a GHRmodels object by a chosen metric (e.g., dic, waic, crps, etc.).\nrank_models(models, metric = \"dic\", n = 10)\n\n\n\n\nmodels: A GHRmodels object containing fitted model output.\nmetric: A character string indicating which goodness-of-fit metric to use for ranking. One of: \"dic\", \"waic\",\"lms\",\"mae\", \"rmse\",\"crps\", \"rsq\",\"dic_vs_first\", \"waic_vs_first\", \"mae_vs_first\", \"rmse_vs_first\", \"crps_vs_first\", \"re_n_var\", and \"re_n_var_change\" (where n is the number of random effect, for ex. re_1_var, re_1_var_change).\nn: An integer specifying how many top-ranked models to return (default 10).\n\n\n\n\nA character vector of the top model IDs (in ascending order of the specified metric).\n\n\n\nfit_models for fitting multiple INLA models.\n\n\n\n## Not run:\n\n# Load example GHRmodels object from the package: \nmodel_list_file &lt;- system.file(\"examples\", \"model_list.rds\", package = \"GHRmodel\")\nmodel_list &lt;- readRDS(model_list_file)\n\n# Get a list of the 5 best models by DIC\ntop_model_dic &lt;- rank_models(\n  models = model_list,\n  metric = \"dic\",\n  n = 5\n)\n## End(Not run)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/rank_models.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/rank_models.Rd.html#description",
    "title": "Rank Models by Goodness-of-Fit",
    "section": "",
    "text": "This function ranks fitted models in a GHRmodels object by a chosen metric (e.g., dic, waic, crps, etc.).\nrank_models(models, metric = \"dic\", n = 10)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/rank_models.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/rank_models.Rd.html#arguments",
    "title": "Rank Models by Goodness-of-Fit",
    "section": "",
    "text": "models: A GHRmodels object containing fitted model output.\nmetric: A character string indicating which goodness-of-fit metric to use for ranking. One of: \"dic\", \"waic\",\"lms\",\"mae\", \"rmse\",\"crps\", \"rsq\",\"dic_vs_first\", \"waic_vs_first\", \"mae_vs_first\", \"rmse_vs_first\", \"crps_vs_first\", \"re_n_var\", and \"re_n_var_change\" (where n is the number of random effect, for ex. re_1_var, re_1_var_change).\nn: An integer specifying how many top-ranked models to return (default 10)."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/rank_models.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/rank_models.Rd.html#returns",
    "title": "Rank Models by Goodness-of-Fit",
    "section": "",
    "text": "A character vector of the top model IDs (in ascending order of the specified metric)."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/rank_models.Rd.html#see-also",
    "href": "docs/GHRmodel/GHRmodel-reference/rank_models.Rd.html#see-also",
    "title": "Rank Models by Goodness-of-Fit",
    "section": "",
    "text": "fit_models for fitting multiple INLA models."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/rank_models.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/rank_models.Rd.html#examples",
    "title": "Rank Models by Goodness-of-Fit",
    "section": "",
    "text": "## Not run:\n\n# Load example GHRmodels object from the package: \nmodel_list_file &lt;- system.file(\"examples\", \"model_list.rds\", package = \"GHRmodel\")\nmodel_list &lt;- readRDS(model_list_file)\n\n# Get a list of the 5 best models by DIC\ntop_model_dic &lt;- rank_models(\n  models = model_list,\n  metric = \"dic\",\n  n = 5\n)\n## End(Not run)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/sample_ppd.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/sample_ppd.Rd.html",
    "title": "Sample from the Posterior Predictive Distribution",
    "section": "",
    "text": "This function refits a specified model from a GHRmodels object and generates samples from its posterior predictive distribution.\nsample_ppd(models, mod_id, s = 1000, nthreads = 8)\n\n\n\n\nmodels: A GHRmodels object.\nmod_id: Character; model identifier (from models$mod_gof$model_id).\ns: An integer specifying the number of samples to draw from the posterior predictive distribution.\nnthreads: An integer specifying the number of threads for parallel computation to refit the model. Default is 8.\n\n\n\n\nA data.frame containing columns for each of the posterior predictive samples and one column with observed data.\n\n\n\n## Not run:\n\n\n# Load example GHRmodels object from the package: \nmodel_list_file &lt;- system.file(\"examples\", \"model_list.rds\", package = \"GHRmodel\")\nmodel_list &lt;- readRDS(model_list_file)\n\n# Generate 1000 samples from the posterior predictive distribution of model 3.\nppd_df &lt;- sample_ppd( \n  model_list,\n  mod_id = \"mod3\", \n  s = 1000,\n  nthreads = 2)\n## End(Not run)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/sample_ppd.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/sample_ppd.Rd.html#description",
    "title": "Sample from the Posterior Predictive Distribution",
    "section": "",
    "text": "This function refits a specified model from a GHRmodels object and generates samples from its posterior predictive distribution.\nsample_ppd(models, mod_id, s = 1000, nthreads = 8)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/sample_ppd.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/sample_ppd.Rd.html#arguments",
    "title": "Sample from the Posterior Predictive Distribution",
    "section": "",
    "text": "models: A GHRmodels object.\nmod_id: Character; model identifier (from models$mod_gof$model_id).\ns: An integer specifying the number of samples to draw from the posterior predictive distribution.\nnthreads: An integer specifying the number of threads for parallel computation to refit the model. Default is 8."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/sample_ppd.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/sample_ppd.Rd.html#returns",
    "title": "Sample from the Posterior Predictive Distribution",
    "section": "",
    "text": "A data.frame containing columns for each of the posterior predictive samples and one column with observed data."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/sample_ppd.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/sample_ppd.Rd.html#examples",
    "title": "Sample from the Posterior Predictive Distribution",
    "section": "",
    "text": "## Not run:\n\n\n# Load example GHRmodels object from the package: \nmodel_list_file &lt;- system.file(\"examples\", \"model_list.rds\", package = \"GHRmodel\")\nmodel_list &lt;- readRDS(model_list_file)\n\n# Generate 1000 samples from the posterior predictive distribution of model 3.\nppd_df &lt;- sample_ppd( \n  model_list,\n  mod_id = \"mod3\", \n  s = 1000,\n  nthreads = 2)\n## End(Not run)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/extract_names.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/extract_names.Rd.html",
    "title": "Extract Covariate Names",
    "section": "",
    "text": "This function allows the user to select variables from a data set by prefix (using the pattern argument) or by exact name matching. The return object is a character vector with the selected covariate names that can be used as input for cov_add, cov_uni, cov_multi, cov_interact, cov_nl, and cov_varying functions.\nextract_names(data = NULL, pattern = NULL, name = NULL)\n\n\n\n\ndata: A data.frame containing the variables.\npattern: A character vector specifying prefix(es) to match (e.g., ‚Äútmin‚Äù matches ‚Äútmin‚Äù, ‚Äútmin.l1‚Äù, etc.).\nname: A character vector of exact variable name(s) to extract.\n\n\n\n\nA character vector of matched covariate names.\n\n\n\ndata &lt;- data.frame(tmin = 1:10, tmin.l1 = 1:10, urban = 1:10)\nextract_names(data, pattern = \"tmin\")\nextract_names(data, name = \"urban\")\nextract_names(data, pattern = \"tmin\", name = \"urban\")"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/extract_names.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/extract_names.Rd.html#description",
    "title": "Extract Covariate Names",
    "section": "",
    "text": "This function allows the user to select variables from a data set by prefix (using the pattern argument) or by exact name matching. The return object is a character vector with the selected covariate names that can be used as input for cov_add, cov_uni, cov_multi, cov_interact, cov_nl, and cov_varying functions.\nextract_names(data = NULL, pattern = NULL, name = NULL)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/extract_names.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/extract_names.Rd.html#arguments",
    "title": "Extract Covariate Names",
    "section": "",
    "text": "data: A data.frame containing the variables.\npattern: A character vector specifying prefix(es) to match (e.g., ‚Äútmin‚Äù matches ‚Äútmin‚Äù, ‚Äútmin.l1‚Äù, etc.).\nname: A character vector of exact variable name(s) to extract."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/extract_names.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/extract_names.Rd.html#returns",
    "title": "Extract Covariate Names",
    "section": "",
    "text": "A character vector of matched covariate names."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/extract_names.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/extract_names.Rd.html#examples",
    "title": "Extract Covariate Names",
    "section": "",
    "text": "data &lt;- data.frame(tmin = 1:10, tmin.l1 = 1:10, urban = 1:10)\nextract_names(data, pattern = \"tmin\")\nextract_names(data, name = \"urban\")\nextract_names(data, pattern = \"tmin\", name = \"urban\")"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/stack_models.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/stack_models.Rd.html",
    "title": "Merge GHRmodels",
    "section": "",
    "text": "This function stack together two or more objects GHRmodels object, returning one GHRmodels object that contains all the input models.\nIf any model_id is duplicated across the inputs the new_name argument must be provided to ensure unique IDs.\nstack_models(..., new_name = NULL, vs_first = FALSE)\n\n\n\n\n...: Two or more GHRmodels objects, or a single list of them.\nnew_name: NULL (default) or a character used to build the new model IDs.\nvs_first: Logical. If TRUE columns comparing the model vs the first model are kept in the mod_gof, otherwise are discarded. Default is FALSE. Set to TRUE only when models contained in the GHRmodels object to be stacked are compared with the same first models.\n\n\n\n\nCombine (Stack) Multiple GHRmodels Objects\n\n\n\nA single GHRmodels object containing all models from the inputs.\n\n\n\nsubset_models for subsetting GHRmodels objects, fit_models for fitting INLA models.\n\n\n\n## Not run:\n\n\n# Load example GHRmodels object from the package: \nmodel_list_file &lt;- system.file(\"examples\", \"model_list.rds\", package = \"GHRmodel\")\nmodel_list &lt;- readRDS(model_list_file)\n\n# Load example GHRmodels object with DLNM from the package:\nmodel_dlnm_file &lt;- system.file(\"examples\", \"model_dlnm.rds\", package = \"GHRmodel\")\nmodel_dlnm &lt;- readRDS(model_dlnm_file)\n\n# Merge models from the model_list and model_dlnm objects\nmodel_stack &lt;- stack_models( \n  model_list,\n  model_dlnm, \n  new_name = \"mod\")\n  \n# The combined model_stack combines the models in the model_list and model_dlnm objects\nmodel_stack$mod_gof$model_id  \n## End(Not run)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/stack_models.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/stack_models.Rd.html#description",
    "title": "Merge GHRmodels",
    "section": "",
    "text": "This function stack together two or more objects GHRmodels object, returning one GHRmodels object that contains all the input models.\nIf any model_id is duplicated across the inputs the new_name argument must be provided to ensure unique IDs.\nstack_models(..., new_name = NULL, vs_first = FALSE)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/stack_models.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/stack_models.Rd.html#arguments",
    "title": "Merge GHRmodels",
    "section": "",
    "text": "...: Two or more GHRmodels objects, or a single list of them.\nnew_name: NULL (default) or a character used to build the new model IDs.\nvs_first: Logical. If TRUE columns comparing the model vs the first model are kept in the mod_gof, otherwise are discarded. Default is FALSE. Set to TRUE only when models contained in the GHRmodels object to be stacked are compared with the same first models."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/stack_models.Rd.html#details",
    "href": "docs/GHRmodel/GHRmodel-reference/stack_models.Rd.html#details",
    "title": "Merge GHRmodels",
    "section": "",
    "text": "Combine (Stack) Multiple GHRmodels Objects"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/stack_models.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/stack_models.Rd.html#returns",
    "title": "Merge GHRmodels",
    "section": "",
    "text": "A single GHRmodels object containing all models from the inputs."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/stack_models.Rd.html#see-also",
    "href": "docs/GHRmodel/GHRmodel-reference/stack_models.Rd.html#see-also",
    "title": "Merge GHRmodels",
    "section": "",
    "text": "subset_models for subsetting GHRmodels objects, fit_models for fitting INLA models."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/stack_models.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/stack_models.Rd.html#examples",
    "title": "Merge GHRmodels",
    "section": "",
    "text": "## Not run:\n\n\n# Load example GHRmodels object from the package: \nmodel_list_file &lt;- system.file(\"examples\", \"model_list.rds\", package = \"GHRmodel\")\nmodel_list &lt;- readRDS(model_list_file)\n\n# Load example GHRmodels object with DLNM from the package:\nmodel_dlnm_file &lt;- system.file(\"examples\", \"model_dlnm.rds\", package = \"GHRmodel\")\nmodel_dlnm &lt;- readRDS(model_dlnm_file)\n\n# Merge models from the model_list and model_dlnm objects\nmodel_stack &lt;- stack_models( \n  model_list,\n  model_dlnm, \n  new_name = \"mod\")\n  \n# The combined model_stack combines the models in the model_list and model_dlnm objects\nmodel_stack$mod_gof$model_id  \n## End(Not run)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/write_inla_formulas.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/write_inla_formulas.Rd.html",
    "title": "Generate INLA-compatible Model Formulas",
    "section": "",
    "text": "This function streamlines the creation of INLA-compatible model formulas by automatically structuring fixed effects, random effects, and interactions. It accepts a list of covariate sets and produces a corresponding set of model formulas that share a common random effect structure.\nwrite_inla_formulas(\n  outcome,\n  covariates = NULL,\n  baseline = TRUE,\n  re1 = list(id = NULL, model = NULL, replicate = NULL, group = NULL, graph = NULL,\n    cyclic = FALSE, scale.model = FALSE, constr = FALSE, adjust.for.con.comp = FALSE,\n    hyper = NULL),\n  re2 = NULL,\n  re3 = NULL,\n  re4 = NULL,\n  re5 = NULL\n)\n\n\n\n\noutcome: Character string specifying the name of the outcome variable.\ncovariates: A list of character vectors, where each vector contains covariate names to be included in the model. If a single vector is provided, a single model formula is generated.\nbaseline: Logical; If TRUE, a baseline formula without covariates is included. If no random effects are specified, this will be an intercept-only model. If random effects are specified, the baseline formula will include random effects but not covariates. This formula will be the first in the list. Default is TRUE.\nre1: A list defining a random effect structure. Up to five such lists (re1 through re5) can be passed.\nre2: Additional random effect definitions, as described for re1.\nre3: Additional random effect definitions, as described for re1.\nre4: Additional random effect definitions, as described for re1.\nre5: Additional random effect definitions, as described for re1.\n\n\n\n\nThe write_inla_formulas() function simplifies the creation of multiple INLA models by automatically structuring fixed effects, random effects, and interactions. The function ensures that all models have a consistent structure, making them easier to analyze and modify.\nIf baseline = TRUE, a null formula (without covariates) is included as the first element of the list.\nThe number of formulas generated depends on the length of the covariates list.\nRandom effects can be added using re1, ..., re5, where each effect must be a named list (e.g.¬†re1 = list(id = ‚Äúyear_id‚Äù, model = ‚Äúrw1‚Äù)). In the list the following fields are strictly necessary:\n\nid (character): the variable name that indexes the random effect (e.g., ‚Äúyear‚Äù, ‚Äúregion‚Äù).\nmodel (character): the type of random effect. Supported values include: \"iid\", \"rw1\", \"rw2\", \"bym\", and \"bym2\".\nThe following optional fields can be provided in the random effect list:\n\nreplicate (character): defines an additional variable used to replicate the random effect structure across groups (e.g., spatial units for repeated time-series).\ngroup (character): used to model group-specific effects or nested structures.\ngraph (character): required for \"bym\" and \"bym2\" models; refers to the name of an object in the environment that holds the spatial adjacency matrix.\ncyclic (logical): indicates whether the random walk (\"rw1\" or \"rw2\") is cyclic. Default is FALSE. Use for periodic structures (e.g., months).\nscale.model (logical): if TRUE, scales structured random effects (like rw1, rw2, bym) so the generalized variance is 1. For bym2 INLA automatically applies scale.model = TRUE internally.\nconstr (logical): If TRUE, a sum to zero constrain is introduced. This ‚Äòconstr‚Äô option is applied only to ‚Äòiid‚Äô random effects. For rw, ar, bym, bym2 INLA automatically applies scale.model = TRUE internally.\nadjust.for.con.comp (logical): if TRUE, accounts for disconnected components in spatial graphs. Recommended for \"bym\" and \"bym2\". Default is FALSE.\nhyper (character): the name of an object in the environment that contains the hyperprior specification for the random effect‚Äôs precision or other parameters.\n\n\nFor more information on random effects in R-INLA, see Bayesian inference with INLA: Mixed-effects Models.\n\n\n\nA character vector of INLA model formulas.\n\n\n\nas_GHRformulas for transforming model formulas into structured objects.\n\n\n\n# Define covariates of interest\ncovs &lt;- c(\"tmin.l1\", \"tmin.l2\", \"pdsi.l1\", \"pdsi.l2\", \"urban_level\")\n\n# Combine covariate names using a pattern-matching functionality\ncombined_covariates &lt;- cov_multi(\n  covariates = covs,\n  pattern    = c(\"tmin\", \"pdsi\", \"urban_level\")\n)\n\n# Define hyperprior specifications for random effects\nprior_re1 &lt;- list(prec = list(prior = \"loggamma\", param = c(0.01, 0.01)))\nprior_re2 &lt;- list(prec = list(prior = \"loggamma\", param = c(0.01, 0.01)))\nprior_re3 &lt;- list(\n  prec = list(prior = \"pc.prec\", param = c(0.5 / 0.31, 0.01)),\n  phi  = list(prior = \"pc\",      param = c(0.5, 2 / 3))\n)\n\n# Write a set of INLA-compatible model formulas\ninla_formulas &lt;- write_inla_formulas(\n  outcome    = \"dengue_cases\",\n  covariates = combined_covariates,\n  re1 = list(\n    id        = \"month_id\",\n    model        = \"rw1\",\n    cyclic    = TRUE,\n    hyper     = \"prior_re1\",\n    replicate = \"spat_meso_id\"\n  ),\n  re2 = list(\n    id    = \"year_id\",\n    model    = \"rw1\",\n    hyper = \"prior_re2\"\n  ),\n  re3 = list(\n    id    = \"spat_id\",\n    model    = \"iid\",\n    hyper = \"prior_re3\"\n  ),\n  baseline = TRUE\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/write_inla_formulas.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/write_inla_formulas.Rd.html#description",
    "title": "Generate INLA-compatible Model Formulas",
    "section": "",
    "text": "This function streamlines the creation of INLA-compatible model formulas by automatically structuring fixed effects, random effects, and interactions. It accepts a list of covariate sets and produces a corresponding set of model formulas that share a common random effect structure.\nwrite_inla_formulas(\n  outcome,\n  covariates = NULL,\n  baseline = TRUE,\n  re1 = list(id = NULL, model = NULL, replicate = NULL, group = NULL, graph = NULL,\n    cyclic = FALSE, scale.model = FALSE, constr = FALSE, adjust.for.con.comp = FALSE,\n    hyper = NULL),\n  re2 = NULL,\n  re3 = NULL,\n  re4 = NULL,\n  re5 = NULL\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/write_inla_formulas.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/write_inla_formulas.Rd.html#arguments",
    "title": "Generate INLA-compatible Model Formulas",
    "section": "",
    "text": "outcome: Character string specifying the name of the outcome variable.\ncovariates: A list of character vectors, where each vector contains covariate names to be included in the model. If a single vector is provided, a single model formula is generated.\nbaseline: Logical; If TRUE, a baseline formula without covariates is included. If no random effects are specified, this will be an intercept-only model. If random effects are specified, the baseline formula will include random effects but not covariates. This formula will be the first in the list. Default is TRUE.\nre1: A list defining a random effect structure. Up to five such lists (re1 through re5) can be passed.\nre2: Additional random effect definitions, as described for re1.\nre3: Additional random effect definitions, as described for re1.\nre4: Additional random effect definitions, as described for re1.\nre5: Additional random effect definitions, as described for re1."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/write_inla_formulas.Rd.html#details",
    "href": "docs/GHRmodel/GHRmodel-reference/write_inla_formulas.Rd.html#details",
    "title": "Generate INLA-compatible Model Formulas",
    "section": "",
    "text": "The write_inla_formulas() function simplifies the creation of multiple INLA models by automatically structuring fixed effects, random effects, and interactions. The function ensures that all models have a consistent structure, making them easier to analyze and modify.\nIf baseline = TRUE, a null formula (without covariates) is included as the first element of the list.\nThe number of formulas generated depends on the length of the covariates list.\nRandom effects can be added using re1, ..., re5, where each effect must be a named list (e.g.¬†re1 = list(id = ‚Äúyear_id‚Äù, model = ‚Äúrw1‚Äù)). In the list the following fields are strictly necessary:\n\nid (character): the variable name that indexes the random effect (e.g., ‚Äúyear‚Äù, ‚Äúregion‚Äù).\nmodel (character): the type of random effect. Supported values include: \"iid\", \"rw1\", \"rw2\", \"bym\", and \"bym2\".\nThe following optional fields can be provided in the random effect list:\n\nreplicate (character): defines an additional variable used to replicate the random effect structure across groups (e.g., spatial units for repeated time-series).\ngroup (character): used to model group-specific effects or nested structures.\ngraph (character): required for \"bym\" and \"bym2\" models; refers to the name of an object in the environment that holds the spatial adjacency matrix.\ncyclic (logical): indicates whether the random walk (\"rw1\" or \"rw2\") is cyclic. Default is FALSE. Use for periodic structures (e.g., months).\nscale.model (logical): if TRUE, scales structured random effects (like rw1, rw2, bym) so the generalized variance is 1. For bym2 INLA automatically applies scale.model = TRUE internally.\nconstr (logical): If TRUE, a sum to zero constrain is introduced. This ‚Äòconstr‚Äô option is applied only to ‚Äòiid‚Äô random effects. For rw, ar, bym, bym2 INLA automatically applies scale.model = TRUE internally.\nadjust.for.con.comp (logical): if TRUE, accounts for disconnected components in spatial graphs. Recommended for \"bym\" and \"bym2\". Default is FALSE.\nhyper (character): the name of an object in the environment that contains the hyperprior specification for the random effect‚Äôs precision or other parameters.\n\n\nFor more information on random effects in R-INLA, see Bayesian inference with INLA: Mixed-effects Models."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/write_inla_formulas.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/write_inla_formulas.Rd.html#returns",
    "title": "Generate INLA-compatible Model Formulas",
    "section": "",
    "text": "A character vector of INLA model formulas."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/write_inla_formulas.Rd.html#see-also",
    "href": "docs/GHRmodel/GHRmodel-reference/write_inla_formulas.Rd.html#see-also",
    "title": "Generate INLA-compatible Model Formulas",
    "section": "",
    "text": "as_GHRformulas for transforming model formulas into structured objects."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/write_inla_formulas.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/write_inla_formulas.Rd.html#examples",
    "title": "Generate INLA-compatible Model Formulas",
    "section": "",
    "text": "# Define covariates of interest\ncovs &lt;- c(\"tmin.l1\", \"tmin.l2\", \"pdsi.l1\", \"pdsi.l2\", \"urban_level\")\n\n# Combine covariate names using a pattern-matching functionality\ncombined_covariates &lt;- cov_multi(\n  covariates = covs,\n  pattern    = c(\"tmin\", \"pdsi\", \"urban_level\")\n)\n\n# Define hyperprior specifications for random effects\nprior_re1 &lt;- list(prec = list(prior = \"loggamma\", param = c(0.01, 0.01)))\nprior_re2 &lt;- list(prec = list(prior = \"loggamma\", param = c(0.01, 0.01)))\nprior_re3 &lt;- list(\n  prec = list(prior = \"pc.prec\", param = c(0.5 / 0.31, 0.01)),\n  phi  = list(prior = \"pc\",      param = c(0.5, 2 / 3))\n)\n\n# Write a set of INLA-compatible model formulas\ninla_formulas &lt;- write_inla_formulas(\n  outcome    = \"dengue_cases\",\n  covariates = combined_covariates,\n  re1 = list(\n    id        = \"month_id\",\n    model        = \"rw1\",\n    cyclic    = TRUE,\n    hyper     = \"prior_re1\",\n    replicate = \"spat_meso_id\"\n  ),\n  re2 = list(\n    id    = \"year_id\",\n    model    = \"rw1\",\n    hyper = \"prior_re2\"\n  ),\n  re3 = list(\n    id    = \"spat_id\",\n    model    = \"iid\",\n    hyper = \"prior_re3\"\n  ),\n  baseline = TRUE\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_coef_lin.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_coef_lin.Rd.html",
    "title": "Produce a Forest Plot of Linear Covariates from a GHRmodels Object",
    "section": "",
    "text": "This function extracts fixed-effect coefficients from a specified model in models, filters them by name or interaction pattern, and produces a forest plot (point estimates with error bars).\n\nIf name = NULL, all fixed-effect terms (excluding the intercept) are shown.\nIf name is a character vector, only the matching terms are included.\n\nplot_coef_lin(\n  models,\n  mod_id = NULL,\n  name = NULL,\n  pattern = NULL,\n  title = NULL,\n  mod_label = NULL,\n  var_label = NULL,\n  palette = \"IDE2\",\n  exp = FALSE,\n  legend = \"Model\"\n)\n\n\n\n\nmodels: An object of class GHRmodels containing fitted model output.\nmod_id: Character vector of model identifiers (must match entries in model$mod_gof$model_id). If NULL (the default), all models are considered.\nname: A character vector specifying exact linear covariates names to be plotted. If both pattern and name are NULL (the default), all terms (except (Intercept)) are plotted.\npattern: A character vector specifying prefix(es) to match (e.g., ‚Äútmin‚Äù matches ‚Äútmin‚Äù, ‚Äútmin.l1‚Äù, etc.) Covariates matching these patterns (case‚Äêinsensitive search) will be plotted. If both pattern and name are NULL (the default), all terms (except (Intercept)) are plotted.\ntitle: An optional string specifying an overall plot title.\nmod_label: An optional named character vector mapping model names to custom labels, e.g.¬†c(‚Äúmod1‚Äù = ‚ÄúModel 1‚Äù). Any model not found in the vector names retains its original label.\nvar_label: An optional named character vector mapping variable (or interaction) names to custom labels. Interaction matching is order-insensitive: \"A:B\" matches \"B:A\". Any term not found in the vector names retains its original label.\npalette: GHR, RColorBrewer or colorspace palette (e.g.¬†‚ÄúPurp‚Äù) colour palette to use for the different models. See all available options by running GHR_palettes(), RColorBrewer::display.brewer.all() and colorspace::hcl_palettes(plot=TRUE). Single R colors in colors() or hex codes can also be used.\nexp: Logical,if TRUE the coefficients are exponentiated, Default is if FALSE.\nlegend: Legend title for the replicate color scale. Default is \"Model\".\n\n\n\n\n\nIntercept: By default, (Intercept) is excluded unless explicitly included in name.\nIndividual terms: e.g., \"temp\".\nInteraction Terms: e.g.¬†\"temp:precip\". Split by :, sorted, and compared setwise; for example, \"temp:precip\" matches \"precip:temp\".\nLabels: If var_label is supplied, any matched covariate or interaction string is replaced by its custom label on the y-axis.\n\n\n\n\nA ggplot2 forest plot object (class ggplot).\n\n\n\ngeom_errorbar for the plotting environment.\n\n\n\n# Load example GHRmodels object from the package: \nmodel_list_file &lt;- system.file(\"examples\", \"model_list.rds\", package = \"GHRmodel\")\nmodel_list &lt;- readRDS(model_list_file)\n\n# Plot point estimates with confidence intervals for the linear covariates: \nplot_coef_lin(\nmodel = model_list,\nmod_id = c(\"mod2\",\"mod4\"),\nvar_label = c(\"tmin.l1\"= \"Min. temp lag 1\",\n              \"pdsi.l1\" = \"Drought index lag 1\"),\ntitle = \"Effects of linear covariates\"\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_coef_lin.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_coef_lin.Rd.html#description",
    "title": "Produce a Forest Plot of Linear Covariates from a GHRmodels Object",
    "section": "",
    "text": "This function extracts fixed-effect coefficients from a specified model in models, filters them by name or interaction pattern, and produces a forest plot (point estimates with error bars).\n\nIf name = NULL, all fixed-effect terms (excluding the intercept) are shown.\nIf name is a character vector, only the matching terms are included.\n\nplot_coef_lin(\n  models,\n  mod_id = NULL,\n  name = NULL,\n  pattern = NULL,\n  title = NULL,\n  mod_label = NULL,\n  var_label = NULL,\n  palette = \"IDE2\",\n  exp = FALSE,\n  legend = \"Model\"\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_coef_lin.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_coef_lin.Rd.html#arguments",
    "title": "Produce a Forest Plot of Linear Covariates from a GHRmodels Object",
    "section": "",
    "text": "models: An object of class GHRmodels containing fitted model output.\nmod_id: Character vector of model identifiers (must match entries in model$mod_gof$model_id). If NULL (the default), all models are considered.\nname: A character vector specifying exact linear covariates names to be plotted. If both pattern and name are NULL (the default), all terms (except (Intercept)) are plotted.\npattern: A character vector specifying prefix(es) to match (e.g., ‚Äútmin‚Äù matches ‚Äútmin‚Äù, ‚Äútmin.l1‚Äù, etc.) Covariates matching these patterns (case‚Äêinsensitive search) will be plotted. If both pattern and name are NULL (the default), all terms (except (Intercept)) are plotted.\ntitle: An optional string specifying an overall plot title.\nmod_label: An optional named character vector mapping model names to custom labels, e.g.¬†c(‚Äúmod1‚Äù = ‚ÄúModel 1‚Äù). Any model not found in the vector names retains its original label.\nvar_label: An optional named character vector mapping variable (or interaction) names to custom labels. Interaction matching is order-insensitive: \"A:B\" matches \"B:A\". Any term not found in the vector names retains its original label.\npalette: GHR, RColorBrewer or colorspace palette (e.g.¬†‚ÄúPurp‚Äù) colour palette to use for the different models. See all available options by running GHR_palettes(), RColorBrewer::display.brewer.all() and colorspace::hcl_palettes(plot=TRUE). Single R colors in colors() or hex codes can also be used.\nexp: Logical,if TRUE the coefficients are exponentiated, Default is if FALSE.\nlegend: Legend title for the replicate color scale. Default is \"Model\"."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_coef_lin.Rd.html#details",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_coef_lin.Rd.html#details",
    "title": "Produce a Forest Plot of Linear Covariates from a GHRmodels Object",
    "section": "",
    "text": "Intercept: By default, (Intercept) is excluded unless explicitly included in name.\nIndividual terms: e.g., \"temp\".\nInteraction Terms: e.g.¬†\"temp:precip\". Split by :, sorted, and compared setwise; for example, \"temp:precip\" matches \"precip:temp\".\nLabels: If var_label is supplied, any matched covariate or interaction string is replaced by its custom label on the y-axis."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_coef_lin.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_coef_lin.Rd.html#returns",
    "title": "Produce a Forest Plot of Linear Covariates from a GHRmodels Object",
    "section": "",
    "text": "A ggplot2 forest plot object (class ggplot)."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_coef_lin.Rd.html#see-also",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_coef_lin.Rd.html#see-also",
    "title": "Produce a Forest Plot of Linear Covariates from a GHRmodels Object",
    "section": "",
    "text": "geom_errorbar for the plotting environment."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_coef_lin.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_coef_lin.Rd.html#examples",
    "title": "Produce a Forest Plot of Linear Covariates from a GHRmodels Object",
    "section": "",
    "text": "# Load example GHRmodels object from the package: \nmodel_list_file &lt;- system.file(\"examples\", \"model_list.rds\", package = \"GHRmodel\")\nmodel_list &lt;- readRDS(model_list_file)\n\n# Plot point estimates with confidence intervals for the linear covariates: \nplot_coef_lin(\nmodel = model_list,\nmod_id = c(\"mod2\",\"mod4\"),\nvar_label = c(\"tmin.l1\"= \"Min. temp lag 1\",\n              \"pdsi.l1\" = \"Drought index lag 1\"),\ntitle = \"Effects of linear covariates\"\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_varying.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_varying.Rd.html",
    "title": "Create Spatially or Temporally Varying Effects for INLA",
    "section": "",
    "text": "This function transforms covariates identified by pattern or name into varying effect terms of the form:f(unit, covariate, model = 'iid'), which allows covariates to have varying slopes across spatial or temporal units. The output can be used directly in the covariates argument of write_inla_formulas.\ncov_varying(\n  covariates,\n  unit,\n  pattern = NULL,\n  name = NULL,\n  model = \"iid\",\n  constr = FALSE,\n  add = FALSE\n)\n\n\n\n\ncovariates: A character vector or a list of character vectors of covariate names. Typically output from cov_multi, cov_uni, or extract_names.\nunit: Character string specifying the unit of variation (e.g., \"spat_id\", \"year\").\npattern: A character vector specifying the prefix pattern(s) to match (e.g., ‚Äútmin‚Äù matches ‚Äútmin‚Äù, ‚Äútmin.l1‚Äù, etc.) for transformation.\nname: Character vector of exact variable names to be transformed.\nmodel: Character string specifying the INLA model for the varying effect. Currently, only \"iid\" is supported.\nconstr: Logical. If TRUE it will impose a sum-to-zero constraint to the random effect. Default is FALSE.\nadd: Logical; if TRUE, appends the transformed covariates to the original ones. Default is FALSE.\n\n\n\n\n\nUse pattern or name (or both) to specify which covariates to transform.\nThe resulting terms use INLA‚Äôs f() syntax: f(unit, covariate, model = \"iid\").\nCurrently only supports \"iid\" models for varying effects.\n\n\n\n\nA list of character vectors, each including covariates with varying effects. The output is suitable as input for write_inla_formulas.\n\n\n\ndata &lt;- data.frame(tmin.l1 = rnorm(10), pdsi.l1 = rnorm(10))\n\ncovs &lt;- extract_names(data, pattern = c(\"tmin\", \"pdsi\"))\ncovlist &lt;- cov_multi(covs, pattern = c(\"tmin\", \"pdsi\"))\n\n# Apply varying effect to tmin\ncov_varying(covlist, pattern = \"tmin\", unit = \"spat_id\")\n\n# Keep original and add varying effect terms\ncov_varying(covlist, pattern = \"tmin\", unit = \"spat_id\", add = TRUE)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_varying.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_varying.Rd.html#description",
    "title": "Create Spatially or Temporally Varying Effects for INLA",
    "section": "",
    "text": "This function transforms covariates identified by pattern or name into varying effect terms of the form:f(unit, covariate, model = 'iid'), which allows covariates to have varying slopes across spatial or temporal units. The output can be used directly in the covariates argument of write_inla_formulas.\ncov_varying(\n  covariates,\n  unit,\n  pattern = NULL,\n  name = NULL,\n  model = \"iid\",\n  constr = FALSE,\n  add = FALSE\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_varying.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_varying.Rd.html#arguments",
    "title": "Create Spatially or Temporally Varying Effects for INLA",
    "section": "",
    "text": "covariates: A character vector or a list of character vectors of covariate names. Typically output from cov_multi, cov_uni, or extract_names.\nunit: Character string specifying the unit of variation (e.g., \"spat_id\", \"year\").\npattern: A character vector specifying the prefix pattern(s) to match (e.g., ‚Äútmin‚Äù matches ‚Äútmin‚Äù, ‚Äútmin.l1‚Äù, etc.) for transformation.\nname: Character vector of exact variable names to be transformed.\nmodel: Character string specifying the INLA model for the varying effect. Currently, only \"iid\" is supported.\nconstr: Logical. If TRUE it will impose a sum-to-zero constraint to the random effect. Default is FALSE.\nadd: Logical; if TRUE, appends the transformed covariates to the original ones. Default is FALSE."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_varying.Rd.html#details",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_varying.Rd.html#details",
    "title": "Create Spatially or Temporally Varying Effects for INLA",
    "section": "",
    "text": "Use pattern or name (or both) to specify which covariates to transform.\nThe resulting terms use INLA‚Äôs f() syntax: f(unit, covariate, model = \"iid\").\nCurrently only supports \"iid\" models for varying effects."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_varying.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_varying.Rd.html#returns",
    "title": "Create Spatially or Temporally Varying Effects for INLA",
    "section": "",
    "text": "A list of character vectors, each including covariates with varying effects. The output is suitable as input for write_inla_formulas."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_varying.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_varying.Rd.html#examples",
    "title": "Create Spatially or Temporally Varying Effects for INLA",
    "section": "",
    "text": "data &lt;- data.frame(tmin.l1 = rnorm(10), pdsi.l1 = rnorm(10))\n\ncovs &lt;- extract_names(data, pattern = c(\"tmin\", \"pdsi\"))\ncovlist &lt;- cov_multi(covs, pattern = c(\"tmin\", \"pdsi\"))\n\n# Apply varying effect to tmin\ncov_varying(covlist, pattern = \"tmin\", unit = \"spat_id\")\n\n# Keep original and add varying effect terms\ncov_varying(covlist, pattern = \"tmin\", unit = \"spat_id\", add = TRUE)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/lag_cov.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/lag_cov.Rd.html",
    "title": "Generate lagged variables for one or more lags",
    "section": "",
    "text": "This function creates lagged versions of one or more numeric or categorical variables in an equally spaced time-series data set. A single call can create multiple lags for each selected variable and, optionally, for each spatial/grouping unit.\nlag_cov(data, name, time, lag, group = NULL, add = TRUE)\n\n\n\n\ndata: A data.frame containing equally spaced observations.\nname: A character vector: name of the variable (or variables) to lag.\ntime: A single character string: name of the time-index variable (e.g., \"date\").\nlag: A numeric vector of one or more positive integers. Each value is interpreted as a ‚Äòlag‚Äô (i.e.¬†shift the series backward by k observations).\ngroup: Optional character vector naming column(s) that define independent time-series (e.g.¬†regions). If NULL, the whole data set is treated as one series.\nadd: Logical. If TRUE (default) the lagged columns are appended to data; if FALSE the function returns only the lagged columns as a matrix.\n\n\n\n\nEither a data frame (when add = TRUE) containing the original data plus the new lagged columns, or a numeric matrix of lagged values (when add = FALSE).\n\n\n\n## Daily series for two micro-regions\nd &lt;- data.frame(\n  date       = as.Date(\"2023-01-01\") + 0:9,\n  micro_code = rep(c(\"A\", \"B\"), each = 5),\n  tmin       = rnorm(10, 10, 2),\n  pdsi       = rnorm(10)\n)\n\n## Create lags 1 to 3 for tmin and pdsi\nlagged &lt;- lag_cov(\n  data  = d,\n  name   = c(\"tmin\", \"pdsi\"),\n  time  = \"date\",\n  group = \"micro_code\",\n  lag   = c(1:3)\n)\n\n## Only lagged columns (matrix),\nlag_only &lt;- lag_cov(\n  data = d, name = \"tmin\", time = \"date\",\n  lag  = c(1:3), add = FALSE\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/lag_cov.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/lag_cov.Rd.html#description",
    "title": "Generate lagged variables for one or more lags",
    "section": "",
    "text": "This function creates lagged versions of one or more numeric or categorical variables in an equally spaced time-series data set. A single call can create multiple lags for each selected variable and, optionally, for each spatial/grouping unit.\nlag_cov(data, name, time, lag, group = NULL, add = TRUE)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/lag_cov.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/lag_cov.Rd.html#arguments",
    "title": "Generate lagged variables for one or more lags",
    "section": "",
    "text": "data: A data.frame containing equally spaced observations.\nname: A character vector: name of the variable (or variables) to lag.\ntime: A single character string: name of the time-index variable (e.g., \"date\").\nlag: A numeric vector of one or more positive integers. Each value is interpreted as a ‚Äòlag‚Äô (i.e.¬†shift the series backward by k observations).\ngroup: Optional character vector naming column(s) that define independent time-series (e.g.¬†regions). If NULL, the whole data set is treated as one series.\nadd: Logical. If TRUE (default) the lagged columns are appended to data; if FALSE the function returns only the lagged columns as a matrix."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/lag_cov.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/lag_cov.Rd.html#returns",
    "title": "Generate lagged variables for one or more lags",
    "section": "",
    "text": "Either a data frame (when add = TRUE) containing the original data plus the new lagged columns, or a numeric matrix of lagged values (when add = FALSE)."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/lag_cov.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/lag_cov.Rd.html#examples",
    "title": "Generate lagged variables for one or more lags",
    "section": "",
    "text": "## Daily series for two micro-regions\nd &lt;- data.frame(\n  date       = as.Date(\"2023-01-01\") + 0:9,\n  micro_code = rep(c(\"A\", \"B\"), each = 5),\n  tmin       = rnorm(10, 10, 2),\n  pdsi       = rnorm(10)\n)\n\n## Create lags 1 to 3 for tmin and pdsi\nlagged &lt;- lag_cov(\n  data  = d,\n  name   = c(\"tmin\", \"pdsi\"),\n  time  = \"date\",\n  group = \"micro_code\",\n  lag   = c(1:3)\n)\n\n## Only lagged columns (matrix),\nlag_only &lt;- lag_cov(\n  data = d, name = \"tmin\", time = \"date\",\n  lag  = c(1:3), add = FALSE\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_ppd.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_ppd.Rd.html",
    "title": "Plot Posterior Predictive Densities Versus Observed Data",
    "section": "",
    "text": "This function draws kernel-density curves for posterior-predictive samples and observed data using ggplot2::geom_line(). Each predictive sample‚Äôs density is plotted in light blue; the observed density is overlaid in black.\nplot_ppd(\n  ppd,\n  xlab = \"Outcome\",\n  ylab = \"Density\",\n  title = \"Posterior Predictive Distribution\",\n  xlim = NULL,\n  obs_color = NULL,\n  ppd_color = NULL\n)\n\n\n\n\nppd: A data.frame containing posterior-predictive samples (one column per sample) and the column with observed data.\nxlab: Character: x-axis label. Default \"Outcome\".\nylab: Character: y-axis label. Default \"Density\".\ntitle: Character: plot title. Default \"Posterior Predictive Distribution\".\nxlim: Numeric vector of length 2 giving the minimum and maximum x-axis values, e.g.¬†c(0, 25). If NULL (default) the limits are c(0, quantile(observed, 0.95)).\nobs_color: Color for the observed line density\nppd_color: Color for the posterior predictive distribution lines density\n\n\n\n\nA ggplot2 plot object.\n\n\n\n## Not run:\n\n# Load example posterior predictive distribution from the package: \nppd_df_file &lt;- system.file(\"examples\", \"ppd_df.rds\", package = \"GHRmodel\")\nppd_df &lt;- readRDS(ppd_df_file) # loads ghr_models into the environment\n\n# Plot densities of the posterior predictive distribution and observed cases. \nplot_ppd(ppd_df, \nobs_color = \"blue\",\nppd_color = \"red\")\n## End(Not run)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_ppd.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_ppd.Rd.html#description",
    "title": "Plot Posterior Predictive Densities Versus Observed Data",
    "section": "",
    "text": "This function draws kernel-density curves for posterior-predictive samples and observed data using ggplot2::geom_line(). Each predictive sample‚Äôs density is plotted in light blue; the observed density is overlaid in black.\nplot_ppd(\n  ppd,\n  xlab = \"Outcome\",\n  ylab = \"Density\",\n  title = \"Posterior Predictive Distribution\",\n  xlim = NULL,\n  obs_color = NULL,\n  ppd_color = NULL\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_ppd.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_ppd.Rd.html#arguments",
    "title": "Plot Posterior Predictive Densities Versus Observed Data",
    "section": "",
    "text": "ppd: A data.frame containing posterior-predictive samples (one column per sample) and the column with observed data.\nxlab: Character: x-axis label. Default \"Outcome\".\nylab: Character: y-axis label. Default \"Density\".\ntitle: Character: plot title. Default \"Posterior Predictive Distribution\".\nxlim: Numeric vector of length 2 giving the minimum and maximum x-axis values, e.g.¬†c(0, 25). If NULL (default) the limits are c(0, quantile(observed, 0.95)).\nobs_color: Color for the observed line density\nppd_color: Color for the posterior predictive distribution lines density"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_ppd.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_ppd.Rd.html#returns",
    "title": "Plot Posterior Predictive Densities Versus Observed Data",
    "section": "",
    "text": "A ggplot2 plot object."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_ppd.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_ppd.Rd.html#examples",
    "title": "Plot Posterior Predictive Densities Versus Observed Data",
    "section": "",
    "text": "## Not run:\n\n# Load example posterior predictive distribution from the package: \nppd_df_file &lt;- system.file(\"examples\", \"ppd_df.rds\", package = \"GHRmodel\")\nppd_df &lt;- readRDS(ppd_df_file) # loads ghr_models into the environment\n\n# Plot densities of the posterior predictive distribution and observed cases. \nplot_ppd(ppd_df, \nobs_color = \"blue\",\nppd_color = \"red\")\n## End(Not run)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/crossbasis_inla.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/crossbasis_inla.Rd.html",
    "title": "Create a Two-Dimensional INLA-compatible Cross-basis Matrix",
    "section": "",
    "text": "This function is a wrapper around dlnm::crossbasis\nto generate cross-basis matrices that capture nonlinear effects of a predictor across both exposure and lag dimensions. The input covariate is passed as a numeric matrix of lagged values, and the resulting columns can be renamed via basis_name for easier reference in model formulas.\ncrossbasis_inla(\n  covariate,\n  basis_name,\n  lag,\n  argvar = list(),\n  arglag = list(),\n  ...\n)\n\n\n\n\ncovariate: A numeric matrix of covariate values. Typically this will be a matrix of lagged covariate values (which can be generated using lag_cov).\nbasis_name: A character string specifying the prefix for the spline columns in the resulting basis matrix (replacing the default \"v\").\nlag: A numeric vector with min and max lag of the matrix (as in crossbasis).\nargvar: A list specifying the shape of the exposure-response function (as in crossbasis).\narglag: A list specifying the shape of the lag-response function (as in crossbasis).\n...: Additional arguments passed to dlnm::crossbasis , such as df, degree, knots, etc.\n\n\n\n\nAn object of class \"crossbasis_inla\" (also inheriting class \"crossbasis\"), as returned by dlnm:crossbasis() but with customized column names.\n\n\n\n# Build cross-basis with a custom prefix for columns\n\n# Import example data set \ndata(\"dengue_MS\")\n\nlag_mat &lt;- lag_cov(data = dengue_MS,\n  name = c(\"tmin\"),\n  time = \"date\",\n  lag = c(1:6),\n  group = \"micro_code\",\n  add = FALSE) # add = FALSE return only the lagged matrix\n  \ncb_inla &lt;- crossbasis_inla(\n  covariate  = lag_mat,\n  basis_name = \"tempLag\",\n  lag = c(1,6),\n  argvar = list(fun = \"bs\", df = 3),\n  arglag = list(fun = \"poly\", degree = 2)\n)\n\n# Check class of the cross-basis object\nclass(cb_inla)\n\n# View resulting cross-basis matrix\nhead(colnames(cb_inla))"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/crossbasis_inla.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/crossbasis_inla.Rd.html#description",
    "title": "Create a Two-Dimensional INLA-compatible Cross-basis Matrix",
    "section": "",
    "text": "This function is a wrapper around dlnm::crossbasis\nto generate cross-basis matrices that capture nonlinear effects of a predictor across both exposure and lag dimensions. The input covariate is passed as a numeric matrix of lagged values, and the resulting columns can be renamed via basis_name for easier reference in model formulas.\ncrossbasis_inla(\n  covariate,\n  basis_name,\n  lag,\n  argvar = list(),\n  arglag = list(),\n  ...\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/crossbasis_inla.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/crossbasis_inla.Rd.html#arguments",
    "title": "Create a Two-Dimensional INLA-compatible Cross-basis Matrix",
    "section": "",
    "text": "covariate: A numeric matrix of covariate values. Typically this will be a matrix of lagged covariate values (which can be generated using lag_cov).\nbasis_name: A character string specifying the prefix for the spline columns in the resulting basis matrix (replacing the default \"v\").\nlag: A numeric vector with min and max lag of the matrix (as in crossbasis).\nargvar: A list specifying the shape of the exposure-response function (as in crossbasis).\narglag: A list specifying the shape of the lag-response function (as in crossbasis).\n...: Additional arguments passed to dlnm::crossbasis , such as df, degree, knots, etc."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/crossbasis_inla.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/crossbasis_inla.Rd.html#returns",
    "title": "Create a Two-Dimensional INLA-compatible Cross-basis Matrix",
    "section": "",
    "text": "An object of class \"crossbasis_inla\" (also inheriting class \"crossbasis\"), as returned by dlnm:crossbasis() but with customized column names."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/crossbasis_inla.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/crossbasis_inla.Rd.html#examples",
    "title": "Create a Two-Dimensional INLA-compatible Cross-basis Matrix",
    "section": "",
    "text": "# Build cross-basis with a custom prefix for columns\n\n# Import example data set \ndata(\"dengue_MS\")\n\nlag_mat &lt;- lag_cov(data = dengue_MS,\n  name = c(\"tmin\"),\n  time = \"date\",\n  lag = c(1:6),\n  group = \"micro_code\",\n  add = FALSE) # add = FALSE return only the lagged matrix\n  \ncb_inla &lt;- crossbasis_inla(\n  covariate  = lag_mat,\n  basis_name = \"tempLag\",\n  lag = c(1,6),\n  argvar = list(fun = \"bs\", df = 3),\n  arglag = list(fun = \"poly\", degree = 2)\n)\n\n# Check class of the cross-basis object\nclass(cb_inla)\n\n# View resulting cross-basis matrix\nhead(colnames(cb_inla))"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_multi.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_multi.Rd.html",
    "title": "Create Covariate Combinations Across Groups",
    "section": "",
    "text": "This function generates all possible combinations of covariates by selecting one variable from each user-defined group. Groups can be defined either by a regular expression pattern (pattern) or by exact variable names (name). The resulting list can be input into the covariates argument in write_inla_formulas to generate multivariable model formulas where all combinations of covariates are needed.\ncov_multi(covariates, pattern = NULL, name = NULL, add = FALSE)\n\n\n\n\ncovariates: A character vector or a list of single-element character vectors. Typically obtained from extract_names or cov_uni or cov_nl.\npattern: A character vector of regular expression patterns (e.g., ‚Äútmin‚Äù matches ‚Äútmin‚Äù, ‚Äútmin.l1‚Äù, etc.). Each pattern defines a group to draw covariates from.\nname: A character vector of exact variable names to include as an additional group.\nadd: Logical; if TRUE, appends the generated combinations to the original covariates object. Default is FALSE.\n\n\n\n\nA list of character vectors. Each element is a unique combination of covariates, where one variable is drawn from each specified group. The resulting list is suitable as input in the covariates argument in write_inla_formulas.\n\n\n\ndata &lt;- data.frame(tmin = rnorm(10), tmin.l1 = rnorm(10),\n                   pdsi = rnorm(10), urban = rnorm(10))\n\n# Extract covariate names\ncovs &lt;- extract_names(data, pattern = c(\"tmin\", \"pdsi\", \"urban\"))\n\n# Combine \"tmin\" and \"pdsi\" into all possible pairings\ncov_multi(covariates = covs, pattern = c(\"tmin\", \"pdsi\"))\n\n# Combine \"tmin\" and \"urban\", treating \"urban\" as an exact match\ncov_multi(covariates = covs, pattern = \"tmin\", name = \"urban\")\n\n# Use output as input to write_inla_formulas()\ncombined_covs &lt;- cov_multi(covariates = covs, pattern = c(\"tmin\", \"pdsi\"))\nformulas &lt;- write_inla_formulas(outcome = \"cases\", covariates = combined_covs)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_multi.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_multi.Rd.html#description",
    "title": "Create Covariate Combinations Across Groups",
    "section": "",
    "text": "This function generates all possible combinations of covariates by selecting one variable from each user-defined group. Groups can be defined either by a regular expression pattern (pattern) or by exact variable names (name). The resulting list can be input into the covariates argument in write_inla_formulas to generate multivariable model formulas where all combinations of covariates are needed.\ncov_multi(covariates, pattern = NULL, name = NULL, add = FALSE)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_multi.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_multi.Rd.html#arguments",
    "title": "Create Covariate Combinations Across Groups",
    "section": "",
    "text": "covariates: A character vector or a list of single-element character vectors. Typically obtained from extract_names or cov_uni or cov_nl.\npattern: A character vector of regular expression patterns (e.g., ‚Äútmin‚Äù matches ‚Äútmin‚Äù, ‚Äútmin.l1‚Äù, etc.). Each pattern defines a group to draw covariates from.\nname: A character vector of exact variable names to include as an additional group.\nadd: Logical; if TRUE, appends the generated combinations to the original covariates object. Default is FALSE."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_multi.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_multi.Rd.html#returns",
    "title": "Create Covariate Combinations Across Groups",
    "section": "",
    "text": "A list of character vectors. Each element is a unique combination of covariates, where one variable is drawn from each specified group. The resulting list is suitable as input in the covariates argument in write_inla_formulas."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_multi.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_multi.Rd.html#examples",
    "title": "Create Covariate Combinations Across Groups",
    "section": "",
    "text": "data &lt;- data.frame(tmin = rnorm(10), tmin.l1 = rnorm(10),\n                   pdsi = rnorm(10), urban = rnorm(10))\n\n# Extract covariate names\ncovs &lt;- extract_names(data, pattern = c(\"tmin\", \"pdsi\", \"urban\"))\n\n# Combine \"tmin\" and \"pdsi\" into all possible pairings\ncov_multi(covariates = covs, pattern = c(\"tmin\", \"pdsi\"))\n\n# Combine \"tmin\" and \"urban\", treating \"urban\" as an exact match\ncov_multi(covariates = covs, pattern = \"tmin\", name = \"urban\")\n\n# Use output as input to write_inla_formulas()\ncombined_covs &lt;- cov_multi(covariates = covs, pattern = c(\"tmin\", \"pdsi\"))\nformulas &lt;- write_inla_formulas(outcome = \"cases\", covariates = combined_covs)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_coef_crosspred.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_coef_crosspred.Rd.html",
    "title": "Plot crosspred Objects: Overall, Slices, or Heatmap",
    "section": "",
    "text": "Generate plots from a \"crosspred\" object. Three plot types are available:\n\ntype = \"overall\": Shows the overall exposure‚Äìresponse relationship, aggregated across all lags.\ntype = \"slices\": Produces line plots with credible interval ribbons, either across lags (for a fixed var) or across values of var (for a fixed lag).\ntype = \"heatmap\": Displays a two-dimensional heatmap of effects across both var and lag. Not applicable for one-basis models.\n\nplot_coef_crosspred(\n  crosspred,\n  type = c(\"heatmap\", \"slices\", \"overall\"),\n  var = NULL,\n  lag = NULL,\n  exp = FALSE,\n  palette = \"-RdBu\",\n  n_lag_smooth = 50,\n  line_color = \"black\",\n  line_size = 0.7,\n  ribbon_color = NULL,\n  ribbon_alpha = 0.2,\n  title = \"\",\n  ylab = NULL,\n  xlab = NULL,\n  ...\n)\n\n\n\n\ncrosspred: An object of class \"crosspred\" or \"GHR_crosspred\", produced by crosspred or crosspred_inla.\ntype: Character string. Options: \"overall\", \"slices\", or \"heatmap\".\nvar: Optional numeric vector of exposure values (used when type = \"slices\" to plot across lags).\nlag: Optional numeric vector of lag values (used when type = \"slices\" to plot across variables).\nexp: Logical. If TRUE, exponentiates the results (e.g., for log or logit links).\npalette: Character string for heatmap palette when type = \"heatmap\". Options: GHR, RColorBrewer or colorspace palette (e.g.¬†‚ÄúPurp‚Äù).\nn_lag_smooth: Integer, number of interpolation points along lag for heatmap smoothing (default = 50).\nline_color: Character string. Line color when type = \"slices\" or type = \"overall\". Default is ‚Äúblack‚Äù.\nline_size: Numeric. Line width (default = 0.7).\nribbon_color: Character string. Color for credible interval ribbons. Defaults to line_color.\nribbon_alpha: Numeric. Alpha transparency for ribbons (default = 0.2).\ntitle: Character string. Plot title.\nylab: Character string. Label for y-axis.\nxlab: Character string. Label for x-axis.\n...: Additional arguments passed to ggplot2 functions.\n\n\n\n\nA ggplot object for the specified plot type.\n\n\n\ncrosspred\n\n\n\n# Load example GHRmodels object from the package\nmodel_dlnm_file &lt;- system.file(\"examples\", \"model_dlnm.rds\", package = \"GHRmodel\")\nmodel_dlnm &lt;- readRDS(model_dlnm_file) \n\n# Load example cross-basis matrix from the package: 2-dimensional cross-basis matrix of the \n# non-linear effect of dengue risk across tmin values and lags: \ncb_tmin_file &lt;- system.file(\"examples\",\"cb_tmin.rds\", package = \"GHRmodel\")\ncb_tmin &lt;- readRDS(cb_tmin_file) # loads cross-basis matrix into the environment\n\n# Generate predictions\npred_result &lt;- crosspred_inla(\n  models    = model_dlnm,\n  basis    = cb_tmin,\n  mod_id = \"mod2\",\n  at       = seq(10, 30, by = 1),  # e.g., temperature sequence\n  lag      = 4,\n  cen      = 20,\n  ci.level = 0.95\n)\n\n# Plot DLNM predictions \nplot_coef_crosspred(\ncrosspred = pred_result,    # Crosspred object with model predictions\ntype = \"slices\",            # Plot temperature-specific slices of exposure-response curves\nexp = TRUE,                 # Exponentiate the coefficients (to relative risk scale)\nvar = c(22:24),             # Display results for temperature 22¬∞C to 24¬∞C\nline_color = \"red\",         # Red color for the lines representing effect estimates\nline_size = 0.8,            # Line thickness set to 0.8 for better visibility\nribbon_color = \"red\",       # Red shading for credible interval ribbons\nribbon_alpha = 0.3,         # Set ribbon transparency to 30%\ntitle = \"Effect of minimum temperatures 22¬∞C to 23¬∞C on dengue relative risk by lag\",\nxlab = \"Lag\",               # Label for the x-axis (exposure variable)\nylab = \"Relative Risk (RR)\" # Label for the y-axis (effect estimate scale)\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_coef_crosspred.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_coef_crosspred.Rd.html#description",
    "title": "Plot crosspred Objects: Overall, Slices, or Heatmap",
    "section": "",
    "text": "Generate plots from a \"crosspred\" object. Three plot types are available:\n\ntype = \"overall\": Shows the overall exposure‚Äìresponse relationship, aggregated across all lags.\ntype = \"slices\": Produces line plots with credible interval ribbons, either across lags (for a fixed var) or across values of var (for a fixed lag).\ntype = \"heatmap\": Displays a two-dimensional heatmap of effects across both var and lag. Not applicable for one-basis models.\n\nplot_coef_crosspred(\n  crosspred,\n  type = c(\"heatmap\", \"slices\", \"overall\"),\n  var = NULL,\n  lag = NULL,\n  exp = FALSE,\n  palette = \"-RdBu\",\n  n_lag_smooth = 50,\n  line_color = \"black\",\n  line_size = 0.7,\n  ribbon_color = NULL,\n  ribbon_alpha = 0.2,\n  title = \"\",\n  ylab = NULL,\n  xlab = NULL,\n  ...\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_coef_crosspred.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_coef_crosspred.Rd.html#arguments",
    "title": "Plot crosspred Objects: Overall, Slices, or Heatmap",
    "section": "",
    "text": "crosspred: An object of class \"crosspred\" or \"GHR_crosspred\", produced by crosspred or crosspred_inla.\ntype: Character string. Options: \"overall\", \"slices\", or \"heatmap\".\nvar: Optional numeric vector of exposure values (used when type = \"slices\" to plot across lags).\nlag: Optional numeric vector of lag values (used when type = \"slices\" to plot across variables).\nexp: Logical. If TRUE, exponentiates the results (e.g., for log or logit links).\npalette: Character string for heatmap palette when type = \"heatmap\". Options: GHR, RColorBrewer or colorspace palette (e.g.¬†‚ÄúPurp‚Äù).\nn_lag_smooth: Integer, number of interpolation points along lag for heatmap smoothing (default = 50).\nline_color: Character string. Line color when type = \"slices\" or type = \"overall\". Default is ‚Äúblack‚Äù.\nline_size: Numeric. Line width (default = 0.7).\nribbon_color: Character string. Color for credible interval ribbons. Defaults to line_color.\nribbon_alpha: Numeric. Alpha transparency for ribbons (default = 0.2).\ntitle: Character string. Plot title.\nylab: Character string. Label for y-axis.\nxlab: Character string. Label for x-axis.\n...: Additional arguments passed to ggplot2 functions."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_coef_crosspred.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_coef_crosspred.Rd.html#returns",
    "title": "Plot crosspred Objects: Overall, Slices, or Heatmap",
    "section": "",
    "text": "A ggplot object for the specified plot type."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_coef_crosspred.Rd.html#see-also",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_coef_crosspred.Rd.html#see-also",
    "title": "Plot crosspred Objects: Overall, Slices, or Heatmap",
    "section": "",
    "text": "crosspred"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_coef_crosspred.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_coef_crosspred.Rd.html#examples",
    "title": "Plot crosspred Objects: Overall, Slices, or Heatmap",
    "section": "",
    "text": "# Load example GHRmodels object from the package\nmodel_dlnm_file &lt;- system.file(\"examples\", \"model_dlnm.rds\", package = \"GHRmodel\")\nmodel_dlnm &lt;- readRDS(model_dlnm_file) \n\n# Load example cross-basis matrix from the package: 2-dimensional cross-basis matrix of the \n# non-linear effect of dengue risk across tmin values and lags: \ncb_tmin_file &lt;- system.file(\"examples\",\"cb_tmin.rds\", package = \"GHRmodel\")\ncb_tmin &lt;- readRDS(cb_tmin_file) # loads cross-basis matrix into the environment\n\n# Generate predictions\npred_result &lt;- crosspred_inla(\n  models    = model_dlnm,\n  basis    = cb_tmin,\n  mod_id = \"mod2\",\n  at       = seq(10, 30, by = 1),  # e.g., temperature sequence\n  lag      = 4,\n  cen      = 20,\n  ci.level = 0.95\n)\n\n# Plot DLNM predictions \nplot_coef_crosspred(\ncrosspred = pred_result,    # Crosspred object with model predictions\ntype = \"slices\",            # Plot temperature-specific slices of exposure-response curves\nexp = TRUE,                 # Exponentiate the coefficients (to relative risk scale)\nvar = c(22:24),             # Display results for temperature 22¬∞C to 24¬∞C\nline_color = \"red\",         # Red color for the lines representing effect estimates\nline_size = 0.8,            # Line thickness set to 0.8 for better visibility\nribbon_color = \"red\",       # Red shading for credible interval ribbons\nribbon_alpha = 0.3,         # Set ribbon transparency to 30%\ntitle = \"Effect of minimum temperatures 22¬∞C to 23¬∞C on dengue relative risk by lag\",\nxlab = \"Lag\",               # Label for the x-axis (exposure variable)\nylab = \"Relative Risk (RR)\" # Label for the y-axis (effect estimate scale)\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/crosspred_inla.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/crosspred_inla.Rd.html",
    "title": "Generate DLNM Predictions from GHRmodels Objects",
    "section": "",
    "text": "This function takes an object of class GHRmodels, extracts the relevant coefficients and variance-covariance matrix, and then calls dlnm::crosspred to compute predictions over a range of covariate values (or at specified points).\ncrosspred_inla(\n  models,\n  basis,\n  mod_id,\n  at = NULL,\n  from = NULL,\n  to = NULL,\n  by = NULL,\n  lag,\n  bylag = 1,\n  cen = NULL,\n  ci.level = 0.95,\n  cumul = FALSE,\n  ...\n)\n\n\n\n\nmodels: An object of class GHRmodels, containing fitted model output (e.g., $fixed and $vcov lists).\nbasis: A cross-basis or one-basis object, typically created by crossbasis_inla or onebasis_inla.\nmod_id: An integer or character string specifying which model within the input GHRmodels object to use (e.g., if model$fixed and model$vcov both have multiple entries).\nat: A numeric vector of values at which to compute predictions (e.g.,seq(10,25, by=0.2))\nfrom, to: Numeric values specifying the range of the prediction sequence if at is not specified (e.g., from = 10 and to = 25).\nby: Numeric increment for the sequence if at is not specified (e.g., by = 0.2).\nlag: A vector of two elements with min and max lag as declared in the crossbasis_inla function.\nbylag: Numeric increment for lag steps (default is 1).\ncen: A centering value (e.g., a reference exposure level).\nci.level: The credible interval level (default 0.95).\ncumul: Logical; if TRUE, cumulative predictions are computed (default FALSE).\n...: Additional arguments passed on to crosspred , such as bound, ci.arg, etc.\n\n\n\n\nThe function identifies which coefficients in model$fixed[mod_id] and which rows/columns in model$vcov[mod_id] correspond to the one-basis or cross-basis terms (i.e., matching the column names in basis). Then it passes these slices to dlnm::crosspred to generate predictions. The centering value (cen), if specified, indicates the reference exposure (e.g., a mean temperature) at which to center the effect estimates (e.g., the effect a given temperature value on the outcome will be compared to the effect of the centering value on the outcome, in this case the mean temperature).\n\n\n\nAn object of class \"GHRcrosspred\", inheriting from \"crosspred\", with fields for the predicted values, credible intervals, and optionally cumulative predictions, as determined by crosspred .\n\n\n\ndlnm::crosspred for details on how predictions are computed.\n\n\n\n# Load example GHRmodels object from the package\nmodel_dlnm_file &lt;- system.file(\"examples\", \"model_dlnm.rds\", package = \"GHRmodel\")\nmodel_dlnm &lt;- readRDS(model_dlnm_file)\n\n# Load example cross-basis matrix from the package: 2-dimensional cross-basis matrix of the \n# non-linear effect of dengue risk across tmin values and lags: \ncb_tmin_file &lt;- system.file(\"examples\",\"cb_tmin.rds\", package = \"GHRmodel\")\ncb_tmin &lt;- readRDS(cb_tmin_file) # loads cross-basis matrix into the environment\n\n# Generate predictions\npred_result &lt;- crosspred_inla(\n  models    = model_dlnm,\n  basis    = cb_tmin,\n  mod_id = \"mod2\",\n  at       = seq(10, 30, by = 1),  # e.g., temperature sequence\n  lag      = 4,\n  cen      = 20,\n  ci.level = 0.95\n)\n\n# Inspect predictions\npred_result$predvar  # the sequence of 'at' values\npred_result$allfit   # fitted values\npred_result$alllow   # lower CI\npred_result$allhigh  # upper CI"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/crosspred_inla.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/crosspred_inla.Rd.html#description",
    "title": "Generate DLNM Predictions from GHRmodels Objects",
    "section": "",
    "text": "This function takes an object of class GHRmodels, extracts the relevant coefficients and variance-covariance matrix, and then calls dlnm::crosspred to compute predictions over a range of covariate values (or at specified points).\ncrosspred_inla(\n  models,\n  basis,\n  mod_id,\n  at = NULL,\n  from = NULL,\n  to = NULL,\n  by = NULL,\n  lag,\n  bylag = 1,\n  cen = NULL,\n  ci.level = 0.95,\n  cumul = FALSE,\n  ...\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/crosspred_inla.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/crosspred_inla.Rd.html#arguments",
    "title": "Generate DLNM Predictions from GHRmodels Objects",
    "section": "",
    "text": "models: An object of class GHRmodels, containing fitted model output (e.g., $fixed and $vcov lists).\nbasis: A cross-basis or one-basis object, typically created by crossbasis_inla or onebasis_inla.\nmod_id: An integer or character string specifying which model within the input GHRmodels object to use (e.g., if model$fixed and model$vcov both have multiple entries).\nat: A numeric vector of values at which to compute predictions (e.g.,seq(10,25, by=0.2))\nfrom, to: Numeric values specifying the range of the prediction sequence if at is not specified (e.g., from = 10 and to = 25).\nby: Numeric increment for the sequence if at is not specified (e.g., by = 0.2).\nlag: A vector of two elements with min and max lag as declared in the crossbasis_inla function.\nbylag: Numeric increment for lag steps (default is 1).\ncen: A centering value (e.g., a reference exposure level).\nci.level: The credible interval level (default 0.95).\ncumul: Logical; if TRUE, cumulative predictions are computed (default FALSE).\n...: Additional arguments passed on to crosspred , such as bound, ci.arg, etc."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/crosspred_inla.Rd.html#details",
    "href": "docs/GHRmodel/GHRmodel-reference/crosspred_inla.Rd.html#details",
    "title": "Generate DLNM Predictions from GHRmodels Objects",
    "section": "",
    "text": "The function identifies which coefficients in model$fixed[mod_id] and which rows/columns in model$vcov[mod_id] correspond to the one-basis or cross-basis terms (i.e., matching the column names in basis). Then it passes these slices to dlnm::crosspred to generate predictions. The centering value (cen), if specified, indicates the reference exposure (e.g., a mean temperature) at which to center the effect estimates (e.g., the effect a given temperature value on the outcome will be compared to the effect of the centering value on the outcome, in this case the mean temperature)."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/crosspred_inla.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/crosspred_inla.Rd.html#returns",
    "title": "Generate DLNM Predictions from GHRmodels Objects",
    "section": "",
    "text": "An object of class \"GHRcrosspred\", inheriting from \"crosspred\", with fields for the predicted values, credible intervals, and optionally cumulative predictions, as determined by crosspred ."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/crosspred_inla.Rd.html#see-also",
    "href": "docs/GHRmodel/GHRmodel-reference/crosspred_inla.Rd.html#see-also",
    "title": "Generate DLNM Predictions from GHRmodels Objects",
    "section": "",
    "text": "dlnm::crosspred for details on how predictions are computed."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/crosspred_inla.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/crosspred_inla.Rd.html#examples",
    "title": "Generate DLNM Predictions from GHRmodels Objects",
    "section": "",
    "text": "# Load example GHRmodels object from the package\nmodel_dlnm_file &lt;- system.file(\"examples\", \"model_dlnm.rds\", package = \"GHRmodel\")\nmodel_dlnm &lt;- readRDS(model_dlnm_file)\n\n# Load example cross-basis matrix from the package: 2-dimensional cross-basis matrix of the \n# non-linear effect of dengue risk across tmin values and lags: \ncb_tmin_file &lt;- system.file(\"examples\",\"cb_tmin.rds\", package = \"GHRmodel\")\ncb_tmin &lt;- readRDS(cb_tmin_file) # loads cross-basis matrix into the environment\n\n# Generate predictions\npred_result &lt;- crosspred_inla(\n  models    = model_dlnm,\n  basis    = cb_tmin,\n  mod_id = \"mod2\",\n  at       = seq(10, 30, by = 1),  # e.g., temperature sequence\n  lag      = 4,\n  cen      = 20,\n  ci.level = 0.95\n)\n\n# Inspect predictions\npred_result$predvar  # the sequence of 'at' values\npred_result$allfit   # fitted values\npred_result$alllow   # lower CI\npred_result$allhigh  # upper CI"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_overview.html#installation",
    "href": "docs/GHRmodel/GHRmodel_overview.html#installation",
    "title": "Introduction to GHRmodel",
    "section": "Installation",
    "text": "Installation\nThe latest version of the GHRmodel package is hosted on CRAN and can by installed using the following commands:\n# Install from CRAN\ninstall.packages(\"GHRmodel\") \n\n# Get the development version from Gitlab\nlibrary(devtools)\ndevtools::install_git('https://earth.bsc.es/gitlab/ghr/ghrmodel.git')\nIf you have downloaded the source package as a .tar.gz file (e.g., from a release), you can install it locally using by typing install.packages(\"path_to_tar.gz_file/GHRmodel_0.1.0.tar.gz\", repos = NULL, type = \"source\", build_vignettes = TRUE).\nOne key dependency of the GHRmodel package, the R-INLA package, is not hosted on CRAN and must be installed manually using:\ninstall.packages(\"INLA\",\n                 repos=c(getOption(\"repos\"),  \n                         INLA=\"https://inla.r-inla-download.org/R/stable\"), dep=TRUE)\nInstructions on how to install R-INLA and troubleshooting suggestions can be found on the R-INLA download and installation page."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_overview.html#data-requirements",
    "href": "docs/GHRmodel/GHRmodel_overview.html#data-requirements",
    "title": "Introduction to GHRmodel",
    "section": "Data requirements",
    "text": "Data requirements\nThe data must be organized as a long-format data frame comprising a regularly spaced time series (e.g., daily, weekly, monthly) for a single or several spatial units. That is, each row must represent a single observation for a specific time and (optionally) a specific location. In this data frame, the time (e.g., date) and optional space identifiers (e.g., region_name) must be included as columns, as in the example below. The time identifier must be in Date format (YYYY-MM-DD).\n#&gt; # A tibble: 6 √ó 4\n#&gt;   date       region_name  dengue_cases  tmin\n#&gt;   &lt;date&gt;     &lt;chr&gt;               &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 2001-01-01 Alto Taquari            0  22.3\n#&gt; 2 2001-02-01 Alto Taquari            2  22.1\n#&gt; 3 2001-03-01 Alto Taquari            6  21.7\n#&gt; 4 2001-04-01 Alto Taquari           14  21.4\n#&gt; 5 2001-05-01 Alto Taquari           24  17.0\n#&gt; 6 2001-06-01 Alto Taquari            7  15.0"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_overview.html#methodology",
    "href": "docs/GHRmodel/GHRmodel_overview.html#methodology",
    "title": "Introduction to GHRmodel",
    "section": "Methodology",
    "text": "Methodology\nThe goal of the GHRmodel package is to streamline the development of climate-sensitive disease risk models into a generalizable and reproducible modeling workflow, which could then be integrated into decision-support systems (e.g., see (Fletcher et al., 2025; Lowe et al., 2018, 2021)). The package implements a Bayesian hierarchical modeling framework to estimate disease case counts, assuming a Poisson or negative binomial distribution. The basic model structure incorporates random effects to capture unexplained seasonal, interannual, and spatial variation, alongside covariates representing (lagged) climatic, environmental, or socioeconomic drivers.\nThere are conflicting definitions of what constitutes a fixed effect or random effect (Gelman & Hill, 2006). In this vignette we will refer to:\n\nfixed effects as covariates whose estimated effects on the outcome are of direct interest (e.g., include a fixed effect for mean temperature to measure the change in dengue incidence per each 1 ¬∞C increase, holding other factors constant).\nrandom effects as model components that capture unobserved heterogeneity, accounting for variation across groups, clusters, or units that is not explained by observed covariates (e.g., include a district-level random effect to capture residual differences in baseline dengue incidence that are not explained by other covariates in the model, such as different reporting strategies or unmeasured vector habitat characteristics).\n\nThe basic model structure can be expressed as:\n\\[\ny_{s,t} \\sim \\text{NegBin}(\\mu_{s,t}, \\theta)\n\\]\n\\[\nlog(\\mu_{s,t}) = \\alpha + \\delta_m(t) + \\gamma_a(t) + u_s + v_s + \\sum_{k} \\beta_k X_{k,t,s}\n\\]\nWhere:\n\n\\(y_{s,t}\\) is the observed number of cases at location \\(s\\) and time \\(t\\).\n\\(\\theta\\) is the overdispersion parameter.\n\\(\\mu_{s,t}\\) is the expected value of the number of cases.\n\\(\\alpha\\) is the intercept\n\\(\\delta_m(t)\\) is the monthly random effect (seasonality)\n\\(\\gamma_a(t)\\) is the yearly random effect (interannual variation)\n\\(u_s\\) is the structured spatial random effect for location \\(s\\)\n\\(v_s\\) is the unstructured spatial random effect for location \\(s\\)\n\\(\\sum_{k} \\beta_k X_{k,t}\\) is the sum over covariates (\\(X_{k,t}\\)) and their coefficients (\\(\\beta_k\\))\n\nThis flexible structure serves as a foundation for more complex models incorporating interactions, non-linearities, and distributed lags.\nModel estimation is performed using R-INLA, an R package that implements Bayesian inference using the Integrated Nested Laplace Approximation (INLA) method for latent Gaussian models (Lindgren et al., 2011; Rue et al., 2009). This approach offers substantial computational advantages compared to Markov Chain Monte Carlo (MCMC) inference methods, often yielding similar results with significantly reduced runtime (Rue et al., 2017). R-INLA also supports spatial and spatio-temporal modeling, making it well-suited for epidemiological applications.\nTo learn more about Bayesian inference, this paper provides an initial overview and this book (Statistical Rethinking) is a comprehensive and accessible introduction to the subject (McElreath, 2020; Van De Schoot et al., 2014). To learn more about Bayesian inference using R-INLA there is a wide array of freely accessible resources online. Useful online books include Bayesian Inference with INLA or Geospatial Health Data: modeling and visualization with R-INLA and Shiny (G√≥mez-Rubio, 2020; Moraga, 2019)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_overview.html#ghrmodel-structure",
    "href": "docs/GHRmodel/GHRmodel_overview.html#ghrmodel-structure",
    "title": "Introduction to GHRmodel",
    "section": "GHRmodel structure",
    "text": "GHRmodel structure\n\n\n\nGHRmodel functions to streamline INLA-compatible model formula development.\n\n\n This vignette outlines the full modeling workflow using the GHRmodel package. The process is organized into three key stages: model development, model fitting, and model evaluation.\n\n1. Model development\nTo fit a model with R-INLA, formulas need to follow its required syntax and structural conventions. INLA-compatible model formulas can be developed using either:\n\nUser-defined INLA-compatible input, which may consist of either user-defined covariate lists or user-defined formula lists.\nGHRmodel helper functions that allow the user to pre-process and transform covariates and streamline writing INLA-compatible formulas.\nPre-process covariates: The lag_cov, onebasis_inla and crossbasis_inla functions allow the user to create lagged covariates and one-or-two dimensional basis-transformed matrices, allowing the exploration of the effect of a covariate across the exposure and/or lag dimension.\nWrite covariates: Functions with the prefix *cov_ allow the user to generate lists of covariates to simplify building valid INLA formulas. These functions allow the user to include lagged, non-linear or more complex covariate structures:\n\n\n\n\n\n\n\n\nFunction\nPurpose\n\n\n\n\nextract_names()\nSelects covariate names from a dataset\n\n\ncov_uni()\nPrepares covariates for univariable INLA models\n\n\ncov_nl()\nConverts covariates to non-linear effect terms, with optional replication.\n\n\ncov_interact()\nCreates interaction terms between 2 or 3 covariates (e.g., var1:var2).\n\n\ncov_varying()\nCreates spatially or temporally varying effect terms.\n\n\ncov_multi()\nGenerates combinations of covariates for multivariable models.\n\n\ncov_add()\nAdds a covariate to each element of a covariate list.\n\n\n\nOverview of helper functions to prepare covariate lists for INLA model formulas.\n\nWrite formulas: The write_inla_formulas() function generates INLA-compatible model formulas with structured fixed effects, random effects, and interactions from a list of INLA-compatible covariate sets.\n\nOnce the INLA-compatible model formulas are developed, they must be passed to the as_GHRformulas() function to be converted into a standardized GHRformulas object. This ensures consistent output structure and random effect specification across models that can be interpreted by the function fit_models() for model fitting. The as_GHRformulas() function accepts either a user-defined vector of formulas or the output from write_inla_formulas(). Currently all formulas in a GHRformulas object must share the same random-effect structure. For example, you cannot combine formulas that include both seasonal and annual random effects with formulas that include only seasonal random effects.\nFor more information see vignette(\"GHRmodel_covariates\").\n\n\n2. Model fitting\nThe fit_models() function allows users to fit a set of INLA-compatible model formulas defined by a GHRformulas object to a provided data set. It automates model fitting, extraction of outputs, and computation of a wide range of goodness-of-fit (GoF) metrics. The output is a GHRmodels object.\nEfficient modeling workflows often require organizing, comparing, and extracting subsets of models. The GHRmodels object supports these operations via helper functions to subset, stack, and retrieve covariates (subset_models(), stack_models(), get_covariates(), respectively).\n\n\n3. Model evaluation\nGHRmodel provides a range of functions for model diagnostics, interpretation and evaluation. Functions with the prefix plot_* return graphical ggplot2 or cowplot objects, allowing users to easily customize visual outputs.\n\nModel diagnostics: posterior predictive checks (plot_ppd()), assessment of GoF metrics (rank_models(), plot_gof()), visualization of fitted values vs.¬†observed case counts (plot_fit()).\nCovariate effect visualizations (with the prefix plot_coef_*) including:\nLinear effects (plot_coef_lin())\nNon-linear effects (plot_coef_nl())\nGroup-varying effects (plot_coef_varying())\nEffects derived from one-basis or crossbasis matrices (plot_coef_crosspred())\nRandom effects visualizations: plot_re() can be used to assess spatial and temporal random effects.\n\nTo access the documentation for each function with detailed descriptions and examples, type in R ? functionname (e.g., ? plot_fit).\nPlot color palettes follow the same structure as those in the GHRexplore package, a dependency of GHRmodel. These include several in-house palettes, as well as palettes from RColorBrewer and colorspace. For details on palette usage, see vignette(\"GHRexplore\")."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_overview.html#data",
    "href": "docs/GHRmodel/GHRmodel_overview.html#data",
    "title": "Introduction to GHRmodel",
    "section": "0. Data",
    "text": "0. Data\n\nDataset description\nThe example dataset contains monthly counts of notified dengue cases by microregion, along with a range of spatial and spatio-temporal covariates. This dataset represents a subset of a larger national dataset that covers the entire territory of Brazil. The subset focuses on a specific region, Mato Grosso do Sul, for the purposes of illustration and computational efficiency. The original full data set, which includes data from all Brazilian microregions, is cited in the accompanying source code on GitHub and Zenodo.\nIn this data frame, the date column contains the temporal identifier (in this case, we have monthly data) and the spatial unit identifier is micro_code. Each micro_code corresponds to a distinct microregion with a complete monthly time series. For more information about the data set, see ?dengue_MS.\n#Load data \ndata(\"dengue_MS\")\ndf &lt;- dengue_MS\n\n# View initial rows in example dataframe\nhead(df)\n#&gt; # A tibble: 6 √ó 27\n#&gt;   micro_code micro_name     micro_name_ibge meso_code meso_name    state_code state_name region_code region_name biome_code biome_name\n#&gt;        &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;             &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt; &lt;chr&gt;     \n#&gt; 1      50001 Baixo Pantanal BAIXO PANTANAL       5001 Pantanais S‚Ä¶         50 Mato Gros‚Ä¶           5 Centre-West          3 Pantanal  \n#&gt; 2      50002 Aquidauana     AQUIDAUANA           5001 Pantanais S‚Ä¶         50 Mato Gros‚Ä¶           5 Centre-West          3 Pantanal  \n#&gt; 3      50003 Alto Taquari   ALTO TAQUARI         5002 Centro Nort‚Ä¶         50 Mato Gros‚Ä¶           5 Centre-West          2 Cerrado   \n#&gt; 4      50004 Campo Grande   CAMPO GRANDE         5002 Centro Nort‚Ä¶         50 Mato Gros‚Ä¶           5 Centre-West          2 Cerrado   \n#&gt; 5      50005 Cassil√¢ndia    CASSIL√ÇNDIA          5003 Leste De Ma‚Ä¶         50 Mato Gros‚Ä¶           5 Centre-West          2 Cerrado   \n#&gt; 6      50006 Parana√≠ba      PARANA√çBA            5003 Leste De Ma‚Ä¶         50 Mato Gros‚Ä¶           5 Centre-West          2 Cerrado   \n#&gt; # ‚Ñπ 16 more variables: ecozone_code &lt;dbl&gt;, ecozone_name &lt;chr&gt;, main_climate &lt;chr&gt;, month &lt;dbl&gt;, year &lt;dbl&gt;, time &lt;dbl&gt;,\n#&gt; #   dengue_cases &lt;dbl&gt;, population &lt;dbl&gt;, pop_density &lt;dbl&gt;, tmax &lt;dbl&gt;, tmin &lt;dbl&gt;, pdsi &lt;dbl&gt;, urban &lt;dbl&gt;, water_network &lt;dbl&gt;,\n#&gt; #   water_shortage &lt;dbl&gt;, date &lt;date&gt;\n\n\nData pre-processing\nCreate numeric ID variables for categorical features (such as year, month, or spatial units) that may be included as random effects, in line with R-INLA‚Äôs requirements. R-INLA expects random effect variables to be specified as numeric indices. Additionally, each variable can only appear in a single model term. Therefore, if a categorical variable is used in multiple roles (e.g., as a random effect and also as a grouping variable for a fixed effect), separate numeric ID variables must be created for each usage.\n\nüí° Tip: It is recommended to retain both the numeric ID and the original categorical variable in your dataset, as this supports easier interpretation and model evaluation, for example by allowing users to easily map model outputs based on numeric IDs back to the original labels for reporting or visualization.\n\n\nüí° Tip: It is important to check that the time identifier is in Date format (YYYY-MM-DD). This is especially important if we want to use GHRmodel functions to lag covariates.\n\nHere we generate numeric IDs for year, month, the spatial unit at which the data is aggregated (in this case micro_code), and a larger aggregation unit (meso_code).\n# Check that the date variable is in Date format\nclass(df$date)\n#&gt; [1] \"Date\"\n\n# Create ID variables\ndf &lt;- df |&gt;  \n  # Filter out the year 2000. There are no dengue cases for that year. \n  filter(year &gt; 2000) |&gt;  \n  # Create numeric IDs for year, month and various spatial units.\n  mutate(\n    year_id = as.numeric(as.factor(year)),\n    month_id = as.numeric(as.factor(month)),\n    spat_id = as.numeric(as.factor(micro_code)), \n    spat_meso_id = as.numeric(as.factor(meso_code))\n  )\n\n\nSpatial data and graphs\nTo perform spatial analysis and generate maps of observations across multiple spatial units, the polygon geometries must be provided as an sf object. Polygon geometries represent the shapes and boundaries of spatial units (e.g., districts, or ecological zones) using a series of connected coordinate points that enclose an area. The sf object must include a spatial unit identifier to enable linkage with the corresponding data frame. For the dengue_MS dataset, the areal polygons are already included in the package in the map_MS object. In map_MS, the code variable corresponds to the micro_code area identifier in the dengue_MS object.\n# Load map (sf object) included in package\ndata(\"map_MS\")\n\n# Visualize the map with microregion labels\nggplot() +\n  geom_sf(data = map_MS) +\n  geom_sf_text(data = map_MS, aes(label = code), size = 2.5) +\n  theme_minimal() +\n  labs(title = \"Mato Grosso do Sul\",\n       x = \"Longitude\",\n       y = \"Latitude\")+\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))\n\nTo model spatially structured random effects (e.g., using the Besag-York-Molli√© model (BYM (Besag et al., 1991)) or BYM2 model (Simpson et al., 2017) for areal data in R-INLA), we need an adjacency matrix that defines neighboring relationships between spatial units. Spatially structured random effects (represented by \\(u_s\\) in the example model formulation above) account for spatial autocorrelation (meaning that nearby regions tend to have similar values) by introducing a correlation structure based on geographic proximity. Spatially unstructured random effects (represented by \\(v_s\\) in the example model formulation above) can be used to account for uncorrelated noise. Including these random effects helps capture spatial variation that is not explained by the fixed effects in the model.\nThe adjacency matrix, indicating which spatial units share borders, is constructed using the spdep package.\n# Create adjacency Matrix\nnb &lt;- spdep::poly2nb(map_MS)\ng &lt;- spdep::nb2mat(nb, style = \"B\")"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_overview.html#model-development-1",
    "href": "docs/GHRmodel/GHRmodel_overview.html#model-development-1",
    "title": "Introduction to GHRmodel",
    "section": "1. Model development",
    "text": "1. Model development\nIn this example we demonstrate how to use the GHRmodel helper functions to streamline writing INLA-compatible formulas.\n\nCreate lagged covariates\nlag_cov() creates lagged versions of numeric or categorical variables in an equally spaced time-series data set.\nHere, we use it to generate lagged values for the variables tmin (monthly average daily minimum temperature averaged across each microregion) and pdsi (monthly Self-calibrated Palmer Drought Severity Index for each microregion) from 1- to 6-month lags using the lag_cov() function.\nTo use this function, the user must specify:\n\nname: The name of the variable (or variables) to lag.\ntime: The column representing the time variable.\nlag: a vector of integers (that is, list of numbers like 2 or c(1,2)) indicating how many time steps (e.g., months) the values should be shifted backward (for instance, a 1-month lag for tmin in February would correspond to the value of tmin in January).\n\nIn this example, each micro_code represents a spatial unit with its own monthly time series. When the dataset contains multiple such time series (one for each group) the group argument should be specified to ensure that lags are computed independently within each group.\nThe add argument determines whether the lagged variables should be appended to the original dataset (add = TRUE) or returned as a separate matrix (add = FALSE).\ndata &lt;- lag_cov(data = df,\n                name = c(\"tmin\", \"pdsi\"),  # variables to lag \n                time = \"date\",        # time variable \n                lag = c(1:6),         # 1 to 6-month lags\n                group = \"micro_code\", # identify spatial units with independent time series\n                add = TRUE)           # lagged variables appended to original data\n\n# Visualize lagged variables\nhead(data[32:43])\n#&gt; # A tibble: 6 √ó 12\n#&gt;   tmin.l1 tmin.l2 tmin.l3 tmin.l4 tmin.l5 tmin.l6  pdsi.l1 pdsi.l2 pdsi.l3 pdsi.l4 pdsi.l5 pdsi.l6\n#&gt;     &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n#&gt; 1    NA      NA      NA      NA      NA        NA NA       NA      NA      NA      NA           NA\n#&gt; 2    23.5    NA      NA      NA      NA        NA  0.0890  NA      NA      NA      NA           NA\n#&gt; 3    23.3    23.5    NA      NA      NA        NA  0.260    0.0890 NA      NA      NA           NA\n#&gt; 4    22.7    23.3    23.5    NA      NA        NA  0.266    0.260   0.0890 NA      NA           NA\n#&gt; 5    21.9    22.7    23.3    23.5    NA        NA  0.0654   0.266   0.260   0.0890 NA           NA\n#&gt; 6    17.8    21.9    22.7    23.3    23.5      NA -0.00682  0.0654  0.266   0.260   0.0890      NA\n\nüí° Tip: To avoid missing values introduced by lagged variables, consider including covariate data from months prior to your analysis start date. This helps ensure complete lag structures at the beginning of the time series. For instance if you disease case data records start in January 2010, and you intend to include covariates with up to a 3-month lag, you should include covariate data starting from October 2009 (3 months before the analysis start date).\n\n\n\nWrite covariates\nThe GHRmodel package contains a set of functions to help users generate organized lists of covariates to be included in the models, simplifying the process of building INLA-compatible formulas. In this vignette, we introduce some of those functions, for further detail please check the additional vignettes vignette(\"GHRmodel_covariates\") and vignette(\"GHRmodel_DLNM\") where advanced options including replicated, varying, interacting effects and Distributed Lag Non-linear Models (DLNM) are explained.\nThe GHRmodel covariate helper functions use a common structure to select covariates:\n\npattern: for partial string matching, selecting groups of covariates that share a common prefix (e.g., ‚Äútmin‚Äù would match ‚Äútmin.l1‚Äù, ‚Äútmin.l2‚Äù, etc.).\nname: for exact matching of covariate names\n\nFor all functions with the prefix cov_*, the input is a character vector or a list of character vectors representing covariate names specified in the covariates argument (which can be generated using the extract_names() function). The output is a list of covariates that may be combined or transformed, formatted for INLA formulas. add: is a logical flag indicating whether to retain original covariates in addition to transformed or combined ones in the output.\n\nSelect variables to include in the model formulas\n\nUsers can specify which variables from the data set to include as covariates using the extract_names() function. It outputs a character vector of variable names.\nHere we select lags 1 through 6 for tmin and pdsi. By including \"tmin.\" and \"pdsi.\" in the pattern argument, we capture all columns that match these prefixes (e.g., tmin.l1, tmin.l2, ‚Ä¶, pdsi.l6).\n\n# Extract variable names matching the specified patterns\ncov_names &lt;- extract_names(data = data,\n                           pattern = c(\"tmin.\",\n                                       \"pdsi.\"))\n\n# Visualize output: character vector of covariate names\nglimpse(cov_names)\n#&gt;  chr [1:12] \"tmin.l1\" \"tmin.l2\" \"tmin.l3\" \"tmin.l4\" \"tmin.l5\" \"tmin.l6\" \"pdsi.l1\" \"pdsi.l2\" \"pdsi.l3\" \"pdsi.l4\" \"pdsi.l5\" ...\n\nGenerate list of linear covariates for univariable models\n\nThe cov_uni() function returns a list where each element contains a single covariate. This structure is suitable for fitting separate univariable models.\n\n# Generate list of single linear covariate names\nuni_cov_lin &lt;- cov_uni(covariates = cov_names, # Input character vector of covariate names\n                       pattern = c(\"pdsi.l\",  # Select lagged pdsi and tmin from the vector of covariate names\n                                   \"tmin.l\"))\n\n# Visualize output: list of single linear covariate names\nhead(uni_cov_lin,2)\n#&gt; [[1]]\n#&gt; [1] \"pdsi.l1\"\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"pdsi.l2\"\n\nGenerate list of non-linear covariates for univariable models\n\nTo include non-linear covariates in the model, the cov_nl() function generates non-linear effect terms compatible with the INLA formula structure (for more information see how to smooth terms in INLA). The non-linear transformation is defined using three main arguments that are passed into inla.group():\n\nThe type of non-linear effect is controlled by the model argument, which supports \"rw1\" (random walk of order 1) or \"rw2\" (random walk of order 2), and defaults to \"rw2\".\nThe method argument allows the user to specify how to discretize the linear covariate. Accepted values are \"cut\" (equal-width intervals) and \"quantile\" (equal-width intervals in the probability space). The default is \"quantile\".\nThe n argument sets the number of basis points (breaks) used to approximate the non-linear effect and defaults to 10.\n\n\nüí° Tip: Choosing a low n will result in a smoother function (at the risk of underfitting) whereas a high n will lead into a more flexible function (at the risk of overfitting). Make sure to explore and plot your data and check goodness-of-fit metrics to get the best possible fit!\n\n\nüìù Note: In addition to cov_nl, GHRmodel provides the onebasis_inla() function for nonlinear covariate transformations. This function supports natural splines (\"ns\"), B-splines (\"bs\"), polynomial (\"poly\"), and other options from dlnm::onebasis(). For more information about one-basis terms see the Complex Covariate Structures in GHRmodel vignette by typing vignette(\"GHRmodel_covariates\").\n\nHere we transform the 1- to 6-month lagged tmin and pdsi variables into non-linear terms using a random walk of order 2 (model = \"rw2\"). We apply 10 breaks (n= 10) to discretize the covariates using method = \"quantile\", which ensures each bin contains a similar number of observations. By setting add = FALSE, the resulting list only includes the transformed variables.\n\n# Generate list of single non-linear covariate names\nuni_cov_nl &lt;- cov_nl(covariates = cov_names, \n                     method = \"quantile\",\n                     model = \"rw2\",\n                     pattern = c(\"pdsi\", \"tmin\"), \n                     n = 10,\n                     add =FALSE)\n\n# Visualize output: list of single non-linear covariate names\nhead(uni_cov_nl,2)\n#&gt; [[1]]\n#&gt; [1] \"f(INLA::inla.group(tmin.l1, method='quantile', n=10), model='rw2')\"\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"f(INLA::inla.group(tmin.l2, method='quantile', n=10), model='rw2')\"\n\nGenerate list of covariates for multivariable models\n\nThe cov_multi() function takes a character vector (such as the output of extract_covariates()) or a list of character vectors (e.g., output from cov_uni() or cov_nl()) and generates all possible combinations. This is useful for constructing multivariable models where the user wishes to explore joint effects of different covariates.\nHere we generate all two-way combinations of the linear and non-linear covariates containing ‚Äútmin‚Äù and ‚Äúpdsi‚Äù listed in the uni_cov_lin and uni_cov_nl objects:\n# Generate list of combinations of linear covariate names\nmulti_cov_lin &lt;- cov_multi(covariates = uni_cov_lin,\n                           pattern = c(\"pdsi\",\"tmin\"),\n                           add = FALSE)\n\n# Visualize output: list of combinations of linear covariate names\nhead(multi_cov_lin,2)\n#&gt; [[1]]\n#&gt; [1] \"pdsi.l1\" \"tmin.l1\"\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"pdsi.l2\" \"tmin.l1\"\n\n# Generate list of combinations of non-linear covariate names\nmulti_cov_nl &lt;- cov_multi(covariates = uni_cov_nl,\n                          pattern = c(\"pdsi\",\"tmin\"),\n                          add = FALSE)\n\n# Visualize output: list of combinations of non-linear covariate names\nhead(multi_cov_nl,2)\n#&gt; [[1]]\n#&gt; [1] \"f(INLA::inla.group(pdsi.l1, method='quantile', n=10), model='rw2')\"\n#&gt; [2] \"f(INLA::inla.group(tmin.l1, method='quantile', n=10), model='rw2')\"\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"f(INLA::inla.group(pdsi.l2, method='quantile', n=10), model='rw2')\"\n#&gt; [2] \"f(INLA::inla.group(tmin.l1, method='quantile', n=10), model='rw2')\"\n\nSee vignette(\"GHRmodel_covariates\") for details on how to generate INLA-compatible formulas with complex covariate structures.\n\n\nWrite formulas\nTo fit models with GHRmodel, formulas must be provided as a GHRformulas object. Here we outline the steps needed to convert a character vector of INLA-compatible formulas into this required format.\n\nDefine priors\n\nBayesian models require priors to be assigned to the parameters that the model will estimate. These priors govern the variability and structure of the latent components and are a core element of Bayesian model specification. It is good practice to pre-define priors before writing model formulas. For more details about priors in R-INLA, see this book chapter (G√≥mez-Rubio, 2020)\n\nThe prior distributions for fixed effects and intercept parameters use R-INLA‚Äôs default: Gaussian distributions with mean = 0 and precision = 0.001) (Moraga, 2019). These default priors are centered at 0 and therefore do not assume any prior knowledge about the direction of the effects.\nPrior distributions for hyperparameters associated with structured random effects (e.g., rw1, iid, bym2) must be specified by the user.\nBelow, we define priors for the monthly, yearly and spatial structured random effects:\n\nThe monthly and yearly random effects are assigned weakly informative Gamma priors on the precision with parameters 0.01 and 0.01 (G√≥mez-Rubio, 2020).\n# Define Gamma priors for the precision of temporal random effects\nprior_t &lt;- list(prec = list(prior = 'loggamma', param = c(0.01, 0.01))) \nThe spatial random effect is modeled with a BYM2 specification, which combines spatially structured and unstructured components. This formulation facilitates assigning Penalized Complexity (PC) priors to model parameters (Simpson et al., 2017). PC priors are recommended because they penalize model complexity, shrinking toward simpler structures unless the data provide strong evidence otherwise. Additionally, they allow users to set priors on interpretable scales, such as the standard deviation of random effects.\n\nThe prec prior controls the magnitude of spatial variation. Using a rule of thumb from Simpson et al.¬†(2017), we assign prior parameters such that the probability that the marginal standard deviation exceeds 0.5 is 0.01 (Moraga, 2019; Simpson et al., 2017).\nThe phi prior controls the proportion of variance explained by the structured spatial component. We use a conservative prior that assumes the unstructured (random noise) effect explains more variation than the spatially structured effect (Moraga, 2019).\n\n# Define penalized complexity (PC) priors for spatial random effects using BYM2\nprior_sp &lt;- list(\n  prec = list(prior = 'pc.prec', param = c(0.5 / 0.31, 0.01)),  # Precision of spatial effect\n  phi  = list(prior = 'pc', param = c(0.5, 2 / 3))              # Mixing parameter: structured vs unstructured\n)\n\nWrite INLA-compatible model formulas from a list of covariates\n\nThe write_inla_formulas() function simplifies the creation of multiple INLA-compatible model formulas by automatically structuring fixed effects, random effects, and interactions. This includes:\n\nFlexible model construction: Accepts a list of covariate sets, enabling batch creation of INLA-compatible model formulas for comparison or model selection workflows.\nBaseline model inclusion: If baseline = TRUE (default), the function adds a baseline model as the first element in the list. This is either an intercept-only model (if no random effects are specified) or a random-effects-only model.\nStructured random effects: Supports up to five random effects through the arguments re1 to re5. Each random effect is defined with its own ID variable (id) and model type (e.g.,model = ‚Äúiid‚Äù, ‚Äúrw1‚Äù, ‚Äúrw2‚Äù, ‚Äúbym‚Äù, or ‚Äúbym2‚Äù). Optional fields include replication (replicate), hierarchical grouping (group), spatial structure (graph), cyclic effects (cyclic), scaling (scale.model), and custom hyperparameters (hyper). While effects included in arguments re1 to re5are shared across all model formulas, effects defined by the covariates argument can differ between models.\n\nFor details see ?write_inla_formulas.\nFirst we compile a list of covariate combinations, where each element in the list corresponds to a distinct model specification. This list will be referenced in the covariates argument in write_inla_formulas(). In this example, covariates are selected to illustrate both linear and non-linear effects for visualization purposes below.\n\ncov_list &lt;- c(list(uni_cov_lin[[7]],    # Include linear tmin.l1 \n                   uni_cov_nl[[1]],     # Include non-linear tmin.l1\n                   multi_cov_lin[[1]],  # Include linear \"pdsi.l1\" \"tmin.l1\"\n                   multi_cov_nl[[1]]),  # Include non-linear \"pdsi.l1\" \"tmin.l1\" combination\n              uni_cov_nl[7:12])         # Include non-linear terms for pdsi.l1 through pdsi.l6\n\n# Visualize the first 3 elements of the covariate list\nhead(cov_list, 4)\n#&gt; [[1]]\n#&gt; [1] \"tmin.l1\"\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"f(INLA::inla.group(tmin.l1, method='quantile', n=10), model='rw2')\"\n#&gt; \n#&gt; [[3]]\n#&gt; [1] \"pdsi.l1\" \"tmin.l1\"\n#&gt; \n#&gt; [[4]]\n#&gt; [1] \"f(INLA::inla.group(pdsi.l1, method='quantile', n=10), model='rw2')\"\n#&gt; [2] \"f(INLA::inla.group(tmin.l1, method='quantile', n=10), model='rw2')\"\n\n# The result is a list\nclass(cov_list)\n#&gt; [1] \"list\"\nNext, we generate a set of model formulas by inputting the covariate list into the write_inla_formulas() function:\n\n# Build a list of INLA-compatible model formulas including outcome, covariates, and random effects\nformulas_cov_list &lt;- write_inla_formulas(\n  # Outcome (dependent variable) in all formulas\n  outcome = \"dengue_cases\",\n  # List of covariate sets to be included in the formulas (generated earlier as cov_list)\n  covariates = cov_list,\n  # First random effect: monthly seasonality\n  re1 = list(\n    id        = \"month_id\",      # Time index for monthly effect\n    model     = \"rw1\",           # First-order random walk model\n    cyclic    = TRUE,            # Enforce cyclicity over months (Dec ‚Üí Jan wrap-around)\n    hyper     = \"prior_t\",       # Hyperprior object for precision\n    replicate = \"spat_meso_id\"   # Separate seasonal pattern per mesoregion\n  ),\n  # Second random effect: inter-annual trend\n  re2 = list(\n    id    = \"year_id\",           # Year index\n    model = \"iid\",               # Independent and identically distributed\n    hyper = \"prior_t\"            # Hyperprior for temporal smoothness\n  ),\n  # Third random effect: spatial autocorrelation\n  re3 = list(\n    id    = \"spat_id\",           # Spatial unit identifier\n    model = \"bym2\",              # BYM2 spatial model (structured + unstructured)\n    graph = \"g\",                 # Pre-computed spatial adjacency graph\n    hyper = \"prior_sp\"           # PC priors for BYM2 model parameters\n  ),\n  # Include a baseline random effect-only model formula as 1st element in the list\n  baseline = TRUE\n)\n\n# Example of INLAcompatible model formula generated\nformulas_cov_list[2]\n#&gt; [1] \"dengue_cases ~ 1 + tmin.l1 + f(month_id, model = 'rw1', replicate = spat_meso_id, cyclic = TRUE, hyper = prior_t) + f(year_id, model = 'iid', hyper = prior_t) + f(spat_id, model = 'bym2', graph = g, hyper = prior_sp)\"\n\n# Outputs a character vector of model formulas\nclass(formulas_cov_list)\n#&gt; [1] \"character\"\n\nConvert model formulas to a GHRformulas object\n\nHere we use the as_GHRformulas() function to convert the output from write_inla_formulas() into a standardized GHRformulas object:\nformulas_cov_list_ghr &lt;- as_GHRformulas(formulas = formulas_cov_list)\n\n# Outputs a GHRformulas object\nclass(formulas_cov_list_ghr)\n#&gt; [1] \"GHRformulas\" \"list\""
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_overview.html#model-fitting-1",
    "href": "docs/GHRmodel/GHRmodel_overview.html#model-fitting-1",
    "title": "Introduction to GHRmodel",
    "section": "2. Model fitting",
    "text": "2. Model fitting\nThe fit_models() function allows users to fit a set of INLA-compatible models defined by a GHRformulas object to a provided data set. It automates model fitting, extraction of outputs, and computation of a wide range of goodness-of-fit (GoF) metrics. It also facilitates model selection: if a baseline model (e.g., random effects-only) is included as the first entry in the formula list‚Äîas when generated via write_inla_formulas(..., baseline = TRUE)‚Äîthe function highlights how subsequent models improve on this baseline across multiple dimensions.\nInputs\nformulas: A GHRformulas object containing one or more INLA model formulas.\ndata: The dataset containing variables used in the model.\nfamily: The likelihood family (currently supports: \"poisson\", \"nbinomial\").\nname: user-defined prefix label for each model.\ncontrol_compute: Options for computing posterior predictive distributions (config = TRUE) or returning the variance-covariance matrix.\noffset (optional): A variable in data to be used as an offset. The function will automatically apply the natural logarithm to this variable.\npb: Toggle progress bar indicating the last model run.\nnthreads: Number of threads for parallel model fitting. A low-end laptop can handle 4-8 threads.\nOutputs The function returns a GHRmodels object that includes:\n\nGHRmodels$fitted: A list of fitted values (one element per model). If config = TRUE, these are derived from the posterior predictive distribution (PPD); otherwise, they are extracted from INLA‚Äôs summary.fitted.values.\nGHRmodels$formulas, GHRmodels$data: Original formulas and dataset.\nGHRmodels$mod_gof: A data frame with a comprehensive suite of goodness-of-fit Metrics (GoF) metrics. If config = TRUE, these are calculated using the posterior predictive distribution (PPD) when applicable; otherwise using INLA‚Äôs summary.fitted.values.\nDIC: Deviance Information Criterion.\nWAIC: Watanabe-Akaike Information Criterion.\nLMS: Log Mean Score based on Conditional Predictive Ordinate.\nMAE: Mean Absolute Error.\nRMSE: Root Mean Squared Error.\nCRPS: Continuous Ranked Probability Score (requires config = TRUE).\nPseudo R¬≤: Improvement over a baseline model based on deviance.\nRandom Effect Variance: Inverse of median precision.\n\nAdditionally, differences in each metric relative to the baseline model are reported (it assumes that the baseline model is the first in the list of formulas, as occurs when the formulas are produced using write_inla_formulas where baseline = TRUE).\n\nRelative metric difference between each model and the first model: stored in variables named with the metric name and suffix ‚Äúvs_first‚Äù (for example, ‚Äúwaic_vs_first‚Äù).\nCredible intervals for metric differences: Values of the lower credible interval of the difference are named with the metric name and suffix ‚Äúvs_first_lci‚Äù and for the upper credible interval of the difference the suffix ‚Äúvs_first_uci‚Äù.\nRelative change in random effect variance (proportion), quantifying how much variability is explained by covariates: stored in variables named with the metric name and suffix ‚Äúvar_change‚Äù (for example, ‚Äúre_1_var_change‚Äù)\n\nFor more information about how these metrics are calculated and what they measure, see ?fit_models.\nThis example demonstrates fitting a set of negative binomial models defined by the GHRformulas object (formulas_cov_list_ghr) constructed above, with an offset term to account for population exposure. After fitting, goodness-of-fit metrics can be extracted as a data frame directly through the GHRmodels$mod_gof element.\n\nmodel_list &lt;- fit_models(\n  formulas = formulas_cov_list_ghr, # GHRformulas object\n  data = data,                      # Data to fit the models \n  family = \"nbinomial\",             # Negative binomial likelihood\n  name = \"mod\",                     # Label prefix for each model\n  offset = \"population\",            # Offset variable to account for population size\n  control_compute = list(\n    config = FALSE,                 # Extract from INLA summary.fitted.values\n    vcov = FALSE                    # Do not return variance-covariance matrix\n  ),\n  nthreads = 8                      # Use 8 threads for parallel computation\n)\n\n# Outputs a GHRmodels object\nclass(model_list)\n\n# Extract goodness of fit metrics as a data.frame\nmodel_list_gof &lt;- model_list$mod_gof"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_overview.html#model-evaluation-1",
    "href": "docs/GHRmodel/GHRmodel_overview.html#model-evaluation-1",
    "title": "Introduction to GHRmodel",
    "section": "3. Model evaluation",
    "text": "3. Model evaluation\nMost, but not all, model evaluation functions in the GHR package suite return graphical ggplot2 or cowplot objects and require a GHRmodels object as input. Users can customize visual outputs using standard ggplot2 syntax.\n\nRank models\nThe rank_models() function provides a simple way to rank models stored in a GHRmodels object based on a selected GoF metric. This function supports any of the GoF metrics or relative metrics output in the mod_gof component of a GHRmodels object ( see ?fit_models).\nHere we rank models based on WAIC and return the top 2 models with the lowest WAIC values.\n\nbest_waic &lt;- rank_models(\n  models = model_list,  # GHRmodels object containing model fit results\n  metric = \"waic\",      # Metric used to rank models (lower WAIC is better)\n  n = 2                 # Number of top-ranked models to return\n)\n\n# Display the model IDs of the two best models\nbest_waic\n#&gt; [1] \"mod5\" \"mod3\"\n\n\nPosterior predictive checks\nPosterior predictive checks allow users to evaluate how well a model captures the distribution of observed data by comparing it to samples generated from the model‚Äôs predictive distribution.\nThe function sample_ppd() refits a specified model from a GHRmodels object and generates samples from its posterior predictive distribution. The output is a data.frame with posterior predictive samples and an observed column for the actual outcomes.\nppd_df &lt;- sample_ppd( \n  model_list,\n  mod_id = \"mod3\", \n  s = 100, # Increase to have more robust results\n  nthreads = 2)\nThe plot_ppd() function takes the output from sample_ppd() and creates a density plot comparing the distributions of the posterior predictive (purple line) with the observed data (black line). This visual comparison helps assess model fit and detect discrepancies between the predicted and observed outcome distributions.\nplot_ppd(ppd_df)\n\n\n\nGoodness-of-fit metrics\nThe plot_gof() function provides a convenient way to visualize and compare the performance of multiple models using a selected goodness-of-fit (GoF) metric, such as DIC, WAIC, RMSE, or CRPS. It is typically used with the mod_gof component of a GHRmodels object (produced by fit_models()), but it can also accept any custom data frame ‚Äî provided it contains the same column names as the default mod_gof output (including model_id and the relevant metric column names). A key feature of plot_gof() is its ability to visually arrange and distinguish models by mapping any column in the input data frame to plot aesthetics such as color, shape, or facet layout. This makes it easy for the user to customize the input data frame to organize models by additional user-defined categories (e.g., environmental variables or dlnm models). Further, the plot supports customization by allowing users to specify which models to include, apply custom labels, and optionally display 95% credible intervals for metrics like dic_vs_first or waic_vs_first.\nHere we assess how the inclusion of different covariates impacts model performance using plot_gof() to compare each model‚Äôs WAIC against that of a baseline model (waic_vs_first). Before plotting, we annotate each model in the model_list$mod_gof dataframe with descriptive labels that classify the type of transformation applied to each covariate.\n# Annotate each model in the model_list$mod_gof dataframe with descriptive labels\nmodel_list_gof &lt;- model_list$mod_gof |&gt; \n  dplyr::mutate(\n    `Variable transformation 1st covariate` = dplyr::case_when(\n      grepl(\"_nl\", covariate_1, ignore.case = TRUE) ~ \"non-linear\", \n      is.na(covariate_1) ~ \"baseline\",\n      T ~ \"linear\"\n    ),\n    `Covariates` = dplyr::case_when(\n      grepl(\"tmin\", covariate_1, ignore.case = TRUE) & is.na(covariate_2) ~ \"tmin\",\n      grepl(\"pdsi\", covariate_1, ignore.case = TRUE) & is.na(covariate_2) ~ \"pdsi\",\n      !is.na(covariate_1) & !is.na(covariate_2) ~ \"tmin + pdsi\",\n      is.na(covariate_1) ~ \"random effect only\"\n    )\n  )\nIn this plot we observe that models that included a non-linear term for the previous month‚Äôs mean temperature (tmin.l1) improved model fit relative to the baseline most.\n# Plot change in WAIC for each model compared to the baseline (first model in the list)\nplot_gof(\n  mod_gof = model_list_gof,            # Goodness-of-fit data from model_list\n  metric = \"waic_vs_first\",            # Compare WAIC to the first model (baseline)\n  ci = TRUE,                           # Include credible intervals (if available)\n  var_arrange = \"waic_vs_first\",       # Arrange models by WAIC difference\n  var_color =  \"Variable transformation 1st covariate\",    # variable transformation\n  var_shape = \"Covariates\",  # Shape mapped to including tmin.l1\n  palette = \"Colorblind\")    \n\n\n\nFitted vs.¬†Observed\nThe plot_fit() function allows users to visually assess model performance by comparing observed case counts with fitted values over time from one or more models stored in a GHRmodels object. It allows:\n\nTime-series comparison of observed and fitted values.\nOption to facet by model ID using mod_facet = TRUE and/or group (e.g., spatial unit) using the group and group_id arguments.\nAdd 95% credible intervals around fitted estimates.\nSupports custom model labels, color palettes, and cropping the plot window to a date range (e.g., c(‚Äú2010-01-01‚Äù, ‚Äú2020-12-31‚Äù))..\n\nHere we observe that the best-fitting model by WAIC performs better during some dengue outbreaks than the baseline random-effect-only model (especially in 2010, 2015 and 2016).\n# Plot observed vs. fitted cases over time for three selected models\nplot_fit(\n  models = model_list,                         # A GHRmodels object (fitted models)\n  mod_id = c(\"mod1\", \"mod3\", \"mod5\"),          # Vector of model IDs to plot\n  mod_label = c(\"Baseline\",                    # Custom display names \n                \"tmin.l1.nl\",            \n                \"pdsi.l1.nl_tmin.l1.nl\"),            \n  ref_color = \"grey\",                          # Color override for the ref model (first)\n  time = \"date\",                               # Name of the time variable in the dataset\n  palette = \"Set2\",                            # Color palette for fitted lines\n  xlim = c(\"2010-01-01\", \"2020-01-01\"),        # Limit x-axis to this date range\n  title = \"Fitted vs Observed\"                 # Main plot title\n)\n\n Here we visualize how well each model‚Äôs predictions match the observed case counts over time, grouped by the region ID meso_code. Faceting (mod_facet = TRUE) allows for side-by-side visual comparison of different modeling strategies. The log-transformed y-axis using transform = \"log10p1\" applies a log10(x + 1) transformation for improved visibility where count data vary greatly in scale.\n# Plot observed vs. fitted values from multiple models with faceted panels by model\nplot_fit(\n  model = model_list,                          # GHRmodels object containing fitted models\n  mod_id = c(\"mod1\", \"mod4\"),                  # Vector of model IDs to plot\n  mod_label = c(\"Baseline\",                    # Custom display name for mod1\n                \"pdsi.l1_tmin.l1\"),            # Custom display name for mod4\n  time = \"date\",                               # Name of the time variable\n  group = \"meso_name\",                         # Column defining grouped time-series (meso region)\n  group_id = c(\"Pantanais Sul Mato-Grossense\", # Select specific groups to display\n               \"Leste De Mato Grosso Do Sul\"),\n  transform = \"log10p1\",                       # Apply log10(x + 1) transformation to y-axis for scaling\n  palette = \"Set2\",                            # Color palette for model fits\n  mod_facet = TRUE,                            # Facet by model to compare fits across panels\n  obs_color = \"purple\",                        # Line color for observed case counts\n  obs_label = \"Observed cases\",                # Legend label for observed values\n  ref_color = \"grey\",                          # Override color for the reference model\n  title = \"Fitted models vs. Observed Cases\",  # Main plot title\n  ci = FALSE                                   # Do not plot credible intervals\n)\n\n\n\nCovariate effects\nLinear coefficients\nThe plot_coef_lin() function generates a forest plot of fixed-effect (linear) coefficients from one or more models stored in a GHRmodels object. This plot provides a visual summary of point estimates and uncertainty (e.g., credible intervals) for linear covariates, helping to interpret the strength and direction of modeled associations.\nBy default, the function plots all linear fixed-effect terms except the intercept. Users can filter the coefficients by exact variable names (name) or matching patterns (pattern), including interaction terms. If users do not select specific model_ids, by default the function plots all linear effects across all models in a provided GHRmodels object. Note that if any of the models contains a cross-basis covariate the function will plot the coefficients for each element in the cross-basis matrix (for more information about one-basis and cross-basis terms see the Distributed Lag Nonlinear Models in GHRmodel vignette by typing vignette(\"GHRmodel_DLNM\")).\nThis plot shows point estimates with confidence intervals for the linear covariates in model_list, enabling comparison of their effects across models. We observe that higher mean minimum temperatures lagged by one month, as well as wetter conditions at the same lag, are both associated with a significant increase in dengue cases.\nplot_coef_lin(\n  model = model_list,\n  mod_id = c(\"mod2\",\"mod4\"),\n  var_label = c(\"tmin.l1\"= \"Min. temp lag 1\",\n                \"pdsi.l1\" = \"Drought index lag 1\"),\n  title = \"Effects of linear covariates\"\n)\n\n Non-linear coeficients\nThe plot_coef_nl() function generates plots of nonlinear effects from one or more fitted models contained within a GHRmodels object. It visualizes nonlinear covariates (typically created with inla.group()). Users can select non-linear terms to display by name or pattern, and customize labels, axes, and color palettes. The function supports two main display modes:\n\nGrid (collapse = FALSE): one plot per covariate and model, with effects by column and models by row. If multiple models are specified in mod_id, the user must explicitly select which nonlinear covariates to plot using either name or pattern. If only one model is provided then all nonlinear effects will be plotted unless specific ones are selected in name or pattern.\nCollapsed (collapse = TRUE): one non-linear effect combined across models into a single panel. This display mode can only be used when the selected non-linear effect is not replicated across groups (e.g., random effects replicated by meso_area) using the f(INLA::inla.group(covariate,...), model= \"rw2\", replicate = group) format (for more information on replicated effects see vignette(\"GHRmodel_covariates\")).\n\nTo show the distribution of the covariate values, the function provides 2 possibilities. By default, the function overlays a rug plot on the x-axis, which can be removed with rug = FALSE. Optionally, a histogram can be shown below each plot by setting histogram = TRUE.\nHere we plot six models with a non-linear term of PDSI at one to six month lags. We observe that there is an effect of very wet conditions on dengue cases at one month lag, while there is no effect at 2 and 3 lags previous and the relationship inverts at longer lags:\nplot_coef_nl(\n  # List of fitted models from which to extract nonlinear effects\n  models = model_list,\n  # Model IDs to include in the plot (must match names in `model_list`)\n  mod_id = c(paste0(\"mod\", 6:11)),\n  # Custom labels for the selected models (used for legend or facet titles)\n  mod_label = c(\n    \"mod6\"  = \"pdsi.l1_nl\",\n    \"mod7\" = \"pdsi.l2_nl\", \n    \"mod8\" = \"pdsi.l3_nl\",\n    \"mod9\" = \"pdsi.l4_nl\",\n    \"mod10\" = \"pdsi.l5_nl\", \n    \"mod11\" = \"pdsi.l6_nl\"\n  ),\n  # Custom labels for the nonlinear covariates (used in axis or strip labels)\n  var_label = c(\n    \"pdsi.l1\" = \"Drought index (PDSI) lag 1\",\n    \"pdsi.l2\" = \"Drought index (PDSI) lag 2\",\n    \"pdsi.l3\" = \"Drought index (PDSI) lag 3\",\n    \"pdsi.l4\" = \"Drought index (PDSI) lag 4\",\n    \"pdsi.l5\" = \"Drought index (PDSI) lag 5\", \n    \"pdsi.l6\" = \"Drought index (PDSI) lag 6\"\n  ),\n  # Include only variables whose names contain \"pdsi\"\n  pattern = \"pdsi\",\n  # Title for the entire plot\n  title = \"Change in non-linear term for drought index (PDSI) with and without mean min. temp lag 1\",\n  # Label for the x-axis\n  xlab = \"PDSI\",\n  # Color palette to use for plotting (a predefined IDExtremes palette)\n  palette = \"IDE2\",\n  # Grid display mode\n  collapse = FALSE,\n  # Disable rug plot on the x-axis\n  rug = FALSE\n)\n\n Here we plot 2 models with a non-linear term of PDSI at one month lag, with and without an additional non-linear term for mean minimum temperature at one-month lag in collapsed mode. We observe that the effect of PDSI does not change substantially when a temperature covariate is added:\nplot_coef_nl(\n  models = model_list,\n  mod_id = c( \"mod5\", \"mod6\") ,\n  mod_label = c(\"mod6\" = \"pdsi.l1_nl\",\n                \"mod5\" = \"pdsi.l1_nl + tmin.l1_nl\"),\n  var_label = c(\"pdsi.l1\" = \"Drought index (PDSI)\"),\n  name = c(\"pdsi.l1\"),\n  title = \"Change in non-linear term for drought index (PDSI) \\n with and without mean min. temp lag 1\",\n  xlab = \"PDSI\",\n  palette = \"IDE2\",\n  collapse = TRUE         # Combine all plots into a single panel\n)\n\n\n\nEvaluate random effects\nThe plot_re() function provides flexible tools for visualizing spatial or temporal random effects from a fitted GHRmodels object. It supports replicated or grouped effects via the rep_id argument and allows customization of labels, color palettes, and legend titles. Depending on the input, it can produce either:\n\nCaterpillar plots of estimated median effect sizes with uncertainty intervals, or\nSpatial maps (when plotting spatial random effects and an sf object is provided) display the geographic distribution of estimated median random effects across spatial units. To enable this, users must specify the map_area argument, which defines the column in the sf object that uniquely identifies each spatial unit. It is essential that the values in this column match exactly with the spatial IDs (re_id) used in the model to ensure proper alignment and accurate mapping.\n\n\nüìù Note: When climate covariates are not included in a model, random effects may capture unmeasured or unexplained drivers of seasonality (e.g., timing of the warm/rainy season) and interannual variability (e.g., El Ni√±o‚ÄìSouthern Oscillation (ENSO) events that can lead to anomalous climate patterns/extreme events)\n\nThe following plot visualizes the estimated yearly random effects from three different models. The re_id argument (\"year_id\") corresponds to the indexing variable used in the INLA model‚Äôs random effect term (in this case f(year_id, ...)). The re_label maps this ID back to the original variable in the dataset (year), allowing the x-axis to display readable calendar years instead of numeric IDs.\nThe plot suggests that the addition of covariates alters the contribution of the yearly random effect in accounting for interannual variability in some years. For example, in 2004 and 2018, the inclusion of climate covariates resulted in a small reduction (shift towards the null) of the contribution of the yearly random effect.\nplot_re(\n  model = model_list, # A GHRmodels object containing fitted model outputs\n  mod_id = c(\"mod1\", \"mod3\", \"mod5\"), # IDs of the models to compare (must match those in model_list)\n  \n  mod_label = c(\"Baseline\", # Label for mod1: baseline model\n                \"tmin.l1_nl\", # Label for mod4: includes PDSI replicated by climate\n                \"pdsi.l1_nl + tmin.l1_nl\"), # Label for mod6: includes nonlinear effects of PDSI and Tmin\n  \n  re_id = \"year_id\",  # Name of the random effect variable (as defined in model structure)\n  re_label = \"year\",  # Optional: label to map year_id to calendar years\n  \n  ref_color = \"grey\",  # Color to use for the first (reference) model‚Äôs effects\n  palette = \"IDE2\", # Color palette for other model effects\n  \n  title = \"Yearly Random Effect\", # Title for the plot\n  xlab = \"Year\" # Label for the x-axis (since re_label maps ID to actual years)\n)\n\n Below we produce a faceted plot of monthly random effects replicated across mesoregions, allowing for comparison of temporal variation across four models. This visualization is useful for examining how model structure influences unexplained temporal variability across regions.\n\nüí° Tip: Users can customize the variables used in the visualization by modifying the GHRmodels$data element. In this example we add a more descriptive month label:\n\n# Maps integers 1‚Äì12 to \"January\" through \"December\" using R‚Äôs built-in month.name vector\nmodel_list[[\"data\"]] &lt;- model_list[[\"data\"]]|&gt;\n  dplyr::mutate(month_label = month.name[month_id]) \nEach facet in the plot corresponds to a different mesoregion, and the plotted lines show the monthly random effects estimated by each model. The use of re_id, rep_id, and their associated label mappings (re_label, rep_label) ensures that both temporal and spatial structures are clearly presented.\nThis plot suggests that the covariates in all mesoregions explain a substantial portion of the seasonality (the monthly random effect values are closer to 0).\nplot_re(\n  models = model_list, # A GHRmodels object containing fitted model outputs\n  \n  mod_id = c(\"mod1\", \"mod3\", \"mod5\"), # IDs of the models to compare (must match those in model_list)\n  \n  mod_label = c(\"Baseline\", # Label for mod1: baseline model\n                \"tmin.l1_nl\", # Label for mod4: includes PDSI replicated by climate\n                \"pdsi.l1_nl + tmin.l1_nl\"), # Label for mod6: includes nonlinear effects of PDSI and Tmin\n  \n  re_id = \"month_id\", # Name of the random effect in the model formula (e.g., f(month_id, ...))\n  re_label = \"month_label\", # Variable in the dataset corresponding to readable month names\n  \n  rep_id = \"spat_meso_id\", # Variable indicating the grouping structure (replication across meso areas)\n  rep_label = \"meso_name\",# Variable to label facets (e.g., \"Centro Norte\", \"Sudoeste\", etc.)\n  \n  ref_color = \"grey\", # Color for the reference model (first listed in mod_id)\n  palette = \"IDE2\", # Palette for coloring additional models\n  \n  title = \"Monthly random effect repeated by meso area\",  # Plot title\n  xlab = \"Month\" # Label for x-axis (calendar month, from re_label)\n)\n\n Here we create a caterpillar plot of the spatial random effects for four models. Each point represents the estimated effect for a microregion, with models compared side by side. The re_id refers to the variable used in the model to define spatial units, and re_label is used to map those to more interpretable labels (e.g., actual microregion names).\nplot_re(\n  models = model_list, # A GHRmodels object containing the output of fitted models\n  \n  mod_id = c(\"mod1\", \"mod3\", \"mod5\"), # IDs of the models to compare (must match those in model_list)\n  \n  mod_label = c(\"Baseline\", # Label for mod1: baseline model\n                \"tmin.l1_nl\", # Label for mod4: includes PDSI replicated by climate\n                \"pdsi.l1_nl + tmin.l1_nl\"), # Label for mod6: includes nonlinear effects of PDSI and Tmin\n  \n  re_id = \"spat_id\",  # Name of the spatial random effect variable as defined in the model\n  re_label = \"micro_name\", # Optional label to map spat_id to readable microregion names \n  \n  title = \"Spatial random effects\",  # Title of the plot\n  xlab = \"Micro code for spatial units\" # Label for the x-axis \n)\n\n\nThis version of plot_re() displays spatial random effects on a map, using the polygon geometries provided in the map_MS object. The map_area argument must match the name of the variable in the sf object (map_MS) that corresponds to the re_id used in the model (here, spat_id in the data matches to code in the sf object).\nThe resulting plot shows the median of the posterior distribution of the random effect per area, allowing users to visually assess spatial patterns in unexplained variability across the study region. Each facet (if multiple models are used) displays how spatial structure changes based on model specification.\nHere we observe that, in some areas, the inclusion of climate covariates in the model do not change the contribution of the spatial random effect, suggesting they are accounting for other sources of overdispersion or spatial autocorrelation (e.g., variation in interventions). In some microregions (e.g.¬†the southernmost microregion), the inclusion of climate covariates in the model leads to a reduction in the contribution of the spatial effect, suggesting the climate may help understand some of the spatial variation in disease risk in this area.\nplot_re(\n  models = model_list, # A GHRmodels object containing the output of fitted models\n  \n  mod_id = c(\"mod1\", \"mod3\", \"mod5\"), # IDs of the models to compare (must match those in model_list)\n  \n  mod_label = c(\"Baseline\", # Label for mod1: baseline model\n                \"tmin.l1_nl\", # Label for mod4: includes PDSI replicated by climate\n                \"pdsi.l1_nl + tmin.l1_nl\"), # Label for mod6: includes nonlinear effects of PDSI and Tmin\n  \n  re_id = \"spat_id\", # Name of the spatial random effect variable used in model\n  re_label = \"micro_name\", # Variable used to map IDs to readable names\n  \n  map = map_MS, # An sf object with polygon boundaries for plotting\n  map_area = \"code\", # Name of the column in map_MS that matches spat_id in the model\n  \n  title = \"Spatial random effects\", # Title for the spatial plot\n  \n  legend = \"Median of the \\nrandom effect ppd\" # Title for the legend\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_overview.html#iterative-model-selection",
    "href": "docs/GHRmodel/GHRmodel_overview.html#iterative-model-selection",
    "title": "Introduction to GHRmodel",
    "section": "4. Iterative model selection",
    "text": "4. Iterative model selection\nIterative model selection for inference or prediction often involves stepwise addition of covariates, followed by evaluating how each new covariate affects both the outcome and overall model fit. The GHRmodel helper functions (subset_models(), stack_models(), get_covariates(), and cov_add()), together with the model evaluation functions, streamline this process. Below, we present a simple example illustrating how such an iterative workflow might be implemented in our case study:\n\nSubset models\nUse subset_models() to subset selected models from a GHRmodels object into a new reduced GHRmodels object. If new_name is supplied, it will prefix the new model IDs (e.g., \"best_waic_1\", \"best_waic_2\").\nHere we use the vector produced using rank_models to subset the model_list GHRmodels object into an object with only the 2 best ranking WAIC models:\n# Extract a vector with the model IDs of the 2 best fitting models by WAIC\nbest_waic &lt;- rank_models(\n  models = model_list,  # GHRmodels object containing model fit results\n  metric = \"waic\",      # Metric used to rank models (lower WAIC is better)\n  n = 2                 # Number of top-ranked models to return\n)\n\n# The output is a vector \nbest_waic\n#&gt; [1] \"mod5\" \"mod3\"\n\n# Subset those specific models and assign new IDs\nmodel_waic &lt;- subset_models(\n  model = model_list,\n  mod_id = best_waic,\n  new_name = \"best_waic\"\n)\n\n# The output is a reduced GHRmodels object\nclass(model_waic)\n#&gt; [1] \"GHRmodels\" \"list\"\n\n# Inspect the model IDs of the subset GHRmodels object\nhead(model_waic$mod_gof$model_id) \n#&gt; [1] \"best_waic1\" \"best_waic2\"\n\n\nExtract covariates\nUse get_covariates() to inspect which covariates were included in your fitted models. You can choose to retrieve:\n\nAll covariate combinations as specified in each model by setting unique = FALSE. This preserves the exact combinations used in each model.\nA list of unique covariate terms by setting unique = TRUE. This shows each covariate only once, regardless of how many models it appears in.\n\n# Get all covariate combinations as declared in the best-fitting models\nbest_waic_cov &lt;- get_covariates(model = model_waic, unique = FALSE)\n\n# Visualize covariate combinations \nbest_waic_cov\n#&gt; [[1]]\n#&gt; [1] \"f(INLA::inla.group(tmin.l1, method = 'quantile', n = 10), model = 'rw2')\"\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"f(INLA::inla.group(pdsi.l1, method = 'quantile', n = 10), model = 'rw2')\"\n#&gt; [2] \"f(INLA::inla.group(tmin.l1, method = 'quantile', n = 10), model = 'rw2')\"\n\n# Get all unique covariates across the best-fitting models\nbest_waic_cov_unique &lt;- get_covariates(model = model_waic, unique = TRUE)\n\n# Visualize unique covariates \nbest_waic_cov_unique\n#&gt; [[1]]\n#&gt; [1] \"f(INLA::inla.group(tmin.l1, method = 'quantile', n = 10), model = 'rw2')\"\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"f(INLA::inla.group(pdsi.l1, method = 'quantile', n = 10), model = 'rw2')\"\n\n\nAdd an additional covariate\nThe cov_add() function appends one or more covariate names to each set of covariates in a list.\nHere we add the covariate urban to the covariates of the best fitting models:\nbest_waic_cov_urban &lt;- cov_add(best_waic_cov, name= \"urban\")\n\nhead(best_waic_cov_urban)\n#&gt; [[1]]\n#&gt; [1] \"f(INLA::inla.group(tmin.l1, method = 'quantile', n = 10), model = 'rw2')\"\n#&gt; [2] \"urban\"                                                                   \n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"f(INLA::inla.group(pdsi.l1, method = 'quantile', n = 10), model = 'rw2')\"\n#&gt; [2] \"f(INLA::inla.group(tmin.l1, method = 'quantile', n = 10), model = 'rw2')\"\n#&gt; [3] \"urban\"\nNext, we generate a new set of model formulas by converting the covariate list including urban into a standardized formula structure using write_inla_formulas() and converting into a GHRformulas object using as_GHRformulas():\n\n# Build a list of INLA-compatible model formulas including outcome, covariates, and random effects\nformulas_cov_urban_list &lt;- write_inla_formulas(\n  # Outcome (dependent variable) in all formulas\n  outcome = \"dengue_cases\",\n  # List of covariate sets to be included in the formulas (generated earlier as cov_list)\n  covariates = best_waic_cov_urban ,\n  # First random effect: monthly seasonality\n  re1 = list(\n    id        = \"month_id\",      # Time index for monthly effect\n    model     = \"rw1\",           # First-order random walk model\n    cyclic    = TRUE,            # Enforce cyclicity over months (Dec ‚Üí Jan wrap-around)\n    hyper     = \"prior_t\",       # Hyperprior object for precision\n    replicate = \"spat_meso_id\"   # Separate seasonal pattern per mesoregion\n  ),\n  # Second random effect: inter-annual trend\n  re2 = list(\n    id    = \"year_id\",           # Year index\n    model = \"rw1\",               # First-order random walk model\n    hyper = \"prior_t\"            # Hyperprior for temporal smoothness\n  ),\n  # Third random effect: spatial autocorrelation\n  re3 = list(\n    id    = \"spat_id\",           # Spatial unit identifier\n    model = \"bym2\",              # BYM2 spatial model (structured + unstructured)\n    graph = \"g\",                 # Pre-computed spatial adjacency graph\n    hyper = \"prior_sp\"           # PC priors for BYM2 model parameters\n  ),\n  # Include a baseline random effect-only model formula as 1st element in the list\n  baseline = TRUE\n)\n\n# Convert into a GHRformulas object \nformulas_cov_urban_list_ghr &lt;- as_GHRformulas(formulas = formulas_cov_urban_list)\n\n\nFit new models\nThen we can fit the models to assess the added effect of urban on dengue cases:\nmodel_urban_list &lt;- fit_models(\n  formulas = formulas_cov_urban_list_ghr, # GHRformulas object\n  data = data,                      # Data to fit the models \n  family = \"nbinomial\",             # Negative binomial likelihood\n  name = \"mod\",                     # Label prefix for each model\n  offset = \"population\",            # Offset variable to account for population size\n  control_compute = list(\n    config = FALSE,                 # Do not posterior predictive distribution\n    vcov = FALSE                    # Do not return variance-covariance matrix\n  ),\n  nthreads = 8                      # Use 8 threads for parallel computation\n)\n\n\nCombine models\nUse stack_models() (or merge_models()) to merge two or more GHRmodels objects into one. This is particularly useful when comparing batches of models fitted with different modeling strategies. Currently it only supports sets of models sharing the same random effect structure. If any mod_ids are duplicated across models, new_name must be provided to ensure unique IDs.\nHere we combine the GHRmodel objects with the urban covariate to the best-fitting models without the urban covariate to compare fit:\n# Merge models from different objects\nmodel_stack &lt;- stack_models(\n  model_waic,\n  model_urban_list,\n  new_name = \"mod\"\n)\n\n# The combined model_stack combines the best fitting models by WAIC and those including the urban covariate\nmodel_stack$mod_gof$model_id  \n#&gt; [1] \"best_waic1\" \"best_waic2\" \"mod1\"       \"mod2\"       \"mod3\"\n\n\nEvaluate combined models\nUsing the rank_models() and plot_gof() we observe that adding the urban covariate does not improve the model fit by WAIC compared to models that only have 1-month lag terms for mean minimum temperature and PDSI.\nrank_models(model_stack, \n            metric = \"waic\")\n#&gt; [1] \"best_waic2\" \"best_waic1\" \"mod2\"       \"mod3\"       \"mod1\"\n# Add a variable to the mod_gof dataframe to distinguish models with the urban covariate\nmodel_stack_gof  &lt;- model_stack$mod_gof |&gt; \n  dplyr::mutate(\n    `Add urban` = dplyr::case_when(\n      grepl(\"urban\", covariate_3, ignore.case = TRUE) |\n        grepl(\"urban\", covariate_2, ignore.case = TRUE)\n      ~ \"yes\", \n      is.na(covariate_3) == TRUE ~ \"no\"\n    ))\n# Plot change in WAIC for each model compared to the baseline (first model in the list)\nplot_gof(\n  mod_gof = model_stack_gof,           # Goodness-of-fit data from model_list\n  metric = \"waic\",                     # Compare WAIC \n  ci = TRUE,                           # Include credible intervals (if available)\n  var_arrange = \"waic\",                # Arrange models by WAIC \n  var_color =  \"Add urban\", \n  mod_label = c(\n    \"mod1\" = \"Baseline\",                 \n    \"mod2\" = \"tmin.l1_nl + urban\",      \n    \"mod3\" = \"tmin.l1_nl + pdsi.l1_nl + urban\", \n    \"best_waic1\" = \"tmin.l1_nl\", \n    \"best_waic2\" = \"tmin.l1_nl + pdsi.l1_nl\"\n  )\n)\n\nWe also observe that the 95% credible interval of the effect of urban on the outcome (dengue cases) contains zero.\nplot_coef_lin(\n  model = model_stack,\n  title = \"Effects of linear covariates\"\n)\n\nThese results point against including urban as a linear covariate in the final model."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-index.html",
    "href": "docs/GHRmodel/GHRmodel-index.html",
    "title": "GHRmodel reference",
    "section": "",
    "text": "as_GHRformulas: This function converts a character vector of suitable R-INLA formulas into a structured GHRformulas object.\ncov_add: This function appends one or more covariate names to all elements (i.\ncov_interact: This function generates interaction terms between covariates specified in the pattern or name arguments.\ncov_multi: This function generates all possible combinations of covariates by selecting one variable from each user-defined group.\ncov_nl: This function transforms selected covariates identified by pattern or name into non-linear terms using INLA‚Äôs f() syntax.\ncov_uni: This function returns a list where each element contains a single covariate, based on covariates specified in the pattern or name arguments.\ncov_varying: This function transforms covariates identified by pattern or name into varying effect terms of the form: f(unit, covariate, model = ‚Äòiid‚Äô) , which allows covariates to have varying slopes across spatial or temporal units.\ncrossbasis_inla: This function is a wrapper around dlnm::crossbasis to generate cross-basis matrices that capture nonlinear effects of a predictor across both exposure and lag dimensions.\ncrosspred_inla: This function takes an object of class GHRmodels , extracts the relevant coefficients and variance-covariance matrix, and then calls dlnm::crosspred to compute predictions over a range of covariate values (or at specified points).\ndengue_MS: The dengue_MS example data set contains monthly counts of notified dengue cases by microregion, along with a range of spatial and spatiotemporal covariates (e.\ndengue_SP: The dengue_SP example data set reports the weekly number of notified dengue cases in the municipality of S√£o Paulo together with climatic covariates.\nextract_names: This function allows the user to select variables from a data set by prefix (using the pattern argument) or by exact name matching.\nfit_models: This function fits a set of INLA model formulas, provided in a GHRformulas object, to a specified dataset.\nget_covariates: Extracts covariates from a GHRmodels object and returns them as a list of character vectors.\nlag_cov: This function creates lagged versions of one or more numeric or categorical variables in an equally spaced time-series data set.\nmap_MS: A simple feature ( sf ) multipolygon object representing a map of Mato Grosso do Sul , Brazil, including 11 municipalities.\nonebasis_inla: This function is a wrapper around onebasis to create a one-dimensional basis for spline modeling.\nplot_coef_crosspred: Generate plots from a ‚Äúcrosspred‚Äù object.\nplot_coef_lin: This function extracts fixed-effect coefficients from a specified model in models , filters them by name or interaction pattern, and produces a forest plot (point estimates with error bars).\nplot_coef_nl: Generates plots of nonlinear effects from one or more fitted models contained within a GHRmodels object.\nplot_coef_varying: Generates a forest plot for a specified spatially or temporally varying coefficient (i.\nplot_fit: This function creates a time-series plot comparing observed cases with fitted values from one or more models in a GHRmodels object.\nplot_gof: Provides visualization of model performance using selected goodness-of-fit (GoF) metrics for one or more models.\nplot_ppd: This function draws kernel-density curves for posterior-predictive samples and observed data using ggplot2::geom_line() .\nplot_re: Generates plots of random effects from one or more fitted models contained within a GHRmodels object.\nrank_models: This function ranks fitted models in a GHRmodels object by a chosen metric (e.\nsample_ppd: This function refits a specified model from a GHRmodels object and generates samples from its posterior predictive distribution.\nstack_models: This function stack together two or more objects GHRmodels object, returning one GHRmodels object that contains all the input models.\nsubset_models: This function subsets selected models from a GHRmodels object into a new reduced GHRmodels object.\nwrite_inla_formulas: This function streamlines the creation of INLA-compatible model formulas by automatically structuring fixed effects, random effects, and interactions."
  },
  {
    "objectID": "docs/data4health/data4health.html",
    "href": "docs/data4health/data4health.html",
    "title": "data4health",
    "section": "",
    "text": "Under construction."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/map_MS.Rd.html",
    "href": "docs/GHRexplore/GHRexplore-reference/map_MS.Rd.html",
    "title": "Municipality boundaries of Mato Grosso do Sul",
    "section": "",
    "text": "Administrative boundaries (polygon geometries) of the 11 municipalities in Mato Grosso do Sul (Brazil) to be used with the dengue_MS data set.\ndata(map_MS)\n\n\n\nA simple feature (sf) object including 11 rows and 2 columns:\n\ncode: Unique ID number to each micro region (11 units).\ngeometry: Geometries of the sf multipolygon."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/map_MS.Rd.html#description",
    "href": "docs/GHRexplore/GHRexplore-reference/map_MS.Rd.html#description",
    "title": "Municipality boundaries of Mato Grosso do Sul",
    "section": "",
    "text": "Administrative boundaries (polygon geometries) of the 11 municipalities in Mato Grosso do Sul (Brazil) to be used with the dengue_MS data set.\ndata(map_MS)"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/map_MS.Rd.html#format",
    "href": "docs/GHRexplore/GHRexplore-reference/map_MS.Rd.html#format",
    "title": "Municipality boundaries of Mato Grosso do Sul",
    "section": "",
    "text": "A simple feature (sf) object including 11 rows and 2 columns:\n\ncode: Unique ID number to each micro region (11 units).\ngeometry: Geometries of the sf multipolygon."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/aggregate_cov.Rd.html",
    "href": "docs/GHRexplore/GHRexplore-reference/aggregate_cov.Rd.html",
    "title": "Aggregate covariates",
    "section": "",
    "text": "Aggregates a data frame containing a covariate of interest in space and/or time.\naggregate_cov(\n  data = NULL,\n  var = NULL,\n  time = NULL,\n  area = NULL,\n  aggregate_space = NULL,\n  aggregate_time = NULL,\n  aggregate_space_fun = \"mean\",\n  aggregate_time_fun = \"mean\"\n)\n\n\n\n\ndata: Data frame containing equally spaced (daily, weekly, monthly) incident cases for one or multiple areas.\nvar: Name of the variable that identifies the covariate.\ntime: Name of the variable that identifies the temporal dimension. The values must be in date format (‚Äúyyyy-mm-dd‚Äù) representing the date of observation for daily data, the first day of the week for weekly, or the first day of the month for monthly observations.\narea: Name of variable that identifies the different locations (i.e., areal units) for which a time series is available.\naggregate_space: Name of variable used to define spatial aggregation groups.\naggregate_time: Temporal scale used to perform temporal aggregation. Options are: ‚Äúweek‚Äù (ISO 8601), ‚Äúmonth‚Äù, ‚Äúyear‚Äù.\naggregate_space_fun: Character indicating the function to be used in the aggregation over space, default is ‚Äúmean‚Äù.\naggregate_time_fun: Character indicating the function to be used in the aggregation over time, default is ‚Äúmean‚Äù.\n\n\n\n\nA data frame with the aggregated covariate."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/aggregate_cov.Rd.html#description",
    "href": "docs/GHRexplore/GHRexplore-reference/aggregate_cov.Rd.html#description",
    "title": "Aggregate covariates",
    "section": "",
    "text": "Aggregates a data frame containing a covariate of interest in space and/or time.\naggregate_cov(\n  data = NULL,\n  var = NULL,\n  time = NULL,\n  area = NULL,\n  aggregate_space = NULL,\n  aggregate_time = NULL,\n  aggregate_space_fun = \"mean\",\n  aggregate_time_fun = \"mean\"\n)"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/aggregate_cov.Rd.html#arguments",
    "href": "docs/GHRexplore/GHRexplore-reference/aggregate_cov.Rd.html#arguments",
    "title": "Aggregate covariates",
    "section": "",
    "text": "data: Data frame containing equally spaced (daily, weekly, monthly) incident cases for one or multiple areas.\nvar: Name of the variable that identifies the covariate.\ntime: Name of the variable that identifies the temporal dimension. The values must be in date format (‚Äúyyyy-mm-dd‚Äù) representing the date of observation for daily data, the first day of the week for weekly, or the first day of the month for monthly observations.\narea: Name of variable that identifies the different locations (i.e., areal units) for which a time series is available.\naggregate_space: Name of variable used to define spatial aggregation groups.\naggregate_time: Temporal scale used to perform temporal aggregation. Options are: ‚Äúweek‚Äù (ISO 8601), ‚Äúmonth‚Äù, ‚Äúyear‚Äù.\naggregate_space_fun: Character indicating the function to be used in the aggregation over space, default is ‚Äúmean‚Äù.\naggregate_time_fun: Character indicating the function to be used in the aggregation over time, default is ‚Äúmean‚Äù."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/aggregate_cov.Rd.html#returns",
    "href": "docs/GHRexplore/GHRexplore-reference/aggregate_cov.Rd.html#returns",
    "title": "Aggregate covariates",
    "section": "",
    "text": "A data frame with the aggregated covariate."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_map.Rd.html",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_map.Rd.html",
    "title": "Choropleth map",
    "section": "",
    "text": "Plots a choropleth map of covariates, case counts, or incidence rates.\nplot_map(\n  data,\n  var,\n  time,\n  type = \"cov\",\n  pop = NULL,\n  pt = 1e+05,\n  area = NULL,\n  map = NULL,\n  map_area = NULL,\n  by_year = NULL,\n  aggregate_time = \"year\",\n  aggregate_time_fun = \"mean\",\n  transform = \"identity\",\n  title = NULL,\n  var_label = NULL,\n  palette = NULL,\n  centering = NULL,\n  bins = NULL,\n  bins_method = \"quantile\",\n  bins_label = NULL,\n  ...\n)\n\n\n\n\ndata: Data frame containing equally spaced (daily, weekly, monthly) covariate or case observations for one or multiple locations.\nvar: Name of the column identifying the variable to be plotted.\ntime: Name of the variable that identifies the temporal dimension of the data frame. Its values must be in date format (‚Äúyyyy-mm-dd‚Äù) representing the day of observation for daily data, the first day of the week for weekly, or the first day of the month for monthly observations.\ntype: Character that specifies the type of variable in var. Possible values include ‚Äòcov‚Äô (covariate, default), ‚Äòcounts‚Äô (case counts), and ‚Äòinc‚Äô (case incidence). If type='inc', pop is required.\npop: Character identifying the variable name for population. Only needed if type='inc'.\npt: Scale of the person-time (default 100,000) for incidence rates.\narea: Name of variable that identifies the different locations (e.g., areal units) for which a time series is available.\nmap: Name of the sf object corresponding to the spatial unit specified in ‚Äòarea‚Äô.\nmap_area: Name of the variable that identifies the different locations (e.g., areal units) in the map object. If not specified, it assumes the same name as in area.\nby_year: Deprecated. Use ‚Äòaggregate_time‚Äô instead.\naggregate_time: Temporal scale for visualization and aggregation. Options include ‚Äúall‚Äù (across all time points) and ‚Äúyear‚Äù (default).\naggregate_time_fun: Character indicating the function to be used in the aggregation over time for type=\"cov\". Options are ‚Äúmean‚Äù (default), ‚Äúmedian‚Äù, ‚Äúsum‚Äù. For case counts and incidence, ‚Äúsum‚Äù is always applied.\ntransform: Character, defaults to ‚Äúidentity‚Äù (i.e., no transformation). Transforms the color ramp for better visualization. Useful options include ‚Äúlog10p1‚Äù log10(x+1) for case counts and incidence with 0s, or any of the in-built ggplot2 options such as ‚Äúlog10‚Äù log10(x), ‚Äúlog1p‚Äù log(x+1), and ‚Äúsqrt‚Äù sqrt(x) (check all possible options using ?scale_y_continuous).\ntitle: Optional title of the plot.\nvar_label: Character with a custom name for the case or covariate variable.\npalette: GHR, RColorBrewer or colorspace palette. Use ‚Äú-‚Äù before the palette name (e.g., ‚Äú-Reds‚Äù) to reverse it.\ncentering: Numerical or ‚Äúmedian‚Äù, defaults to NULL. If set, it centers the palette on that value.\nbins: Number of bins for categorization of numerical variables. Defaults to NULL (no binning).\nbins_method: Method to compute the bins, only used when bins is not NULL. Possible values are ‚Äúquantile‚Äù (default) and ‚Äúequal‚Äù.\nbins_label: Optional labels for the bins. They must have the same length as the number of bins. Defaults to NULL (default interval labels).\n...: Additional aesthetics to be passed to geom_sf. Possible values include colour (e.g., colour=\"black\"), linewidth (e.g., linewidth=0.1), linetype (e.g., linetype=2), and alpha (e.g., alpha=0.8).\n\n\n\n\nA ggplot2 choropleth map.\n\n\n\n# Load data\nlibrary(\"sf\")\ndata(\"dengue_MS\")\ndata(\"map_MS\")\n\n# Temporal average of a covariate\nplot_map(data = dengue_MS, \n         var = \"tmin\",  \n         time = \"date\",       \n         type = \"cov\",\n         area = \"micro_code\",  \n         map = map_MS,         \n         map_area = \"code\",   \n         aggregate_time = \"all\",\n         aggregate_time_fun = \"mean\",         \n         palette =\"Reds\",\n         var_label= \"Min Temp.\")\n\n# Categorical covariate\nplot_map(data = dengue_MS, \n         var = \"biome_name\",        \n         time = \"date\",      \n         area = \"micro_code\", \n         aggregate_time = \"all\",\n         map = map_MS,       \n         map_area = \"code\",  \n         palette =\"Viridis\",\n         var_label= \"Biome\")\n\n# Case counts by year (log)\ndengue_MS |&gt;\n  plot_map(var = \"dengue_cases\",    \n           time = \"date\",    \n           type = \"counts\",\n           area = \"micro_code\", \n           pop = \"population\",\n           map = map_MS,   \n           map_area = \"code\",\n           palette = \"Reds\",\n           transform = \"log10p1\")\n\n# Case incidence by year, binned\nplot_map(dengue_MS,\n         var = \"dengue_cases\", \n         type = \"inc\",\n         time = \"date\",\n         area = \"micro_code\",\n         pop = \"population\",\n         pt = 1000,\n         map = map_MS, \n         map_area = \"code\",\n         bins = 5,   \n         palette = \"Viridis\")"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_map.Rd.html#description",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_map.Rd.html#description",
    "title": "Choropleth map",
    "section": "",
    "text": "Plots a choropleth map of covariates, case counts, or incidence rates.\nplot_map(\n  data,\n  var,\n  time,\n  type = \"cov\",\n  pop = NULL,\n  pt = 1e+05,\n  area = NULL,\n  map = NULL,\n  map_area = NULL,\n  by_year = NULL,\n  aggregate_time = \"year\",\n  aggregate_time_fun = \"mean\",\n  transform = \"identity\",\n  title = NULL,\n  var_label = NULL,\n  palette = NULL,\n  centering = NULL,\n  bins = NULL,\n  bins_method = \"quantile\",\n  bins_label = NULL,\n  ...\n)"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_map.Rd.html#arguments",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_map.Rd.html#arguments",
    "title": "Choropleth map",
    "section": "",
    "text": "data: Data frame containing equally spaced (daily, weekly, monthly) covariate or case observations for one or multiple locations.\nvar: Name of the column identifying the variable to be plotted.\ntime: Name of the variable that identifies the temporal dimension of the data frame. Its values must be in date format (‚Äúyyyy-mm-dd‚Äù) representing the day of observation for daily data, the first day of the week for weekly, or the first day of the month for monthly observations.\ntype: Character that specifies the type of variable in var. Possible values include ‚Äòcov‚Äô (covariate, default), ‚Äòcounts‚Äô (case counts), and ‚Äòinc‚Äô (case incidence). If type='inc', pop is required.\npop: Character identifying the variable name for population. Only needed if type='inc'.\npt: Scale of the person-time (default 100,000) for incidence rates.\narea: Name of variable that identifies the different locations (e.g., areal units) for which a time series is available.\nmap: Name of the sf object corresponding to the spatial unit specified in ‚Äòarea‚Äô.\nmap_area: Name of the variable that identifies the different locations (e.g., areal units) in the map object. If not specified, it assumes the same name as in area.\nby_year: Deprecated. Use ‚Äòaggregate_time‚Äô instead.\naggregate_time: Temporal scale for visualization and aggregation. Options include ‚Äúall‚Äù (across all time points) and ‚Äúyear‚Äù (default).\naggregate_time_fun: Character indicating the function to be used in the aggregation over time for type=\"cov\". Options are ‚Äúmean‚Äù (default), ‚Äúmedian‚Äù, ‚Äúsum‚Äù. For case counts and incidence, ‚Äúsum‚Äù is always applied.\ntransform: Character, defaults to ‚Äúidentity‚Äù (i.e., no transformation). Transforms the color ramp for better visualization. Useful options include ‚Äúlog10p1‚Äù log10(x+1) for case counts and incidence with 0s, or any of the in-built ggplot2 options such as ‚Äúlog10‚Äù log10(x), ‚Äúlog1p‚Äù log(x+1), and ‚Äúsqrt‚Äù sqrt(x) (check all possible options using ?scale_y_continuous).\ntitle: Optional title of the plot.\nvar_label: Character with a custom name for the case or covariate variable.\npalette: GHR, RColorBrewer or colorspace palette. Use ‚Äú-‚Äù before the palette name (e.g., ‚Äú-Reds‚Äù) to reverse it.\ncentering: Numerical or ‚Äúmedian‚Äù, defaults to NULL. If set, it centers the palette on that value.\nbins: Number of bins for categorization of numerical variables. Defaults to NULL (no binning).\nbins_method: Method to compute the bins, only used when bins is not NULL. Possible values are ‚Äúquantile‚Äù (default) and ‚Äúequal‚Äù.\nbins_label: Optional labels for the bins. They must have the same length as the number of bins. Defaults to NULL (default interval labels).\n...: Additional aesthetics to be passed to geom_sf. Possible values include colour (e.g., colour=\"black\"), linewidth (e.g., linewidth=0.1), linetype (e.g., linetype=2), and alpha (e.g., alpha=0.8)."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_map.Rd.html#returns",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_map.Rd.html#returns",
    "title": "Choropleth map",
    "section": "",
    "text": "A ggplot2 choropleth map."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_map.Rd.html#examples",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_map.Rd.html#examples",
    "title": "Choropleth map",
    "section": "",
    "text": "# Load data\nlibrary(\"sf\")\ndata(\"dengue_MS\")\ndata(\"map_MS\")\n\n# Temporal average of a covariate\nplot_map(data = dengue_MS, \n         var = \"tmin\",  \n         time = \"date\",       \n         type = \"cov\",\n         area = \"micro_code\",  \n         map = map_MS,         \n         map_area = \"code\",   \n         aggregate_time = \"all\",\n         aggregate_time_fun = \"mean\",         \n         palette =\"Reds\",\n         var_label= \"Min Temp.\")\n\n# Categorical covariate\nplot_map(data = dengue_MS, \n         var = \"biome_name\",        \n         time = \"date\",      \n         area = \"micro_code\", \n         aggregate_time = \"all\",\n         map = map_MS,       \n         map_area = \"code\",  \n         palette =\"Viridis\",\n         var_label= \"Biome\")\n\n# Case counts by year (log)\ndengue_MS |&gt;\n  plot_map(var = \"dengue_cases\",    \n           time = \"date\",    \n           type = \"counts\",\n           area = \"micro_code\", \n           pop = \"population\",\n           map = map_MS,   \n           map_area = \"code\",\n           palette = \"Reds\",\n           transform = \"log10p1\")\n\n# Case incidence by year, binned\nplot_map(dengue_MS,\n         var = \"dengue_cases\", \n         type = \"inc\",\n         time = \"date\",\n         area = \"micro_code\",\n         pop = \"population\",\n         pt = 1000,\n         map = map_MS, \n         map_area = \"code\",\n         bins = 5,   \n         palette = \"Viridis\")"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_heatmap.Rd.html",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_heatmap.Rd.html",
    "title": "Heatmap plot",
    "section": "",
    "text": "Plots temporal heatmaps of covariates, case counts, or incidence rates.\nplot_heatmap(\n  data,\n  var,\n  time,\n  type = \"cov\",\n  pop = NULL,\n  pt = 1e+05,\n  area = NULL,\n  aggregate_space = NULL,\n  aggregate_time = \"month\",\n  aggregate_space_fun = \"mean\",\n  aggregate_time_fun = \"mean\",\n  transform = \"identity\",\n  title = NULL,\n  var_label = NULL,\n  ylab = NULL,\n  xlab = NULL,\n  palette = NULL,\n  centering = NULL\n)\n\n\n\n\ndata: Data frame containing equally spaced (daily, weekly, monthly) covariate or disease case observations for one or multiple locations.\nvar: Name of the column identifying the variable to be plotted.\ntime: Name of the variable that identifies the temporal dimension of the data frame. Its values must be in date format (‚Äúyyyy-mm-dd‚Äù) representing the day of observation for daily data, the first day of the week for weekly, or the first day of the month for monthly observations.\ntype: Character that specifies the type of variable in var. Possible values include ‚Äòcov‚Äô (covariate, default), ‚Äòcounts‚Äô (case counts), and ‚Äòinc‚Äô (case incidence). If type='inc', pop is required.\npop: Character identifying the variable name for population. Only needed if type='inc'.\npt: Numerical only used for type='inc'. It represents the scale of the person-time (default 100,000) for incidence rates.\narea: Name of variable that identifies the different locations (i.e., areal units) for which a time series is available.\naggregate_space: Name of variable used to define spatial aggregation groups.\naggregate_time: Temporal scale used to perform temporal aggregation. Options are: ‚Äúweek‚Äù (ISO 8601), ‚Äúmonth‚Äù, ‚Äúyear‚Äù.\naggregate_space_fun: Character indicating the function to be used in the aggregation over space for type=\"cov\". Options are ‚Äúmean‚Äù (default), ‚Äúmedian‚Äù, ‚Äúsum‚Äù. For case counts and incidence, ‚Äúsum‚Äù is always applied.\naggregate_time_fun: Character indicating the function to be used in the aggregation over time for type=\"cov\". Options are ‚Äúmean‚Äù (default), ‚Äúmedian‚Äù, ‚Äúsum‚Äù. For case counts and incidence, ‚Äúsum‚Äù is always applied.\ntransform: Character, defaults to ‚Äúidentity‚Äù (i.e., no transformation). Transforms the color ramp for better visualization. Useful options include ‚Äúlog10p1‚Äù log10(x+1) useful for case counts and incidence with 0s, or any of the in-built ggplot2 options such as ‚Äúlog10‚Äù log10(x), ‚Äúlog1p‚Äù log(x+1), and ‚Äúsqrt‚Äù sqrt(x) (check all possible options using ?scale_y_continuous).\ntitle: Optional title of the plot.\nvar_label: Character with a custom name for the case or covariate variable.\nylab: Label for the y-axis.\nxlab: Label for the x-axis.\npalette: GHR, RColorBrewer or colorspace palette. Use ‚Äú-‚Äù before the palette name (e.g., ‚Äú-Reds‚Äù) to reverse it.\ncentering: Numerical or ‚Äúmedian‚Äù, defaults to NULL. If set, it centers the palette on that value.\n\n\n\n\nA ggplot2 heatmap plot.\n\n\n\n# Load data\ndata(\"dengue_MS\")\n\n# Covariate heatmap with space aggregation\nplot_heatmap(dengue_MS,\n             var = \"tmin\",\n             time = \"date\",\n             var_label = \"Minimum\\ntemp.\",\n             type = \"cov\",\n             area = \"micro_code\",\n             aggregate_space = \"meso_code\",  \n             palette = \"Blue-Red\")\n\n# Case count heatmap with log scale\nplot_heatmap(dengue_MS,\n             var = \"dengue_cases\", \n             time = \"date\",  \n             type = \"counts\",\n             area = \"micro_code\",  \n             palette = \"Reds\", \n             title = \"Dengue counts\", \n             var_label = \"Dengue \\ncounts\",\n             transform = \"log10p1\")  \n             \n# Case incidence (for 1,000 persons) heatmap with space aggregation\nplot_heatmap(dengue_MS,\n             var = \"dengue_cases\", \n             time = \"date\",          \n             type = \"inc\",\n             pop = \"population\",\n             pt = 1000,\n             area = \"micro_code\", \n             aggregate_space = \"meso_code\", \n             palette = \"Purp\")"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_heatmap.Rd.html#description",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_heatmap.Rd.html#description",
    "title": "Heatmap plot",
    "section": "",
    "text": "Plots temporal heatmaps of covariates, case counts, or incidence rates.\nplot_heatmap(\n  data,\n  var,\n  time,\n  type = \"cov\",\n  pop = NULL,\n  pt = 1e+05,\n  area = NULL,\n  aggregate_space = NULL,\n  aggregate_time = \"month\",\n  aggregate_space_fun = \"mean\",\n  aggregate_time_fun = \"mean\",\n  transform = \"identity\",\n  title = NULL,\n  var_label = NULL,\n  ylab = NULL,\n  xlab = NULL,\n  palette = NULL,\n  centering = NULL\n)"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_heatmap.Rd.html#arguments",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_heatmap.Rd.html#arguments",
    "title": "Heatmap plot",
    "section": "",
    "text": "data: Data frame containing equally spaced (daily, weekly, monthly) covariate or disease case observations for one or multiple locations.\nvar: Name of the column identifying the variable to be plotted.\ntime: Name of the variable that identifies the temporal dimension of the data frame. Its values must be in date format (‚Äúyyyy-mm-dd‚Äù) representing the day of observation for daily data, the first day of the week for weekly, or the first day of the month for monthly observations.\ntype: Character that specifies the type of variable in var. Possible values include ‚Äòcov‚Äô (covariate, default), ‚Äòcounts‚Äô (case counts), and ‚Äòinc‚Äô (case incidence). If type='inc', pop is required.\npop: Character identifying the variable name for population. Only needed if type='inc'.\npt: Numerical only used for type='inc'. It represents the scale of the person-time (default 100,000) for incidence rates.\narea: Name of variable that identifies the different locations (i.e., areal units) for which a time series is available.\naggregate_space: Name of variable used to define spatial aggregation groups.\naggregate_time: Temporal scale used to perform temporal aggregation. Options are: ‚Äúweek‚Äù (ISO 8601), ‚Äúmonth‚Äù, ‚Äúyear‚Äù.\naggregate_space_fun: Character indicating the function to be used in the aggregation over space for type=\"cov\". Options are ‚Äúmean‚Äù (default), ‚Äúmedian‚Äù, ‚Äúsum‚Äù. For case counts and incidence, ‚Äúsum‚Äù is always applied.\naggregate_time_fun: Character indicating the function to be used in the aggregation over time for type=\"cov\". Options are ‚Äúmean‚Äù (default), ‚Äúmedian‚Äù, ‚Äúsum‚Äù. For case counts and incidence, ‚Äúsum‚Äù is always applied.\ntransform: Character, defaults to ‚Äúidentity‚Äù (i.e., no transformation). Transforms the color ramp for better visualization. Useful options include ‚Äúlog10p1‚Äù log10(x+1) useful for case counts and incidence with 0s, or any of the in-built ggplot2 options such as ‚Äúlog10‚Äù log10(x), ‚Äúlog1p‚Äù log(x+1), and ‚Äúsqrt‚Äù sqrt(x) (check all possible options using ?scale_y_continuous).\ntitle: Optional title of the plot.\nvar_label: Character with a custom name for the case or covariate variable.\nylab: Label for the y-axis.\nxlab: Label for the x-axis.\npalette: GHR, RColorBrewer or colorspace palette. Use ‚Äú-‚Äù before the palette name (e.g., ‚Äú-Reds‚Äù) to reverse it.\ncentering: Numerical or ‚Äúmedian‚Äù, defaults to NULL. If set, it centers the palette on that value."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_heatmap.Rd.html#returns",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_heatmap.Rd.html#returns",
    "title": "Heatmap plot",
    "section": "",
    "text": "A ggplot2 heatmap plot."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_heatmap.Rd.html#examples",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_heatmap.Rd.html#examples",
    "title": "Heatmap plot",
    "section": "",
    "text": "# Load data\ndata(\"dengue_MS\")\n\n# Covariate heatmap with space aggregation\nplot_heatmap(dengue_MS,\n             var = \"tmin\",\n             time = \"date\",\n             var_label = \"Minimum\\ntemp.\",\n             type = \"cov\",\n             area = \"micro_code\",\n             aggregate_space = \"meso_code\",  \n             palette = \"Blue-Red\")\n\n# Case count heatmap with log scale\nplot_heatmap(dengue_MS,\n             var = \"dengue_cases\", \n             time = \"date\",  \n             type = \"counts\",\n             area = \"micro_code\",  \n             palette = \"Reds\", \n             title = \"Dengue counts\", \n             var_label = \"Dengue \\ncounts\",\n             transform = \"log10p1\")  \n             \n# Case incidence (for 1,000 persons) heatmap with space aggregation\nplot_heatmap(dengue_MS,\n             var = \"dengue_cases\", \n             time = \"date\",          \n             type = \"inc\",\n             pop = \"population\",\n             pt = 1000,\n             area = \"micro_code\", \n             aggregate_space = \"meso_code\", \n             palette = \"Purp\")"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/dengue_MS.Rd.html",
    "href": "docs/GHRexplore/GHRexplore-reference/dengue_MS.Rd.html",
    "title": "Dengue cases in Mato Grosso do Sul",
    "section": "",
    "text": "Monthly number of notified dengue cases by municipality in the Mato Grosso do Sul state of Brazil and a set of spatial and spatio-temporal covariates.\ndata(dengue_MS)\n\n\n\nA data frame with 2,640 rows and 27 columns:\n\nmicro_code: Unique ID number for each micro region (11 units).\nmicro_name: Name of each micro region.\nmicro_name_ibge: Name of each micro region in IBGE format.\nmeso_code: Unique ID number for each meso region (4 units).\nmeso_name: Name of each meso region.\nstate_code: Unique ID number for each state (1 unit).\nstate_name: Name of each state.\nregion_code: Unique ID number given to each Brazilian Region. All observations come from the ‚ÄúSoutheast Region‚Äù.\nregion_name: Name of each Brazilian Region. All observations come from the ‚ÄúSoutheast Region‚Äù.\nbiome_code: Biome code.\nbiome_name: Biome name.\necozone_code: Ecozone code.\necozone_name: Ecozone name.\nmain_climate: Most prevalent climate regime in the microregion. Based on Koppen Geiger climate regimes.\nmonth: Calendar month index, 1 = January, 12 = December.\nyear: Year 2000 - 2019.\ntime: Time index starting at 1 for January 2000.\ndengue_cases: Number of notified dengue cases registered in the notifiable diseases system in Brazil (SINAN) in the microregion of reference, at the month of first symptoms.\npopulation: Estimated population based on projections calculated using the 2000 and 2010 censuses, as well as population counts from 2007 and 2017.\npop_density: Population density (number of people per km2).\ntmax: Monthly average daily maximum temperature; gridded values (at a 0.5 deg resolution) averaged across each microregion.\ntmin: Monthly average daily minimum temperature; gridded values (at a 0.5 deg resolution) averaged across each microregion.\npdsi: Self-calibrated Palmer Drought Severity Index for each microregion. It measures how wet or dry a region is relative to usual conditions. Negative values represent periods of drought, positive values represent wetter periods. Calculated by taking the mean value within each microregion.\nurban: Percentage of population living in urban areas (2010 census).\nwater_network: Percentage of population with access to the piped water network according to the 2010 census.\nwater_shortage: Frequency of reported water shortages per microregion between 2000 and 2016.\ndate: First day of the month in date format (‚Äú%d-%m-%Y‚Äù).\n\n\n\n\nIn addition to the dengue counts, the dataset contains a set of environmental, socio-economic and meteo-climatic factors. This dataset is a subset of the original containing observations over the entire Brazil.\n\n\n\nhttps://github.com/drrachellowe/hydromet_dengue"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/dengue_MS.Rd.html#description",
    "href": "docs/GHRexplore/GHRexplore-reference/dengue_MS.Rd.html#description",
    "title": "Dengue cases in Mato Grosso do Sul",
    "section": "",
    "text": "Monthly number of notified dengue cases by municipality in the Mato Grosso do Sul state of Brazil and a set of spatial and spatio-temporal covariates.\ndata(dengue_MS)"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/dengue_MS.Rd.html#format",
    "href": "docs/GHRexplore/GHRexplore-reference/dengue_MS.Rd.html#format",
    "title": "Dengue cases in Mato Grosso do Sul",
    "section": "",
    "text": "A data frame with 2,640 rows and 27 columns:\n\nmicro_code: Unique ID number for each micro region (11 units).\nmicro_name: Name of each micro region.\nmicro_name_ibge: Name of each micro region in IBGE format.\nmeso_code: Unique ID number for each meso region (4 units).\nmeso_name: Name of each meso region.\nstate_code: Unique ID number for each state (1 unit).\nstate_name: Name of each state.\nregion_code: Unique ID number given to each Brazilian Region. All observations come from the ‚ÄúSoutheast Region‚Äù.\nregion_name: Name of each Brazilian Region. All observations come from the ‚ÄúSoutheast Region‚Äù.\nbiome_code: Biome code.\nbiome_name: Biome name.\necozone_code: Ecozone code.\necozone_name: Ecozone name.\nmain_climate: Most prevalent climate regime in the microregion. Based on Koppen Geiger climate regimes.\nmonth: Calendar month index, 1 = January, 12 = December.\nyear: Year 2000 - 2019.\ntime: Time index starting at 1 for January 2000.\ndengue_cases: Number of notified dengue cases registered in the notifiable diseases system in Brazil (SINAN) in the microregion of reference, at the month of first symptoms.\npopulation: Estimated population based on projections calculated using the 2000 and 2010 censuses, as well as population counts from 2007 and 2017.\npop_density: Population density (number of people per km2).\ntmax: Monthly average daily maximum temperature; gridded values (at a 0.5 deg resolution) averaged across each microregion.\ntmin: Monthly average daily minimum temperature; gridded values (at a 0.5 deg resolution) averaged across each microregion.\npdsi: Self-calibrated Palmer Drought Severity Index for each microregion. It measures how wet or dry a region is relative to usual conditions. Negative values represent periods of drought, positive values represent wetter periods. Calculated by taking the mean value within each microregion.\nurban: Percentage of population living in urban areas (2010 census).\nwater_network: Percentage of population with access to the piped water network according to the 2010 census.\nwater_shortage: Frequency of reported water shortages per microregion between 2000 and 2016.\ndate: First day of the month in date format (‚Äú%d-%m-%Y‚Äù)."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/dengue_MS.Rd.html#details",
    "href": "docs/GHRexplore/GHRexplore-reference/dengue_MS.Rd.html#details",
    "title": "Dengue cases in Mato Grosso do Sul",
    "section": "",
    "text": "In addition to the dengue counts, the dataset contains a set of environmental, socio-economic and meteo-climatic factors. This dataset is a subset of the original containing observations over the entire Brazil."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/dengue_MS.Rd.html#source",
    "href": "docs/GHRexplore/GHRexplore-reference/dengue_MS.Rd.html#source",
    "title": "Dengue cases in Mato Grosso do Sul",
    "section": "",
    "text": "https://github.com/drrachellowe/hydromet_dengue"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/GHRexplore-package.Rd.html",
    "href": "docs/GHRexplore/GHRexplore-reference/GHRexplore-package.Rd.html",
    "title": "GHRexplore: Exploratory Analysis of Temporal and Spatio-Temporal Health Data",
    "section": "",
    "text": "A collection of commonly used visualizations of temporal and spatio-temporal health data including case counts, incidence rates, and covariates. The available plot types include time series, heatmaps, seasonality plots, maps and more. The package supports standard data transformations such as temporal and spatial aggregations, while offering extensive customization options for the resulting figures.\n\n\n\nMaintainer : Carles Mil√† carles.milagarcia@bsc.es (ORCID)\nAuthors:\n\nGiovenale Moirano (ORCID)\nAnna B. Kawiecki (ORCID)\nRachel Lowe (ORCID) [copyright holder]\n\n\n\n\nUseful links:\n\nhttps://earth.bsc.es/gitlab/ghr/ghrexplore\nReport bugs at https://earth.bsc.es/gitlab/ghr/ghrexplore/-/issues"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/GHRexplore-package.Rd.html#description",
    "href": "docs/GHRexplore/GHRexplore-reference/GHRexplore-package.Rd.html#description",
    "title": "GHRexplore: Exploratory Analysis of Temporal and Spatio-Temporal Health Data",
    "section": "",
    "text": "A collection of commonly used visualizations of temporal and spatio-temporal health data including case counts, incidence rates, and covariates. The available plot types include time series, heatmaps, seasonality plots, maps and more. The package supports standard data transformations such as temporal and spatial aggregations, while offering extensive customization options for the resulting figures."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/GHRexplore-package.Rd.html#authors",
    "href": "docs/GHRexplore/GHRexplore-reference/GHRexplore-package.Rd.html#authors",
    "title": "GHRexplore: Exploratory Analysis of Temporal and Spatio-Temporal Health Data",
    "section": "",
    "text": "Maintainer : Carles Mil√† carles.milagarcia@bsc.es (ORCID)\nAuthors:\n\nGiovenale Moirano (ORCID)\nAnna B. Kawiecki (ORCID)\nRachel Lowe (ORCID) [copyright holder]"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/GHRexplore-package.Rd.html#see-also",
    "href": "docs/GHRexplore/GHRexplore-reference/GHRexplore-package.Rd.html#see-also",
    "title": "GHRexplore: Exploratory Analysis of Temporal and Spatio-Temporal Health Data",
    "section": "",
    "text": "Useful links:\n\nhttps://earth.bsc.es/gitlab/ghr/ghrexplore\nReport bugs at https://earth.bsc.es/gitlab/ghr/ghrexplore/-/issues"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_correlation.Rd.html",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_correlation.Rd.html",
    "title": "Correlation plot",
    "section": "",
    "text": "Plots a correlation matrix of a series of variables.\nplot_correlation(\n  data,\n  var,\n  var_label = NULL,\n  method = \"pearson\",\n  plot_type = c(\"circle\", \"number\"),\n  scale = 1,\n  title = NULL,\n  palette = \"IDE1\",\n  print = FALSE\n)\n\n\n\n\ndata: Data frame containing equally spaced (daily, weekly, monthly) covariate or disease case observations for one or multiple locations.\nvar: Character vector containing variables in data to include in the correlation matrix.\nvar_label: Optional character vector of the same length as var containing custom names for the variables.\nmethod: Correlation computation method. Options include ‚Äúpearson‚Äù (default), ‚Äúspearman‚Äù or ‚Äúkendall‚Äù.\nplot_type: Character vector of length 2 indicating the type of plot to use in the lower triangular and diagonal (1st element) and the upper triangular (2nd element). Options include ‚Äúcircle‚Äù, ‚Äúnumber‚Äù and ‚Äúraster‚Äù.\nscale: Circle and number size multiplier, e.g.¬†1.1 increases the size a 10% while 0.9 decreases it a 10%.\ntitle: Optional title of the plot.\npalette: GHR, RColorBrewer or colorspace palette. Use ‚Äú-‚Äù before the palette name (e.g., ‚Äú-Reds‚Äù) to reverse it.\nprint: Logical. If TRUE, print the correlation matrix.\n\n\n\n\nA plot of the correlation matrix.\n\n\n\n# Load data\ndata(\"dengue_MS\")\n\n# Pearson correlation plot\nplot_correlation(dengue_MS, \n                 method = \"pearson\",\n                 var = c(\"dengue_cases\",\"pop_density\", \n                         \"tmax\", \"tmin\", \"pdsi\", \"urban\",\n                         \"water_network\", \"water_shortage\"),  \n                 var_label = c(\"dengue cases\",\"pop. density\", \n                               \"max temp\", \"min temp\", \"drought index\", \"urbanization\",\n                               \"water network\", \"water shortage\"),\n                 title = \"Correlation matrix\") \n\n# Print spearman correlation plot of type 'raster' and 'number' \n# with another palette \nplot_correlation(dengue_MS,\n                 method = \"spearman\",\n                 var = c(\"dengue_cases\",\"pop_density\", \n                         \"tmax\", \"tmin\", \"pdsi\", \"urban\",\n                         \"water_network\", \"water_shortage\"),  \n                 var_label = c(\"dengue cases\",\"pop. density\", \n                               \"max temp\", \"min temp\", \"drought index\", \"urbanization\",\n                               \"water network\", \"water shortage\"),\n                 plot_type = c(\"raster\", \"number\"),\n                 palette = \"-Blue-Red 3\")"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_correlation.Rd.html#description",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_correlation.Rd.html#description",
    "title": "Correlation plot",
    "section": "",
    "text": "Plots a correlation matrix of a series of variables.\nplot_correlation(\n  data,\n  var,\n  var_label = NULL,\n  method = \"pearson\",\n  plot_type = c(\"circle\", \"number\"),\n  scale = 1,\n  title = NULL,\n  palette = \"IDE1\",\n  print = FALSE\n)"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_correlation.Rd.html#arguments",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_correlation.Rd.html#arguments",
    "title": "Correlation plot",
    "section": "",
    "text": "data: Data frame containing equally spaced (daily, weekly, monthly) covariate or disease case observations for one or multiple locations.\nvar: Character vector containing variables in data to include in the correlation matrix.\nvar_label: Optional character vector of the same length as var containing custom names for the variables.\nmethod: Correlation computation method. Options include ‚Äúpearson‚Äù (default), ‚Äúspearman‚Äù or ‚Äúkendall‚Äù.\nplot_type: Character vector of length 2 indicating the type of plot to use in the lower triangular and diagonal (1st element) and the upper triangular (2nd element). Options include ‚Äúcircle‚Äù, ‚Äúnumber‚Äù and ‚Äúraster‚Äù.\nscale: Circle and number size multiplier, e.g.¬†1.1 increases the size a 10% while 0.9 decreases it a 10%.\ntitle: Optional title of the plot.\npalette: GHR, RColorBrewer or colorspace palette. Use ‚Äú-‚Äù before the palette name (e.g., ‚Äú-Reds‚Äù) to reverse it.\nprint: Logical. If TRUE, print the correlation matrix."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_correlation.Rd.html#returns",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_correlation.Rd.html#returns",
    "title": "Correlation plot",
    "section": "",
    "text": "A plot of the correlation matrix."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_correlation.Rd.html#examples",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_correlation.Rd.html#examples",
    "title": "Correlation plot",
    "section": "",
    "text": "# Load data\ndata(\"dengue_MS\")\n\n# Pearson correlation plot\nplot_correlation(dengue_MS, \n                 method = \"pearson\",\n                 var = c(\"dengue_cases\",\"pop_density\", \n                         \"tmax\", \"tmin\", \"pdsi\", \"urban\",\n                         \"water_network\", \"water_shortage\"),  \n                 var_label = c(\"dengue cases\",\"pop. density\", \n                               \"max temp\", \"min temp\", \"drought index\", \"urbanization\",\n                               \"water network\", \"water shortage\"),\n                 title = \"Correlation matrix\") \n\n# Print spearman correlation plot of type 'raster' and 'number' \n# with another palette \nplot_correlation(dengue_MS,\n                 method = \"spearman\",\n                 var = c(\"dengue_cases\",\"pop_density\", \n                         \"tmax\", \"tmin\", \"pdsi\", \"urban\",\n                         \"water_network\", \"water_shortage\"),  \n                 var_label = c(\"dengue cases\",\"pop. density\", \n                               \"max temp\", \"min temp\", \"drought index\", \"urbanization\",\n                               \"water network\", \"water shortage\"),\n                 plot_type = c(\"raster\", \"number\"),\n                 palette = \"-Blue-Red 3\")"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_multiple.Rd.html",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_multiple.Rd.html",
    "title": "Multiple plot",
    "section": "",
    "text": "Produces a list of multiple plots of the same type, each representing one variable.\nplot_multiple(plot_function, ...)\n\n\n\n\nplot_function: Indicates which of the plot types to use. Options are: ‚Äòplot_timeseries‚Äô, ‚Äòplot_heatmap‚Äô, ‚Äòplot_seasonality‚Äô, and ‚Äòplot_map‚Äô.\n...: Additional arguments to pass to the plotting function.\n\n\n\n\nVariable names, types, labels and palette can be customized for each plot, the rest of parameters will be the same for all variables (options depend on the chosen plot type).\n\n\n\nA list of the different generated plots.\n\n\n\nplot_compare, plot_combine\n\n\n\n# Load data\nlibrary(\"sf\")\ndata(\"dengue_MS\")\ndata(\"map_MS\")\n\nplots &lt;- plot_multiple(\n  plot_function = plot_timeseries,\n  data = dengue_MS,\n  var = c(\"dengue_cases\", \"dengue_cases\", \"tmax\"),\n  type = c(\"counts\", \"inc\", \"cov\"),\n  pop = \"population\",\n  var_label = c(\"Dengue Cases\", \"Dengue inc\", \"Max Temp\"),\n  palette = c(\"blue\", \"red\", \"darkgreen\"),\n  time = \"date\",\n  area = \"micro_code\",\n  facet = TRUE)\n\n# Acess individual plots\nprint(plots[[1]])  \n\n# Multiple heatmap plots\nplots &lt;- plot_multiple(\n  plot_function = plot_heatmap,\n  data = dengue_MS,\n  var = c(\"dengue_cases\", \"dengue_cases\", \"tmax\"),\n  type = c(\"counts\", \"inc\", \"cov\"),\n  pop = \"population\",\n  var_label = c(\"Dengue Cases\", \"Dengue inc\", \"Max Temp\"),\n  palette = c(\"Blues\", \"Reds\", \"BrBG\"),\n  time = \"date\",\n  area = \"micro_code\")\n\n# Multiple seasonality plots\nplots &lt;- plot_multiple(\n  plot_function = plot_seasonality,\n  data = dengue_MS,\n  var = c(\"dengue_cases\", \"dengue_cases\", \"tmax\"),\n  type = c(\"counts\", \"inc\", \"cov\"),\n  pop = \"population\",\n  var_label = c(\"Dengue Cases\", \"Dengue inc\", \"Max Temp\"),\n  palette =  c(\"Blues\", \"Reds\", \"BrBG\"),\n  time = \"date\",\n  area = \"micro_code\")\n\n# Multiple map plots\nplots &lt;- plot_multiple(\n  plot_function = plot_map, \n  data = dengue_MS,\n  var = c(\"dengue_cases\", \"dengue_cases\", \"tmax\"),\n  type = c(\"counts\", \"inc\", \"cov\"),\n  pop = \"population\",\n  var_label = c(\"Dengue Cases\", \"Dengue inc\", \"Max Temp\"),\n  palette = c(\"Reds\", \"Blues\", \"Viridis\"),\n  map = map_MS,         \n  map_area = \"code\",    \n  time = \"date\",\n  area = \"micro_code\")"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_multiple.Rd.html#description",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_multiple.Rd.html#description",
    "title": "Multiple plot",
    "section": "",
    "text": "Produces a list of multiple plots of the same type, each representing one variable.\nplot_multiple(plot_function, ...)"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_multiple.Rd.html#arguments",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_multiple.Rd.html#arguments",
    "title": "Multiple plot",
    "section": "",
    "text": "plot_function: Indicates which of the plot types to use. Options are: ‚Äòplot_timeseries‚Äô, ‚Äòplot_heatmap‚Äô, ‚Äòplot_seasonality‚Äô, and ‚Äòplot_map‚Äô.\n...: Additional arguments to pass to the plotting function."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_multiple.Rd.html#details",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_multiple.Rd.html#details",
    "title": "Multiple plot",
    "section": "",
    "text": "Variable names, types, labels and palette can be customized for each plot, the rest of parameters will be the same for all variables (options depend on the chosen plot type)."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_multiple.Rd.html#returns",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_multiple.Rd.html#returns",
    "title": "Multiple plot",
    "section": "",
    "text": "A list of the different generated plots."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_multiple.Rd.html#see-also",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_multiple.Rd.html#see-also",
    "title": "Multiple plot",
    "section": "",
    "text": "plot_compare, plot_combine"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_multiple.Rd.html#examples",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_multiple.Rd.html#examples",
    "title": "Multiple plot",
    "section": "",
    "text": "# Load data\nlibrary(\"sf\")\ndata(\"dengue_MS\")\ndata(\"map_MS\")\n\nplots &lt;- plot_multiple(\n  plot_function = plot_timeseries,\n  data = dengue_MS,\n  var = c(\"dengue_cases\", \"dengue_cases\", \"tmax\"),\n  type = c(\"counts\", \"inc\", \"cov\"),\n  pop = \"population\",\n  var_label = c(\"Dengue Cases\", \"Dengue inc\", \"Max Temp\"),\n  palette = c(\"blue\", \"red\", \"darkgreen\"),\n  time = \"date\",\n  area = \"micro_code\",\n  facet = TRUE)\n\n# Acess individual plots\nprint(plots[[1]])  \n\n# Multiple heatmap plots\nplots &lt;- plot_multiple(\n  plot_function = plot_heatmap,\n  data = dengue_MS,\n  var = c(\"dengue_cases\", \"dengue_cases\", \"tmax\"),\n  type = c(\"counts\", \"inc\", \"cov\"),\n  pop = \"population\",\n  var_label = c(\"Dengue Cases\", \"Dengue inc\", \"Max Temp\"),\n  palette = c(\"Blues\", \"Reds\", \"BrBG\"),\n  time = \"date\",\n  area = \"micro_code\")\n\n# Multiple seasonality plots\nplots &lt;- plot_multiple(\n  plot_function = plot_seasonality,\n  data = dengue_MS,\n  var = c(\"dengue_cases\", \"dengue_cases\", \"tmax\"),\n  type = c(\"counts\", \"inc\", \"cov\"),\n  pop = \"population\",\n  var_label = c(\"Dengue Cases\", \"Dengue inc\", \"Max Temp\"),\n  palette =  c(\"Blues\", \"Reds\", \"BrBG\"),\n  time = \"date\",\n  area = \"micro_code\")\n\n# Multiple map plots\nplots &lt;- plot_multiple(\n  plot_function = plot_map, \n  data = dengue_MS,\n  var = c(\"dengue_cases\", \"dengue_cases\", \"tmax\"),\n  type = c(\"counts\", \"inc\", \"cov\"),\n  pop = \"population\",\n  var_label = c(\"Dengue Cases\", \"Dengue inc\", \"Max Temp\"),\n  palette = c(\"Reds\", \"Blues\", \"Viridis\"),\n  map = map_MS,         \n  map_area = \"code\",    \n  time = \"date\",\n  area = \"micro_code\")"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore.html#overview",
    "href": "docs/GHRexplore/GHRexplore.html#overview",
    "title": "GHRexplore",
    "section": "Overview",
    "text": "Overview\n\n\nGHRexplore is an R package for exploratory analysis of temporal and spatio-temporal health data including case counts, incidence rates, and covariates. It provides commonly used visualizations and supports standard data transformations such as temporal and spatial aggregations. The package also offers extensive customization options for the resulting figures. Currently available plotting functions include:\n\n\n\n\n\n\n\nplot_timeseries: Plots time series of covariates, case counts or incidence rates.\nplot_heatmap: Plots a time series of covariates, case counts or incidence rates as heatmaps.\nplot_seasonality: Plots yearly time series to detect seasonal patterns of covariates, case counts or incidence rates.\nplot_correlation: Plots a correlation matrix of a series of variables.\nplot_map: Plots a choropleth map of covariates, case counts or incidence rates.\nplot_bivariate: Plots a bivariate plot of two numerical and/or categorical variables.\nplot_multiple, plot_combine and plot_compare: Used to generate graphs of several variables at the same time.\n\nGHRexplore is one of the packages developed by the Global Health Resilience (GHR) team at the Barcelona Supercomputing Center (BSC) within the IDExtremes project. The development version of the package can be found on gitlab."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore.html#installation",
    "href": "docs/GHRexplore/GHRexplore.html#installation",
    "title": "GHRexplore",
    "section": "Installation",
    "text": "Installation\n# Install from CRAN\ninstall.packages(\"GHRexplore\")\n\n# Get the development version from Gitlab\ndevtools::install_git('https://earth.bsc.es/gitlab/ghr/ghrexplore.git')"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore.html#usage",
    "href": "docs/GHRexplore/GHRexplore.html#usage",
    "title": "GHRexplore",
    "section": "Usage",
    "text": "Usage\nlibrary(\"GHRexplore\")\n\n# Use data included in the package to plot a heatmap with spatial aggregation\ndata(\"dengue_MS\")\nplot_heatmap(data = dengue_MS,\n             var = \"dengue_cases\",\n             type = \"inc\",\n             pop = \"population\",\n             time = \"date\",          \n             area = \"micro_code\",   \n             aggregate_space = \"meso_code\",\n             transform = \"log10p1\",\n             title = \"Dengue incidence in Brazil\")"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore.html#developers",
    "href": "docs/GHRexplore/GHRexplore.html#developers",
    "title": "GHRexplore",
    "section": "Developers",
    "text": "Developers\nGiovenale Moirano, PhD \nBarcelona Supercomputing Center\nGlobal Health Resilience\nCarles Mil√†, PhD \nBarcelona Supercomputing Center\nGlobal Health Resilience\nAnna B. Kawiecki, PhD \nBarcelona Supercomputing Center\nGlobal Health Resilience\nRachel Lowe, PhD \nBarcelona Supercomputing Center\nGlobal Health Resilience (Group leader)"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-news.html#section",
    "href": "docs/GHRexplore/GHRexplore-news.html#section",
    "title": "GHRexplore changelog",
    "section": "0.2.0",
    "text": "0.2.0\n\nNew plotting function: plot_timeseries2() for dual-axis time series plots.\nIncreased flexibility of plot_map() (line colour, width, alpha).\nby_year argument deprecated in plot_map() and substituted by aggregate_time."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-news.html#section-1",
    "href": "docs/GHRexplore/GHRexplore-news.html#section-1",
    "title": "GHRexplore changelog",
    "section": "0.1.1",
    "text": "0.1.1\n\nFixed tests failing with cowplot 1.2.0.\nFixed minor bug in plot_map()."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-news.html#section-2",
    "href": "docs/GHRexplore/GHRexplore-news.html#section-2",
    "title": "GHRexplore changelog",
    "section": "0.1.0",
    "text": "0.1.0\n\nInitial CRAN submission."
  },
  {
    "objectID": "docs/clim4health/clim4health.html#overview",
    "href": "docs/clim4health/clim4health.html#overview",
    "title": "clim4health",
    "section": "Overview",
    "text": "Overview\n\n\nclim4health is an R package designed to obtain, transform and export climate data for their use in epidemiological analyses and other types of applications. The package contains a series of functions structured in three sequential blocks: input, transformation, and output.\nIn the input block, clim4health provides functions to download several types of climate data including reanalyses, forecasts, hindcasts, and weather stations and load them into memory for their processing. The transformation block includes functions to postprocess and downscale climate data, perform spatiotemporal aggregations, as well as compute threshold-based suitability indicators. Finally, in the output block, functions to visualize and export the transformed data are provided.\n\n\n\n\n\n\n\n\n\n\n\n\nclim4health is one of the packages developed by the Global Health Resilience (GHR) team at the Barcelona Supercomputing Center (BSC) within the HARMONIZE project, which comprises different R and Python libraries tailored for health, climate, environmental, and socioeconomic data acquisition, harmonisation, and visualization.\nThe package is currently under development and its expected release date is February 2026."
  },
  {
    "objectID": "docs/clim4health/clim4health.html#developers",
    "href": "docs/clim4health/clim4health.html#developers",
    "title": "clim4health",
    "section": "Developers",
    "text": "Developers\nEmily Ball, PhD \nBarcelona Supercomputing Center\nClimate Services\nAlba Llabr√©s, PhD \nBarcelona Supercomputing Center\nClimate Services\nCarles Mil√†, PhD \nBarcelona Supercomputing Center\nGlobal Health Resilience\nRaul Capellan Fernandez, MSc\nBarcelona Supercomputing Center\nEarth Data and Diagnostics\nDaniela L√ºhrsen, MSc \nBarcelona Supercomputing Center\nGlobal Health Resilience\nAnna B. Kawiecki, PhD \nBarcelona Supercomputing Center\nGlobal Health Resilience\nRachel Lowe, PhD \nBarcelona Supercomputing Center\nGlobal Health Resilience (Group leader)"
  },
  {
    "objectID": "index.html#from-health-and-climate-data-to-disease-forecasts",
    "href": "index.html#from-health-and-climate-data-to-disease-forecasts",
    "title": "GHRtools",
    "section": "From health and climate data to disease forecasts",
    "text": "From health and climate data to disease forecasts\nGHRtools is a suite of R packages that support climate and health workflows by streamlining health and climate data collection and harmonization, exploratory analysis, Bayesian modelling and forecasting."
  },
  {
    "objectID": "index.html#our-tools",
    "href": "index.html#our-tools",
    "title": "GHRtools",
    "section": "Our tools",
    "text": "Our tools\n \n\n\n\n\n\n\n\n\n\n\n\n    data4health  \n  \n    \n        \n   Access, preprocess and aggregate health data at customized spatiotemporal resolutions.\n   Use a set of functions to streamline health data pipelines or leverage a user-friendly graphical interface provided as a Shiny app within the package.\n    \n    \n  \n\n\n\n  \n\n\n\n\n    clim4health  \n  \n     \n    \n  Obtain, transform and export climate data including reanalyses, forecasts, hindcasts, and weather stations.\n  Apply common transformations of climate data including postprocessing, downscaling, spatiotemporal aggregations, and construct threshold-based vector suitability indicators.\n    \n  \n  \n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n    GHRexplore  \n  \n         \n    \n   Perform exploratory analysis of temporal and spatiotemporal health data including case counts, incidence rates, and covariates.\n   Produce high-quality time series, heatmaps, seasonality, bivariate and correlation plots, as well as choropleth maps, with many customization options.\n    \n  \n  \n\n\n\n  \n\n\n\n\n    GHRmodel  \n  \n         \n    \n   A modular and flexible approach to modeling health outcomes using INLA. \n   It addresses common challenges when fitting INLA models, including covariate transformations, formula definitions with complex covariate effects, model fitting, diagnostic plots and model statistics.\n\n    \n  \n  \n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n    GHRpredict  \n  \n         \n    \n   Generate predictions of models fitted with GHRmodel.\n   Evaluate the quality of your predictions using out-of-sample statistics, graphical diagnostics and outbreak detection capabilities using cross-validation"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-vignette.html#data-requirements",
    "href": "docs/GHRexplore/GHRexplore-vignette.html#data-requirements",
    "title": "Introduction to GHRexplore",
    "section": "Data requirements",
    "text": "Data requirements\nThe data must be a long-format data frame containing a regularly spaced time series (e.g., daily, weekly, monthly) of a single or several spatial units. In this data frame, the time and optional space identifiers must be included as columns.\nAs an example, we can have a look at the dengue_MS dataset included in the package, which includes data on dengue cases from the Mato Grosso do Sul state in Brazil as well as a set of relevant covariates.\ndata(\"dengue_MS\")\nglimpse(dengue_MS)\n#&gt; Rows: 2,640\n#&gt; Columns: 27\n#&gt; $ micro_code      &lt;dbl&gt; 50001, 50002, 50003, 50004, 50005, 50006, 50007, 50008, 50009, 50010, 50011, 50001, 50002, 50003, 50004, ‚Ä¶\n#&gt; $ micro_name      &lt;chr&gt; \"Baixo Pantanal\", \"Aquidauana\", \"Alto Taquari\", \"Campo Grande\", \"Cassil√¢ndia\", \"Parana√≠ba\", \"Tr√™s Lagoas\"‚Ä¶\n#&gt; $ micro_name_ibge &lt;chr&gt; \"BAIXO PANTANAL\", \"AQUIDAUANA\", \"ALTO TAQUARI\", \"CAMPO GRANDE\", \"CASSIL√ÇNDIA\", \"PARANA√çBA\", \"TR√äS LAGOAS\"‚Ä¶\n#&gt; $ meso_code       &lt;dbl&gt; 5001, 5001, 5002, 5002, 5003, 5003, 5003, 5003, 5004, 5004, 5004, 5001, 5001, 5002, 5002, 5003, 5003, 500‚Ä¶\n#&gt; $ meso_name       &lt;chr&gt; \"Pantanais Sul Mato-Grossense\", \"Pantanais Sul Mato-Grossense\", \"Centro Norte De Mato Grosso Do Sul\", \"Ce‚Ä¶\n#&gt; $ state_code      &lt;dbl&gt; 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 5‚Ä¶\n#&gt; $ state_name      &lt;chr&gt; \"Mato Grosso Do Sul\", \"Mato Grosso Do Sul\", \"Mato Grosso Do Sul\", \"Mato Grosso Do Sul\", \"Mato Grosso Do S‚Ä¶\n#&gt; $ region_code     &lt;dbl&gt; 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, ‚Ä¶\n#&gt; $ region_name     &lt;chr&gt; \"Centre-West\", \"Centre-West\", \"Centre-West\", \"Centre-West\", \"Centre-West\", \"Centre-West\", \"Centre-West\", ‚Ä¶\n#&gt; $ biome_code      &lt;dbl&gt; 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 6, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 6, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 6, 3, 3, ‚Ä¶\n#&gt; $ biome_name      &lt;chr&gt; \"Pantanal\", \"Pantanal\", \"Cerrado\", \"Cerrado\", \"Cerrado\", \"Cerrado\", \"Cerrado\", \"Cerrado\", \"Cerrado\", \"Cer‚Ä¶\n#&gt; $ ecozone_code    &lt;dbl&gt; 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 8, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 8, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 8, 3, 3, ‚Ä¶\n#&gt; $ ecozone_name    &lt;chr&gt; \"Pantanal\", \"Pantanal\", \"Cerrado\", \"Cerrado\", \"Cerrado\", \"Cerrado\", \"Cerrado\", \"Cerrado\", \"Cerrado\", \"Cer‚Ä¶\n#&gt; $ main_climate    &lt;chr&gt; \"AW\", \"AM\", \"AW\", \"AM\", \"AM\", \"AW\", \"AM\", \"AW\", \"AF\", \"CFA\", \"CFA\", \"AW\", \"AM\", \"AW\", \"AM\", \"AM\", \"AW\", \"‚Ä¶\n#&gt; $ month           &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, ‚Ä¶\n#&gt; $ year            &lt;dbl&gt; 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 200‚Ä¶\n#&gt; $ time            &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, ‚Ä¶\n#&gt; $ dengue_cases    &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N‚Ä¶\n#&gt; $ population      &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N‚Ä¶\n#&gt; $ pop_density     &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N‚Ä¶\n#&gt; $ tmax            &lt;dbl&gt; 34.28429, 33.15394, 32.31370, 31.23787, 31.19907, 32.12062, 31.67418, 31.42584, 33.35522, 31.53561, 31.59‚Ä¶\n#&gt; $ tmin            &lt;dbl&gt; 24.00583, 23.43257, 22.61425, 21.82709, 21.29000, 21.85358, 22.03971, 21.71142, 23.22608, 21.63477, 21.51‚Ä¶\n#&gt; $ pdsi            &lt;dbl&gt; -1.2329962, -1.8564967, -0.7201829, -2.3979688, -0.2056521, -1.5016941, -2.4826837, -3.2662439, -3.053628‚Ä¶\n#&gt; $ urban           &lt;dbl&gt; 88.31, 72.36, 84.51, 94.71, 87.29, 85.58, 84.16, 78.50, 78.59, 81.81, 73.65, 88.31, 72.36, 84.51, 94.71, ‚Ä¶\n#&gt; $ water_network   &lt;dbl&gt; 88.78, 79.59, 84.29, 88.13, 86.48, 65.80, 83.69, 81.68, 80.51, 77.45, 76.66, 88.78, 79.59, 84.29, 88.13, ‚Ä¶\n#&gt; $ water_shortage  &lt;dbl&gt; 0.0000, 0.1528, 0.0437, 0.1855, 0.3201, 0.1921, 0.0524, 0.2444, 0.1247, 0.2095, 0.1419, 0.0000, 0.1528, 0‚Ä¶\n#&gt; $ date            &lt;date&gt; 2000-01-01, 2000-01-01, 2000-01-01, 2000-01-01, 2000-01-01, 2000-01-01, 2000-01-01, 2000-01-01, 2000-01-‚Ä¶\nIn this data frame, the date column contains the temporal identifier (in this case, we have monthly data where the variable date represents the first day of the month) and the spatial unit identifier is micro_code.\nSince we have data for several spatial units, it is useful to have the polygon geometries of the areas (e.g., a geopackage, shapefile o geojson file), loaded as an sf object, in order to plot cartographic representations. The sf object must also contain the area unit identifier to be able to link the geometries with the data frame.\nFor the dengue_MS, the geometries are already included in the package in the map_MS object:\ndata(\"map_MS\")\nglimpse(map_MS)\n#&gt; Rows: 11\n#&gt; Columns: 2\n#&gt; $ code     &lt;dbl&gt; 50001, 50002, 50003, 50004, 50005, 50006, 50007, 50008, 50009, 50010, 50011\n#&gt; $ geometry &lt;MULTIPOLYGON [¬∞]&gt; MULTIPOLYGON (((-55.60618 -..., MULTIPOLYGON (((-55.39862 -..., MULTIPOLYGON (((-53.68353 -..., MULTIPOLYGON (((‚Ä¶\nIn map_MS, the code variable corresponds to the micro_code area identifier in the dengue_MS object.\n\nüí° Tip: If you don‚Äôt have geometries for your data, a good place to look for them is GADM, natural earth, or GeoBoundaries."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-vignette.html#covariates-case-counts-and-incidence-rates",
    "href": "docs/GHRexplore/GHRexplore-vignette.html#covariates-case-counts-and-incidence-rates",
    "title": "Introduction to GHRexplore",
    "section": "Covariates, case counts, and incidence rates",
    "text": "Covariates, case counts, and incidence rates\nIn all GHRexplore functions, the column name of the variable to be plotted needs to be specified with the var argument. Plotting functions behave differently depending on the type of data being plotted as defined by the type argument: covariates (type='cov'), case counts (type='counts'), and incidence rates (type='inc'). Several examples for each type are provided in the following sections.\nTo plot incidence rates, the column with the disease counts must be used as var and the population must be also supplied as the pop argument. By default, rates are computed per 100,000 persons, but this number can be changed using the pt argument."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-vignette.html#spatial-and-temporal-aggregations",
    "href": "docs/GHRexplore/GHRexplore-vignette.html#spatial-and-temporal-aggregations",
    "title": "Introduction to GHRexplore",
    "section": "Spatial and temporal aggregations",
    "text": "Spatial and temporal aggregations\nMost GHRexplore functions support temporal and spatial aggregations from finer to coarser resolution. For example, you can aggregate daily to weekly data, or aggregate small regions to larger regions.\nTemporal and spatial aggregations are performed using the arguments aggregate_time and aggregate_space, respectively. For covariates (type='cov'), the aggregation function can be specified using aggregate_space_fun and aggregate_time_fun (options include mean (default), median, and sum). For case counts and incidence, the aggregation function is fixed to be the sum of cases."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-vignette.html#color-palettes",
    "href": "docs/GHRexplore/GHRexplore-vignette.html#color-palettes",
    "title": "Introduction to GHRexplore",
    "section": "Color palettes",
    "text": "Color palettes\nIn GHRexplore, color is controlled by the palette argument. We included a few in-house palettes that are used as defaults depending on the plot type:\nGHR_palettes()\n\nIn addition to these, all color palettes included in the packages RColorBrewer and colorspace can also be used. All available options can be checked by running RColorBrewer::display.brewer.all() and colorspace::hcl_palettes(plot=TRUE).\nAs a few examples, the ‚ÄòBlues‚Äô palette can be useful when plotting precipitation-related variables, ‚ÄòGreens‚Äô when plotting vegetation-related variables, or ‚ÄòBlue-Red‚Äô when displaying temperature. When a single color is needed, a color in colors() or a hex code can also be specified. In addition, the user can provide custom palettes using a vector of hex codes to the palette argument.\n\nüí° Tip: Palettes can be reversed by preceding them with a minus sign, e.g.¬†‚Äò-IDE1‚Äô."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-vignette.html#time-series",
    "href": "docs/GHRexplore/GHRexplore-vignette.html#time-series",
    "title": "Introduction to GHRexplore",
    "section": "Time series",
    "text": "Time series\nplot_timeseries produces time series plots of covariates, case counts, or incidence rates. It allows for spatial and temporal aggregations, plotting single or multiple time series of different areas simultaneously (using facets or colors), y-axis transformations, and axis and title labeling.\nWe start by plotting the time series data for minimum temperature (note type=\"cov\") for all the 11 areas in dengue_MS:\nplot_timeseries(dengue_MS, var = \"tmin\", type = \"cov\", \n                var_label = \"Minimum temp.\",\n                time = \"date\", area = \"micro_code\")\n\nSince 11 areas are quite a lot for a single graph, we can use facet = TRUE to display them in different panels:\nplot_timeseries(dengue_MS, var = \"tmin\", type = \"cov\", var_label = \"Minimum temp.\",\n                time = \"date\", area = \"micro_code\", facet = TRUE)\n\nAnother possible strategy is to keep the 11 areas, but highlight the one we are interested in using the highlight argument by setting it to the area identifier we want to highlight:\nplot_timeseries(dengue_MS, var = \"tmin\", type = \"cov\", var_label = \"Minimum temp.\",\n                time = \"date\", area = \"micro_code\", highlight = \"50001\",\n                title = \"Micro code 50001\")\n\nAs an alternative option, we could also aggregate to a coarser spatial unit by using an aggregation function. Here, we aggregate to meso areas using the aggregate_space argument. Since type=\"cov\", it will aggregate temperatures using the mean as a default.\nplot_timeseries(dengue_MS, var = \"tmin\", type = \"cov\", var_label = \"Minimum temp.\",\n                time = \"date\", area = \"micro_code\", aggregate_space = \"meso_code\")\n\nAfter temperature, we move on to plotting dengue counts (note type=\"counts\") aggregating to meso areas using aggregate_space, which applies a sum function by default when type=\"counts\". Given the right-skewed distribution of the counts, we scale the y axis using a log10(x+1) transformation:\nplot_timeseries(dengue_MS, var = \"dengue_cases\", type = \"counts\",\n                time = \"date\", area = \"micro_code\", aggregate_space = \"meso_code\",\n                transform = \"log10p1\")\n\nIn a similar fashion, we can also plot incidence rates (note type=\"inc\" and the defined pop argument) aggregating to meso areas using aggregate_space, which for type=\"inc\" it first sums the cases per area, and then computes the incidence rates. We set the scale of the incidence rate (pt argument) to 1,000 persons, and scale the y axis using a log10(x+1) transformation:\nplot_timeseries(dengue_MS, var = \"dengue_cases\", type = \"inc\", pop = \"population\",\n                time = \"date\", area = \"micro_code\", aggregate_space = \"meso_code\",\n                pt = 1000, transform = \"log10p1\")"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-vignette.html#dual-axis-time-series",
    "href": "docs/GHRexplore/GHRexplore-vignette.html#dual-axis-time-series",
    "title": "Introduction to GHRexplore",
    "section": "Dual-axis time series",
    "text": "Dual-axis time series\nplot_timeseries2 produces two-axis time series plots of covariates, case counts, or incidence rates. Similarly to plot_timeseries, it allows for spatial and temporal aggregations, plotting single or multiple time series of different areas simultaneously using facets, and axis and title labeling. The main difference between the two time series functions is that, in plot_timeseries2 the arguments var, type and optionally var_label and ylab need to be of length 2, corresponding to the left and right axes respectively.\nWe start by plotting the time series data for two covariates (note type=c(\"cov\", \"cov\")): maximum temperature and PDSI. We choose to align the two axis by forcing the mean of the two variables to be aligned:\nplot_timeseries2(dengue_MS,\n                 var = c(\"tmax\", \"pdsi\"),\n                 type = c(\"cov\", \"cov\"),\n                 time = \"date\", \n                 area = \"micro_code\",\n                 align = \"mean\")\n\nWe now improve on this by performing spatial aggregation into larger meso areas and specifying custom colours and labels:\nplot_timeseries2(dengue_MS,\n                 var = c(\"tmax\", \"pdsi\"),\n                 type = c(\"cov\", \"cov\"),\n                 time = \"date\", \n                 area = \"micro_code\",\n                 aggregate_space = \"meso_code\",\n                 palette = c(\"tomato\", \"royalblue\"),\n                 var_label = c(\"Maximum temp.\", \"PDSI\"),\n                 align = \"mean\")\n\nOne of the most interesting applications of plot_timeseries2 is to visualize in the same graph disease cases and a candidate predictor. We do that in the following example, where we visualize dengue incidence and maximum temperature (note type=c(\"inc\", \"cov\") and the pop argument):\nplot_timeseries2(dengue_MS,\n                 var = c(\"dengue_cases\", \"pdsi\"),\n                 type = c(\"inc\", \"cov\"),\n                 pop = \"population\", \n                 time = \"date\", \n                 area = \"micro_code\",\n                 aggregate_space = \"meso_code\")\n\nSimilarly, we can visualize case counts together with a covariate (note type=c(\"counts\", \"cov\")).\nplot_timeseries2(dengue_MS,\n                 var = c(\"dengue_cases\", \"pdsi\"),\n                 type = c(\"counts\", \"cov\"),\n                 time = \"date\", \n                 area = \"micro_code\",\n                 aggregate_space = \"meso_code\")"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-vignette.html#heatmap",
    "href": "docs/GHRexplore/GHRexplore-vignette.html#heatmap",
    "title": "Introduction to GHRexplore",
    "section": "Heatmap",
    "text": "Heatmap\nplot_heatmap plots time series heatmaps of covariates, case counts, or incidence rates. Years are displayed on the y axis and weeks or months on the x axis. The function allows for spatial and temporal aggregations, plotting single or multiple time series for different areas simultaneously (using facets), color transformations, and axis and title labeling.\nIn this first example, we plot the variable (note type=\"cov\") PDSI (Palmer Drought Severity Index) aggregated at the meso code level. We use a suitable palette for drought and we center it at zero:\nplot_heatmap(dengue_MS, var = \"pdsi\", type = \"cov\", var_label = \"PDSI\",\n             time = \"date\", area = \"micro_code\",\n             aggregate_space = \"meso_code\", palette = \"-Vik\", centering = 0) \n\nIn this second example, we plot dengue incidence rates (note type=\"inc\" and pop arguments) at the meso code level and apply a transformation to the color gradient to have a better contrast.\nplot_heatmap(dengue_MS, var = \"dengue_cases\", type = \"inc\", pop = \"population\",\n             time = \"date\", area = \"micro_code\", aggregate_space = \"meso_code\",\n             title= \"Monthly Incidence\", transform = \"log10p1\")"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-vignette.html#seasonality",
    "href": "docs/GHRexplore/GHRexplore-vignette.html#seasonality",
    "title": "Introduction to GHRexplore",
    "section": "Seasonality",
    "text": "Seasonality\nplot_seasonality produces yearly time series of covariates, case counts, or incidence rates to explore seasonality patterns. Months/weeks are shown on the x axis, the magnitude of the variable on the y axis, and years are represented as colors. The function allows for spatial and temporal aggregations, plotting single or multiple time series of different areas simultaneously (using facets), axis transformations, and axis and title labeling.\nIn this example, we explore the seasonal patterns of minimum temperature aggregated at the meso code level.\nplot_seasonality(dengue_MS, var = \"tmin\", var_label = \"Minimum temperature\",\n                 type = \"cov\", time = \"date\", area = \"micro_code\",   \n                 aggregate_space = \"meso_code\")"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-vignette.html#map",
    "href": "docs/GHRexplore/GHRexplore-vignette.html#map",
    "title": "Introduction to GHRexplore",
    "section": "Map",
    "text": "Map\nplot_map plots choropleth maps of covariates, case counts, or incidence rates. In this function, we also need to supply the sf object containing the polygon geometries in the map argument. We can use the map_area argument to specify the column in the sf object that contains the area identifiers to be merged to the area column of the data frame specified in data.\nplot_map allows for temporal aggregations (by year or across all years), color transformations, centering and binning (current options include quantiles and equal area), as well as title labeling. It can plot both numerical and categorical variables.\nIn this first example, we plot average urbanicity levels (note type=\"cov\") over the entire study period while using an inverted palette:\nplot_map(data = dengue_MS, var = \"urban\",  time = \"date\", \n         type = \"cov\", area = \"micro_code\",  map = map_MS, \n         map_area = \"code\", aggregate_time = \"all\", \n         var_label= \"Urbanicity\", palette = \"-Heat\")\n\nWe now plot case incidence per 1,000 persons (note type=\"inc\" and pt=1000) for every year (aggregate_time = \"year\") and binning into 5 categories using the quantile method (see bins and bins_method arguments).\nplot_map(dengue_MS, var = \"dengue_cases\", type = \"inc\", pop = \"population\", \n         pt = 1000, time = \"date\", area = \"micro_code\",  \n         map = map_MS, map_area = \"code\", aggregate_time = \"year\", \n         bins = 5, bins_method = \"quantile\", palette = \"-Rocket\")  \n\nLastly, here is one example with the categorical, time-invariant biome covariate:\nplot_map(data = dengue_MS, var = \"biome_name\", type = \"cov\",\n         time = \"date\", area = \"micro_code\", aggregate_time = \"all\", \n         map = map_MS, map_area = \"code\", var_label= \"Biome\")"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-vignette.html#bivariate",
    "href": "docs/GHRexplore/GHRexplore-vignette.html#bivariate",
    "title": "Introduction to GHRexplore",
    "section": "Bivariate",
    "text": "Bivariate\nplot_bivariate allows the visually assessment of associations between two variables. It will be a scatter plot if both variables are numeric and box plots if one of them is categorical. Options for customization include grouping by a variable using color or facets (area argument) and axis and title labeling.\nIn this first example, we explore the relationship between maximum temperature and drought while grouping by meso code:\nplot_bivariate(dengue_MS, \n               var = c(\"tmax\", \"pdsi\"), \n               var_label = c(\"Max. temp\", \"PDSI\"),\n               area = \"meso_code\")\n\nNext, we do the same but grouping using facets with free scales:\nplot_bivariate(dengue_MS, \n               var = c(\"tmax\", \"pdsi\"), \n               var_label = c(\"Max. temp\", \"PDSI\"),\n               area = \"meso_code\", \n               facet = TRUE, free_x_scale = TRUE, free_y_scale = TRUE)\n\nLastly, we explore the distribution of minimum temperature and the categorical variable biome while coloring by meso code:\nplot_bivariate(dengue_MS, \n               var = c(\"biome_name\", \"tmax\"), \n               var_label = c(\"Biome\", \"Max. temp\"),\n               area = \"meso_code\")"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-vignette.html#correlation",
    "href": "docs/GHRexplore/GHRexplore-vignette.html#correlation",
    "title": "Introduction to GHRexplore",
    "section": "Correlation",
    "text": "Correlation\nplot_correlation plots a correlation matrix of a set of variables. By default, Pearson correlation is computed, and circles are used to depict correlation values in the lower triangle and the diagonal of the matrix, whereas numbering is used in the upper triangle:\nplot_correlation(dengue_MS, \n                 var = c(\"dengue_cases\",\"pop_density\", \"tmax\", \"tmin\",\n                         \"pdsi\", \"urban\", \"water_network\", \"water_shortage\")) \n\nIn this second example, we use Spearman correlation and customize the triangles and the palette.\nplot_correlation(dengue_MS, var = c(\"dengue_cases\",\"pop_density\", \"tmax\", \"tmin\",\n                                    \"pdsi\", \"urban\", \"water_network\", \"water_shortage\"),  \n                 method = \"spearman\", plot_type = c(\"number\", \"raster\"),\n                 palette = \"RdBu\") \n\nCustom labels for the variables can be provided using the var_label argument."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-vignette.html#compare",
    "href": "docs/GHRexplore/GHRexplore-vignette.html#compare",
    "title": "Introduction to GHRexplore",
    "section": "Compare",
    "text": "Compare\nplot_compare allows the visualization of several variables in the same figure using the same GHRexplore plotting function. Possible functions include plot_timeseries, plot_heatmap, plot_seasonality and plot_map.\nIn plot_compare, the var, var_lab, type and palette can be vectors of the same length that refer to each of the elements to be plotted, while some other elements, like pop, pt, time, area and aggregation functions are shared. The final display of the multiple plots is automatically done via the cowplot package, and several options to arrange the figures are available (see ?plot_combine) including all arguments of cowplot::plot_grid.\nIn this first example, we plot the time series of PDSI and dengue incidence as a single column and combine the legends (ncol=1, combine_legend=TRUE):\nplot_compare(plot_function = plot_timeseries,\n             data = dengue_MS, \n             var = c(\"pdsi\", \"dengue_cases\"),\n             type = c(\"cov\", \"inc\"), \n             var_lab = c(\"PDSI\", \"Dengue Incidence\"),\n             pop = \"population\",\n             time = \"date\", \n             area = \"micro_code\", \n             aggregate_space = \"meso_code\",\n             ncol=1, \n             combine_legend=TRUE)\n\nIn this second example, we plot heatmaps of PDSI and dengue incidence using different palettes:\nplot_compare(plot_function = plot_heatmap,\n             data = dengue_MS, \n             var = c(\"pdsi\", \"dengue_cases\"),\n             type = c(\"cov\", \"inc\"), \n             var_lab = c(\"PDSI\", \"Incidence\"),\n             palette = c(\"Purp\", \"Reds\"), \n             pop = \"population\",\n             time = \"date\", \n             area = \"micro_code\", \n             aggregate_space = \"meso_code\",\n             ncol=1)"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-index.html",
    "href": "docs/GHRexplore/GHRexplore-index.html",
    "title": "GHRexplore reference",
    "section": "",
    "text": "GHR_palette: Generates color palettes including custom, ColorBrewer and colorspace palettes.\nGHRexplore-package: A collection of commonly used visualizations of temporal and spatio-temporal health data including case counts, incidence rates, and covariates.\naggregate_cases: Aggregates a data frame containing disease cases in space and/or time.\naggregate_cov: Aggregates a data frame containing a covariate of interest in space and/or time.\ndengue_MS: Monthly number of notified dengue cases by municipality in the Mato Grosso do Sul state of Brazil and a set of spatial and spatio-temporal covariates.\ndengue_SP: Data frame containing the weekly number of notified dengue cases in the municipality of Sao Paulo , as well as a set of climatic covariates.\nmap_MS: Administrative boundaries (polygon geometries) of the 11 municipalities in Mato Grosso do Sul (Brazil) to be used with the dengue_MS data set.\nplot_bivariate: Plots a bivariate graph to visually assess associations.\nplot_combine: Combines plots, each representing one variable, into a single plot.\nplot_compare: Combines multiple plots of several variables in a single graph.\nplot_correlation: Plots a correlation matrix of a series of variables.\nplot_heatmap: Plots temporal heatmaps of covariates, case counts, or incidence rates.\nplot_map: Plots a choropleth map of covariates, case counts, or incidence rates.\nplot_multiple: Produces a list of multiple plots of the same type, each representing one variable.\nplot_seasonality: Plots yearly time series of covariates, case counts, or incidence rates to explore seasonality patterns.\nplot_timeseries: Plots time series of covariates, case counts, or incidence rates.\nplot_timeseries2: Plots time series of two covariates, case counts, or incidence rates in two different axes."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/dengue_SP.Rd.html",
    "href": "docs/GHRexplore/GHRexplore-reference/dengue_SP.Rd.html",
    "title": "Dengue cases in Sao Paulo",
    "section": "",
    "text": "Data frame containing the weekly number of notified dengue cases in the municipality of Sao Paulo, as well as a set of climatic covariates.\ndata(dengue_SP)\n\n\n\nA data frame with 678 rows and 8 columns:\n\ndate: First day of the week in date format.\ngeocode: Unique ID code for Sao Paulo microregion.\ncases: Number of notified dengue cases.\nyear: Year (2010 - 2022).\ntemp_med: Weekly average daily mean temperature.\nprecip_tot: Weekly cumulative precipitation.\nenso: El Ni√±o-Southern Oscillation index.\npop: Number of inhabitants.\n\n\n\n\nhttps://info.dengue.mat.br/services/api"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/dengue_SP.Rd.html#description",
    "href": "docs/GHRexplore/GHRexplore-reference/dengue_SP.Rd.html#description",
    "title": "Dengue cases in Sao Paulo",
    "section": "",
    "text": "Data frame containing the weekly number of notified dengue cases in the municipality of Sao Paulo, as well as a set of climatic covariates.\ndata(dengue_SP)"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/dengue_SP.Rd.html#format",
    "href": "docs/GHRexplore/GHRexplore-reference/dengue_SP.Rd.html#format",
    "title": "Dengue cases in Sao Paulo",
    "section": "",
    "text": "A data frame with 678 rows and 8 columns:\n\ndate: First day of the week in date format.\ngeocode: Unique ID code for Sao Paulo microregion.\ncases: Number of notified dengue cases.\nyear: Year (2010 - 2022).\ntemp_med: Weekly average daily mean temperature.\nprecip_tot: Weekly cumulative precipitation.\nenso: El Ni√±o-Southern Oscillation index.\npop: Number of inhabitants."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/dengue_SP.Rd.html#source",
    "href": "docs/GHRexplore/GHRexplore-reference/dengue_SP.Rd.html#source",
    "title": "Dengue cases in Sao Paulo",
    "section": "",
    "text": "https://info.dengue.mat.br/services/api"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/GHR_palette.Rd.html",
    "href": "docs/GHRexplore/GHRexplore-reference/GHR_palette.Rd.html",
    "title": "Generate GHR color palettes",
    "section": "",
    "text": "Generates color palettes including custom, ColorBrewer and colorspace palettes.\nCreates a visualization of all custom GHR palettes.\nGHR_palette(palette, ncols = 30)\n\nGHR_palettes()\n\n\n\n\npalette: Name of the GHR, RcolorBrewer or colorspace palette. Use ‚Äú-‚Äù before the palette name (e.g., ‚Äú-Reds‚Äù) to reverse it. A vector of custom colors is also possible.\nncols: Number of colors to sample.\n\n\n\n\nSee all available options by running GHR_palettes(), RColorBrewer::display.brewer.all() and colorspace::hcl_palettes(plot=TRUE).\n\n\n\nGHR_palette() returns the function that generates the color palette and the attribute ‚Äòna_color‚Äô.\nGHR_palettes() returns a plot with the custom GHR palettes.\n\n\n\nGHR_palette(\"IDE1\", 5)(5)\n\nGHR_palettes()"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/GHR_palette.Rd.html#description",
    "href": "docs/GHRexplore/GHRexplore-reference/GHR_palette.Rd.html#description",
    "title": "Generate GHR color palettes",
    "section": "",
    "text": "Generates color palettes including custom, ColorBrewer and colorspace palettes.\nCreates a visualization of all custom GHR palettes.\nGHR_palette(palette, ncols = 30)\n\nGHR_palettes()"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/GHR_palette.Rd.html#arguments",
    "href": "docs/GHRexplore/GHRexplore-reference/GHR_palette.Rd.html#arguments",
    "title": "Generate GHR color palettes",
    "section": "",
    "text": "palette: Name of the GHR, RcolorBrewer or colorspace palette. Use ‚Äú-‚Äù before the palette name (e.g., ‚Äú-Reds‚Äù) to reverse it. A vector of custom colors is also possible.\nncols: Number of colors to sample."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/GHR_palette.Rd.html#details",
    "href": "docs/GHRexplore/GHRexplore-reference/GHR_palette.Rd.html#details",
    "title": "Generate GHR color palettes",
    "section": "",
    "text": "See all available options by running GHR_palettes(), RColorBrewer::display.brewer.all() and colorspace::hcl_palettes(plot=TRUE)."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/GHR_palette.Rd.html#returns",
    "href": "docs/GHRexplore/GHRexplore-reference/GHR_palette.Rd.html#returns",
    "title": "Generate GHR color palettes",
    "section": "",
    "text": "GHR_palette() returns the function that generates the color palette and the attribute ‚Äòna_color‚Äô.\nGHR_palettes() returns a plot with the custom GHR palettes."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/GHR_palette.Rd.html#examples",
    "href": "docs/GHRexplore/GHRexplore-reference/GHR_palette.Rd.html#examples",
    "title": "Generate GHR color palettes",
    "section": "",
    "text": "GHR_palette(\"IDE1\", 5)(5)\n\nGHR_palettes()"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/aggregate_cases.Rd.html",
    "href": "docs/GHRexplore/GHRexplore-reference/aggregate_cases.Rd.html",
    "title": "Aggregate cases",
    "section": "",
    "text": "Aggregates a data frame containing disease cases in space and/or time.\naggregate_cases(\n  data = NULL,\n  cases = NULL,\n  pop = NULL,\n  time = NULL,\n  area = NULL,\n  pt = 1e+05,\n  aggregate_space = NULL,\n  aggregate_time = NULL\n)\n\n\n\n\ndata: Data frame containing equally spaced (daily, weekly, monthly) incident cases for one or multiple areas.\ncases: Name of the variable that identifies the cases.\npop: Name of the variable that identifies the population.\ntime: Name of the variable that identifies the temporal dimension. The values must be in date format (‚Äúyyyy-mm-dd‚Äù) representing the day of observation for daily data, the first day of the week for weekly, or the first day of the month for monthly observations.\narea: Name of variable that identifies the different locations (e.g., areal units) for which a time series is available.\npt: Scale of the person-time (default 100,000) for incidence rates.\naggregate_space: Name of variable used to define spatial aggregation groups.\naggregate_time: Temporal scale used to perform temporal aggregation. Options are: ‚Äúweek‚Äù (ISO 8601), ‚Äúmonth‚Äù, ‚Äúyear‚Äù.\n\n\n\n\nA data frame with the aggregated cases."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/aggregate_cases.Rd.html#description",
    "href": "docs/GHRexplore/GHRexplore-reference/aggregate_cases.Rd.html#description",
    "title": "Aggregate cases",
    "section": "",
    "text": "Aggregates a data frame containing disease cases in space and/or time.\naggregate_cases(\n  data = NULL,\n  cases = NULL,\n  pop = NULL,\n  time = NULL,\n  area = NULL,\n  pt = 1e+05,\n  aggregate_space = NULL,\n  aggregate_time = NULL\n)"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/aggregate_cases.Rd.html#arguments",
    "href": "docs/GHRexplore/GHRexplore-reference/aggregate_cases.Rd.html#arguments",
    "title": "Aggregate cases",
    "section": "",
    "text": "data: Data frame containing equally spaced (daily, weekly, monthly) incident cases for one or multiple areas.\ncases: Name of the variable that identifies the cases.\npop: Name of the variable that identifies the population.\ntime: Name of the variable that identifies the temporal dimension. The values must be in date format (‚Äúyyyy-mm-dd‚Äù) representing the day of observation for daily data, the first day of the week for weekly, or the first day of the month for monthly observations.\narea: Name of variable that identifies the different locations (e.g., areal units) for which a time series is available.\npt: Scale of the person-time (default 100,000) for incidence rates.\naggregate_space: Name of variable used to define spatial aggregation groups.\naggregate_time: Temporal scale used to perform temporal aggregation. Options are: ‚Äúweek‚Äù (ISO 8601), ‚Äúmonth‚Äù, ‚Äúyear‚Äù."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/aggregate_cases.Rd.html#returns",
    "href": "docs/GHRexplore/GHRexplore-reference/aggregate_cases.Rd.html#returns",
    "title": "Aggregate cases",
    "section": "",
    "text": "A data frame with the aggregated cases."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_seasonality.Rd.html",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_seasonality.Rd.html",
    "title": "Seasonality plot",
    "section": "",
    "text": "Plots yearly time series of covariates, case counts, or incidence rates to explore seasonality patterns.\nplot_seasonality(\n  data,\n  var,\n  time,\n  type = \"cov\",\n  pop = NULL,\n  pt = 1e+05,\n  area = NULL,\n  aggregate_space = NULL,\n  aggregate_time = \"month\",\n  aggregate_space_fun = \"mean\",\n  aggregate_time_fun = \"mean\",\n  transform = \"identity\",\n  title = NULL,\n  var_label = NULL,\n  ylab = NULL,\n  xlab = NULL,\n  free_y_scale = FALSE,\n  palette = \"IDE1\"\n)\n\n\n\n\ndata: Data frame containing equally spaced (daily, weekly, monthly) covariate or disease case observations for one or multiple locations.\nvar: Name of the column identifying the variable to be plotted.\ntime: Name of the variable that identifies the temporal dimension of the data frame. Its values must be in date format (‚Äúyyyy-mm-dd‚Äù) representing the day of observation for daily data, the first day of the week for weekly, or the first day of the month for monthly observations.\ntype: Character that specifies the type of variable in var. Possible values include ‚Äòcov‚Äô (covariate, default), ‚Äòcounts‚Äô (case counts), and ‚Äòinc‚Äô (case incidence). If type='inc', pop is required.\npop: Character identifying the variable name for population. Only needed if type='inc'.\npt: Scale of the person-time (default 100,000) for incidence rates.\narea: Name of variable that identifies the different locations (e.g., areal units) for which a time series is available.\naggregate_space: Name of variable used to define spatial aggregation groups.\naggregate_time: Temporal scale used to perform temporal aggregation. Options are: ‚Äúweek‚Äù (ISO 8601), ‚Äúmonth‚Äù, ‚Äúyear‚Äù.\naggregate_space_fun: Character indicating the function to be used in the aggregation over space for type=\"cov\". Options are ‚Äúmean‚Äù (default), ‚Äúmedian‚Äù, ‚Äúsum‚Äù. For case counts and incidence, ‚Äúsum‚Äù is always applied.\naggregate_time_fun: Character indicating the function to be used in the aggregation over time for type=\"cov\". Options are ‚Äúmean‚Äù (default), ‚Äúmedian‚Äù, ‚Äúsum‚Äù. For case counts and incidence, ‚Äúsum‚Äù is always applied.\ntransform: Character, defaults to ‚Äúidentity‚Äù (i.e., no transformation). Transforms the y-axis for better visualization. Useful options include ‚Äúlog10p1‚Äù log10(x+1) for case counts and incidence with 0s, or any of the in-built ggplot2 options such as ‚Äúlog10‚Äù log10(x), ‚Äúlog1p‚Äù log(x+1), and ‚Äúsqrt‚Äù sqrt(x) (check all possible options using ?scale_y_continuous).\ntitle: Optional title of the plot.\nvar_label: Character with a custom name for the case or covariate variable.\nylab: Label for the y-axis.\nxlab: Label for the x-axis.\nfree_y_scale: If TRUE, the y-axis scale is free in each facet.\npalette: GHR, RColorBrewer or colorspace palette. Use ‚Äú-‚Äù before the palette name (e.g., ‚Äú-Reds‚Äù) to reverse it.\n\n\n\n\nA ggplot2 seasonality plot.\n\n\n\n# Load data\ndata(\"dengue_MS\")\n\n# Seasonality plot of a covariate with space aggregation\nplot_seasonality(dengue_MS,\n                 var = \"tmax\",\n                 time = \"date\",\n                 var_label = \"Max temp.\",\n                 type = \"cov\",\n                 area = \"micro_code\",\n                 aggregate_space = \"region_code\") \n\n# Plot case counts (log scale) with space aggregation\n plot_seasonality(dengue_MS,\n                  var = \"dengue_cases\",\n                  time = \"date\",  \n                  type = \"counts\",\n                  area = \"micro_code\",\n                  aggregate_space = \"meso_code\",\n                  transform = \"log10p1\",\n                  var_label = \"Monthly Dengue Cases\", \n                  xlab = \"Month\", \n                  ylab = \"Number of cases\",\n                  free_y_scale = TRUE)\n                  \n# Seasonality plot of incidence\nplot_seasonality(dengue_MS,\n                 var = \"dengue_cases\",\n                 time = \"date\",    \n                 type = \"inc\",\n                 pop = \"population\",\n                 area = \"micro_code\",\n                 pt = 1000, \n                 title = \"Monthly Dengue Incidence\",\n                 palette = \"Reds\")"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_seasonality.Rd.html#description",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_seasonality.Rd.html#description",
    "title": "Seasonality plot",
    "section": "",
    "text": "Plots yearly time series of covariates, case counts, or incidence rates to explore seasonality patterns.\nplot_seasonality(\n  data,\n  var,\n  time,\n  type = \"cov\",\n  pop = NULL,\n  pt = 1e+05,\n  area = NULL,\n  aggregate_space = NULL,\n  aggregate_time = \"month\",\n  aggregate_space_fun = \"mean\",\n  aggregate_time_fun = \"mean\",\n  transform = \"identity\",\n  title = NULL,\n  var_label = NULL,\n  ylab = NULL,\n  xlab = NULL,\n  free_y_scale = FALSE,\n  palette = \"IDE1\"\n)"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_seasonality.Rd.html#arguments",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_seasonality.Rd.html#arguments",
    "title": "Seasonality plot",
    "section": "",
    "text": "data: Data frame containing equally spaced (daily, weekly, monthly) covariate or disease case observations for one or multiple locations.\nvar: Name of the column identifying the variable to be plotted.\ntime: Name of the variable that identifies the temporal dimension of the data frame. Its values must be in date format (‚Äúyyyy-mm-dd‚Äù) representing the day of observation for daily data, the first day of the week for weekly, or the first day of the month for monthly observations.\ntype: Character that specifies the type of variable in var. Possible values include ‚Äòcov‚Äô (covariate, default), ‚Äòcounts‚Äô (case counts), and ‚Äòinc‚Äô (case incidence). If type='inc', pop is required.\npop: Character identifying the variable name for population. Only needed if type='inc'.\npt: Scale of the person-time (default 100,000) for incidence rates.\narea: Name of variable that identifies the different locations (e.g., areal units) for which a time series is available.\naggregate_space: Name of variable used to define spatial aggregation groups.\naggregate_time: Temporal scale used to perform temporal aggregation. Options are: ‚Äúweek‚Äù (ISO 8601), ‚Äúmonth‚Äù, ‚Äúyear‚Äù.\naggregate_space_fun: Character indicating the function to be used in the aggregation over space for type=\"cov\". Options are ‚Äúmean‚Äù (default), ‚Äúmedian‚Äù, ‚Äúsum‚Äù. For case counts and incidence, ‚Äúsum‚Äù is always applied.\naggregate_time_fun: Character indicating the function to be used in the aggregation over time for type=\"cov\". Options are ‚Äúmean‚Äù (default), ‚Äúmedian‚Äù, ‚Äúsum‚Äù. For case counts and incidence, ‚Äúsum‚Äù is always applied.\ntransform: Character, defaults to ‚Äúidentity‚Äù (i.e., no transformation). Transforms the y-axis for better visualization. Useful options include ‚Äúlog10p1‚Äù log10(x+1) for case counts and incidence with 0s, or any of the in-built ggplot2 options such as ‚Äúlog10‚Äù log10(x), ‚Äúlog1p‚Äù log(x+1), and ‚Äúsqrt‚Äù sqrt(x) (check all possible options using ?scale_y_continuous).\ntitle: Optional title of the plot.\nvar_label: Character with a custom name for the case or covariate variable.\nylab: Label for the y-axis.\nxlab: Label for the x-axis.\nfree_y_scale: If TRUE, the y-axis scale is free in each facet.\npalette: GHR, RColorBrewer or colorspace palette. Use ‚Äú-‚Äù before the palette name (e.g., ‚Äú-Reds‚Äù) to reverse it."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_seasonality.Rd.html#returns",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_seasonality.Rd.html#returns",
    "title": "Seasonality plot",
    "section": "",
    "text": "A ggplot2 seasonality plot."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_seasonality.Rd.html#examples",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_seasonality.Rd.html#examples",
    "title": "Seasonality plot",
    "section": "",
    "text": "# Load data\ndata(\"dengue_MS\")\n\n# Seasonality plot of a covariate with space aggregation\nplot_seasonality(dengue_MS,\n                 var = \"tmax\",\n                 time = \"date\",\n                 var_label = \"Max temp.\",\n                 type = \"cov\",\n                 area = \"micro_code\",\n                 aggregate_space = \"region_code\") \n\n# Plot case counts (log scale) with space aggregation\n plot_seasonality(dengue_MS,\n                  var = \"dengue_cases\",\n                  time = \"date\",  \n                  type = \"counts\",\n                  area = \"micro_code\",\n                  aggregate_space = \"meso_code\",\n                  transform = \"log10p1\",\n                  var_label = \"Monthly Dengue Cases\", \n                  xlab = \"Month\", \n                  ylab = \"Number of cases\",\n                  free_y_scale = TRUE)\n                  \n# Seasonality plot of incidence\nplot_seasonality(dengue_MS,\n                 var = \"dengue_cases\",\n                 time = \"date\",    \n                 type = \"inc\",\n                 pop = \"population\",\n                 area = \"micro_code\",\n                 pt = 1000, \n                 title = \"Monthly Dengue Incidence\",\n                 palette = \"Reds\")"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_timeseries.Rd.html",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_timeseries.Rd.html",
    "title": "Time series plot",
    "section": "",
    "text": "Plots time series of covariates, case counts, or incidence rates.\nplot_timeseries(\n  data,\n  var,\n  time,\n  type = \"cov\",\n  pop = NULL,\n  pt = 1e+05,\n  area = NULL,\n  aggregate_space = NULL,\n  aggregate_time = NULL,\n  aggregate_space_fun = \"mean\",\n  aggregate_time_fun = \"mean\",\n  facet = FALSE,\n  highlight = NULL,\n  transform = \"identity\",\n  title = NULL,\n  var_label = NULL,\n  legend = NULL,\n  ylab = NULL,\n  xlab = NULL,\n  free_y_scale = FALSE,\n  palette = NULL\n)\n\n\n\n\ndata: Data frame containing equally spaced (daily, weekly, monthly) covariate or disease case observations for one or multiple locations.\nvar: Name of the column identifying the variable to be plotted.\ntime: Name of the variable that identifies the temporal dimension of the data frame. Its values must be in date format (‚Äúyyyy-mm-dd‚Äù) representing the day of observation for daily data, the first day of the week for weekly, or the first day of the month for monthly observations.\ntype: Character that specifies the type of variable in var. Possible values include ‚Äòcov‚Äô (covariate, default), ‚Äòcounts‚Äô (case counts), and ‚Äòinc‚Äô (case incidence). If type='inc', pop is required.\npop: Character identifying the variable name for population. Only needed if type='inc'.\npt: Numerical only used for type='inc'. It represents the scale of the person-time (default 100,000) for incidence rates.\narea: Name of variable that identifies the different locations (e.g., areal units) for which a time series is available.\naggregate_space: Name of variable used to define spatial aggregation groups.\naggregate_time: Temporal scale used to perform temporal aggregation. Options are: ‚Äúweek‚Äù (ISO 8601), ‚Äúmonth‚Äù, ‚Äúyear‚Äù.\naggregate_space_fun: Character indicating the function to be used in the aggregation over space for type=\"cov\". Options are ‚Äúmean‚Äù (default), ‚Äúmedian‚Äù, ‚Äúsum‚Äù. For case counts and incidence, ‚Äúsum‚Äù is always applied.\naggregate_time_fun: Character indicating the function to be used in the aggregation over time for type=\"cov\". Options are ‚Äúmean‚Äù (default), ‚Äúmedian‚Äù, ‚Äúsum‚Äù. For case counts and incidence, ‚Äúsum‚Äù is always applied.\nfacet: If TRUE a separate time series for each space unit is plotted in different facets.\nhighlight: ID of the area to be highlighted. Using this option will only color the selected spatial unit and set all the rest to grey.\ntransform: Character, defaults to ‚Äúidentity‚Äù (i.e., no transformation). Transforms the y-axis for better visualization. Useful options include ‚Äúlog10p1‚Äù log10(x+1) useful for case counts and incidence with 0s, or any of the in-built ggplot2 options such as ‚Äúlog10‚Äù log10(x), ‚Äúlog1p‚Äù log(x+1), and ‚Äúsqrt‚Äù sqrt(x) (check all possible options using ?scale_y_continuous).\ntitle: Optional title of the plot.\nvar_label: Character with a custom name for the case or covariate variable.\nlegend: Character with a custom name for the legend.\nylab: Label for the y-axis.\nxlab: Label for the x-axis.\nfree_y_scale: Logical, default FALSE. Allows different scales in the y_axis when facets are used.\npalette: GHR, RColorBrewer or colorspace palette (e.g.¬†‚ÄúPurp‚Äù). Single R colors in colors() or hex codes can be used for single time series or facets. Use ‚Äú-‚Äù before the palette name (e.g., ‚Äú-Reds‚Äù) to reverse it. Defaults to a dark green when area is NULL, when facet is TRUE or when highlight is used (i.e.¬†single time series), otherwise defaults to the ‚ÄúIDE2‚Äù palette.\n\n\n\n\nA ggplot2 time series plot.\n\n\n\nplot_timeseries2 for dual-axis time series plots.\n\n\n\n# Load data\ndata(\"dengue_MS\")\n\n# Plotting a covariate, all areas in a single graph\nplot_timeseries(dengue_MS,\n                var = \"tmin\",\n                time = \"date\",          \n                type = \"cov\",\n                area = \"micro_code\",   \n                title = \"Minimun Temperature\") \n                \n# Plotting a covariate with space aggregation and different facets\nplot_timeseries(dengue_MS,\n                var = \"tmin\",\n                time = \"date\",\n                type = \"cov\",\n                area = \"micro_code\",\n                aggregate_space = \"meso_code\",\n                aggregate_space_fun = \"mean\",\n                facet = TRUE,           \n                var_label= \"Minimum Temperature\",\n                palette = \"violetred\")\n                \n# Plotting counts, highlight a single area \nplot_timeseries(dengue_MS,\n                var = \"dengue_cases\", \n                time = \"date\",         \n                type = \"counts\",\n                pop = \"population\",\n                area = \"micro_code\",  \n                title= \"Dengue cases\",\n                highlight = \"50001\")\n\n# Plot disease counts (log scale) with temporal and spatial aggregation             \nplot_timeseries(dengue_MS,\n                var = \"dengue_cases\", \n                time = \"date\",      \n                type = \"counts\",\n                area = \"micro_code\",   \n                aggregate_space = \"meso_code\",\n                aggregate_time = \"year\",\n                title = \"Yearly Cases\",\n                transform = \"log10\") \n               \n# Plot incidence for 1,000 people with a Brewer palette and log y axis\nplot_timeseries(dengue_MS,\n                var = \"dengue_cases\",\n                time = \"date\",          \n                type = \"inc\",\n                pop = \"population\",\n                area = \"micro_code\",  \n                pt = 1000,\n                transform = \"log10p1\")"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_timeseries.Rd.html#description",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_timeseries.Rd.html#description",
    "title": "Time series plot",
    "section": "",
    "text": "Plots time series of covariates, case counts, or incidence rates.\nplot_timeseries(\n  data,\n  var,\n  time,\n  type = \"cov\",\n  pop = NULL,\n  pt = 1e+05,\n  area = NULL,\n  aggregate_space = NULL,\n  aggregate_time = NULL,\n  aggregate_space_fun = \"mean\",\n  aggregate_time_fun = \"mean\",\n  facet = FALSE,\n  highlight = NULL,\n  transform = \"identity\",\n  title = NULL,\n  var_label = NULL,\n  legend = NULL,\n  ylab = NULL,\n  xlab = NULL,\n  free_y_scale = FALSE,\n  palette = NULL\n)"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_timeseries.Rd.html#arguments",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_timeseries.Rd.html#arguments",
    "title": "Time series plot",
    "section": "",
    "text": "data: Data frame containing equally spaced (daily, weekly, monthly) covariate or disease case observations for one or multiple locations.\nvar: Name of the column identifying the variable to be plotted.\ntime: Name of the variable that identifies the temporal dimension of the data frame. Its values must be in date format (‚Äúyyyy-mm-dd‚Äù) representing the day of observation for daily data, the first day of the week for weekly, or the first day of the month for monthly observations.\ntype: Character that specifies the type of variable in var. Possible values include ‚Äòcov‚Äô (covariate, default), ‚Äòcounts‚Äô (case counts), and ‚Äòinc‚Äô (case incidence). If type='inc', pop is required.\npop: Character identifying the variable name for population. Only needed if type='inc'.\npt: Numerical only used for type='inc'. It represents the scale of the person-time (default 100,000) for incidence rates.\narea: Name of variable that identifies the different locations (e.g., areal units) for which a time series is available.\naggregate_space: Name of variable used to define spatial aggregation groups.\naggregate_time: Temporal scale used to perform temporal aggregation. Options are: ‚Äúweek‚Äù (ISO 8601), ‚Äúmonth‚Äù, ‚Äúyear‚Äù.\naggregate_space_fun: Character indicating the function to be used in the aggregation over space for type=\"cov\". Options are ‚Äúmean‚Äù (default), ‚Äúmedian‚Äù, ‚Äúsum‚Äù. For case counts and incidence, ‚Äúsum‚Äù is always applied.\naggregate_time_fun: Character indicating the function to be used in the aggregation over time for type=\"cov\". Options are ‚Äúmean‚Äù (default), ‚Äúmedian‚Äù, ‚Äúsum‚Äù. For case counts and incidence, ‚Äúsum‚Äù is always applied.\nfacet: If TRUE a separate time series for each space unit is plotted in different facets.\nhighlight: ID of the area to be highlighted. Using this option will only color the selected spatial unit and set all the rest to grey.\ntransform: Character, defaults to ‚Äúidentity‚Äù (i.e., no transformation). Transforms the y-axis for better visualization. Useful options include ‚Äúlog10p1‚Äù log10(x+1) useful for case counts and incidence with 0s, or any of the in-built ggplot2 options such as ‚Äúlog10‚Äù log10(x), ‚Äúlog1p‚Äù log(x+1), and ‚Äúsqrt‚Äù sqrt(x) (check all possible options using ?scale_y_continuous).\ntitle: Optional title of the plot.\nvar_label: Character with a custom name for the case or covariate variable.\nlegend: Character with a custom name for the legend.\nylab: Label for the y-axis.\nxlab: Label for the x-axis.\nfree_y_scale: Logical, default FALSE. Allows different scales in the y_axis when facets are used.\npalette: GHR, RColorBrewer or colorspace palette (e.g.¬†‚ÄúPurp‚Äù). Single R colors in colors() or hex codes can be used for single time series or facets. Use ‚Äú-‚Äù before the palette name (e.g., ‚Äú-Reds‚Äù) to reverse it. Defaults to a dark green when area is NULL, when facet is TRUE or when highlight is used (i.e.¬†single time series), otherwise defaults to the ‚ÄúIDE2‚Äù palette."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_timeseries.Rd.html#returns",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_timeseries.Rd.html#returns",
    "title": "Time series plot",
    "section": "",
    "text": "A ggplot2 time series plot."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_timeseries.Rd.html#see-also",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_timeseries.Rd.html#see-also",
    "title": "Time series plot",
    "section": "",
    "text": "plot_timeseries2 for dual-axis time series plots."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_timeseries.Rd.html#examples",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_timeseries.Rd.html#examples",
    "title": "Time series plot",
    "section": "",
    "text": "# Load data\ndata(\"dengue_MS\")\n\n# Plotting a covariate, all areas in a single graph\nplot_timeseries(dengue_MS,\n                var = \"tmin\",\n                time = \"date\",          \n                type = \"cov\",\n                area = \"micro_code\",   \n                title = \"Minimun Temperature\") \n                \n# Plotting a covariate with space aggregation and different facets\nplot_timeseries(dengue_MS,\n                var = \"tmin\",\n                time = \"date\",\n                type = \"cov\",\n                area = \"micro_code\",\n                aggregate_space = \"meso_code\",\n                aggregate_space_fun = \"mean\",\n                facet = TRUE,           \n                var_label= \"Minimum Temperature\",\n                palette = \"violetred\")\n                \n# Plotting counts, highlight a single area \nplot_timeseries(dengue_MS,\n                var = \"dengue_cases\", \n                time = \"date\",         \n                type = \"counts\",\n                pop = \"population\",\n                area = \"micro_code\",  \n                title= \"Dengue cases\",\n                highlight = \"50001\")\n\n# Plot disease counts (log scale) with temporal and spatial aggregation             \nplot_timeseries(dengue_MS,\n                var = \"dengue_cases\", \n                time = \"date\",      \n                type = \"counts\",\n                area = \"micro_code\",   \n                aggregate_space = \"meso_code\",\n                aggregate_time = \"year\",\n                title = \"Yearly Cases\",\n                transform = \"log10\") \n               \n# Plot incidence for 1,000 people with a Brewer palette and log y axis\nplot_timeseries(dengue_MS,\n                var = \"dengue_cases\",\n                time = \"date\",          \n                type = \"inc\",\n                pop = \"population\",\n                area = \"micro_code\",  \n                pt = 1000,\n                transform = \"log10p1\")"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_timeseries2.Rd.html",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_timeseries2.Rd.html",
    "title": "Time series plot of two variables in two different axes",
    "section": "",
    "text": "Plots time series of two covariates, case counts, or incidence rates in two different axes.\nplot_timeseries2(\n  data,\n  var,\n  time,\n  type = c(\"cov\", \"cov\"),\n  pop = NULL,\n  pt = 1e+05,\n  area = NULL,\n  aggregate_space = NULL,\n  aggregate_time = NULL,\n  aggregate_space_fun = \"mean\",\n  aggregate_time_fun = \"mean\",\n  align = \"min\",\n  title = NULL,\n  var_label = NULL,\n  legend = \"Variable\",\n  ylab = NULL,\n  xlab = NULL,\n  free_y_scale = FALSE,\n  palette = c(\"#168c81\", \"#B98AFB\"),\n  alpha = 0.9\n)\n\n\n\n\ndata: Data frame containing equally spaced (daily, weekly, monthly) covariate or disease case observations for one or multiple locations.\nvar: A character vector of length 2 (left axis, right axis) identifying the variables to be plotted.\ntime: Name of the variable that identifies the temporal dimension of the data frame. Its values must be in date format (‚Äúyyyy-mm-dd‚Äù) representing the day of observation for daily data, the first day of the week for weekly, or the first day of the month for monthly observations.\ntype: A character vector of length 2 (left axis, right axis) that specifies the types of variable in var. Possible values include ‚Äòcov‚Äô (covariate, default), ‚Äòcounts‚Äô (case counts), and ‚Äòinc‚Äô (case incidence). If type='inc', pop is required.\npop: Character identifying the variable name for population. Only needed if type='inc'.\npt: Numerical only used for type='inc'. It represents the scale of the person-time (default 100,000) for incidence rates.\narea: Name of variable that identifies the different locations (e.g., areal units) for which a time series is available.\naggregate_space: Name of variable used to define spatial aggregation groups.\naggregate_time: Temporal scale used to perform temporal aggregation. Options are: ‚Äúweek‚Äù (ISO 8601), ‚Äúmonth‚Äù, ‚Äúyear‚Äù.\naggregate_space_fun: Character indicating the function to be used in the aggregation over space for type=\"cov\". Options are ‚Äúmean‚Äù (default), ‚Äúmedian‚Äù, ‚Äúsum‚Äù. For case counts and incidence, ‚Äúsum‚Äù is always applied.\naggregate_time_fun: Character indicating the function to be used in the aggregation over time for type=\"cov\". Options are ‚Äúmean‚Äù (default), ‚Äúmedian‚Äù, ‚Äúsum‚Äù. For case counts and incidence, ‚Äúsum‚Äù is always applied.\nalign: Options to align the two plots. Defaults to ‚Äúmin‚Äù, which forces the minimum of the two variables to be aligned. Other options include ‚Äúmean‚Äù and ‚Äúmedian‚Äù.\ntitle: Optional title of the plot.\nvar_label: A character vector of length 2 (left axis, right axis) with custom names for the case or covariate variable.\nlegend: Character with a custom name for the legend.\nylab: A character vector of length 2 (left, right) for the y-axes.\nxlab: Label for the x-axis.\nfree_y_scale: Logical, default FALSE. Allows different scales in the y_axis when facets are used.\npalette: A character vector of length 2 (left axis, right axis) indicating the colours (R or hex codes) to use for each of the two variables).\nalpha: Numerical between 0 and 1 determining the transparency of the lines.\n\n\n\n\nA ggplot2 time series plot.\n\n\n\nplot_timeseries for single axis time series plots.\n\n\n\n# Load data\ndata(\"dengue_MS\")\ndata(\"dengue_SP\")\n\n# Plotting two covariates with temporal aggregation, align using the mean\nplot_timeseries2(dengue_SP,\n                 var = c(\"temp_med\", \"precip_tot\"),\n                 time = \"date\",\n                 align = \"mean\",\n                 aggregate_time = \"month\")\n\n# Plotting case incidence and a covariate with temporal aggregation \n# and customized colours and labels\nplot_timeseries2(dengue_SP,\n                 var = c(\"cases\", \"precip_tot\"),\n                 type = c(\"inc\", \"cov\"),\n                 var_label = c(\"Incidence\", \"Precipitation\"),\n                 title = \"Precipitation and dengue incidence in Sao Paulo\",\n                 time = \"date\",\n                 pop = \"pop\",\n                 aggregate_time = \"month\",\n                 palette = c(\"darkgreen\", \"royalblue\"),\n                 alpha = 0.8)\n                 \n# Plotting case incidence and a covariate with spatial aggregation\nplot_timeseries2(dengue_MS,\n                 var = c(\"dengue_cases\", \"pdsi\"),\n                 type = c(\"inc\", \"cov\"),\n                 pop = \"population\",\n                 time = \"date\",\n                 area = \"micro_code\",\n                 aggregate_space = \"meso_code\")"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_timeseries2.Rd.html#description",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_timeseries2.Rd.html#description",
    "title": "Time series plot of two variables in two different axes",
    "section": "",
    "text": "Plots time series of two covariates, case counts, or incidence rates in two different axes.\nplot_timeseries2(\n  data,\n  var,\n  time,\n  type = c(\"cov\", \"cov\"),\n  pop = NULL,\n  pt = 1e+05,\n  area = NULL,\n  aggregate_space = NULL,\n  aggregate_time = NULL,\n  aggregate_space_fun = \"mean\",\n  aggregate_time_fun = \"mean\",\n  align = \"min\",\n  title = NULL,\n  var_label = NULL,\n  legend = \"Variable\",\n  ylab = NULL,\n  xlab = NULL,\n  free_y_scale = FALSE,\n  palette = c(\"#168c81\", \"#B98AFB\"),\n  alpha = 0.9\n)"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_timeseries2.Rd.html#arguments",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_timeseries2.Rd.html#arguments",
    "title": "Time series plot of two variables in two different axes",
    "section": "",
    "text": "data: Data frame containing equally spaced (daily, weekly, monthly) covariate or disease case observations for one or multiple locations.\nvar: A character vector of length 2 (left axis, right axis) identifying the variables to be plotted.\ntime: Name of the variable that identifies the temporal dimension of the data frame. Its values must be in date format (‚Äúyyyy-mm-dd‚Äù) representing the day of observation for daily data, the first day of the week for weekly, or the first day of the month for monthly observations.\ntype: A character vector of length 2 (left axis, right axis) that specifies the types of variable in var. Possible values include ‚Äòcov‚Äô (covariate, default), ‚Äòcounts‚Äô (case counts), and ‚Äòinc‚Äô (case incidence). If type='inc', pop is required.\npop: Character identifying the variable name for population. Only needed if type='inc'.\npt: Numerical only used for type='inc'. It represents the scale of the person-time (default 100,000) for incidence rates.\narea: Name of variable that identifies the different locations (e.g., areal units) for which a time series is available.\naggregate_space: Name of variable used to define spatial aggregation groups.\naggregate_time: Temporal scale used to perform temporal aggregation. Options are: ‚Äúweek‚Äù (ISO 8601), ‚Äúmonth‚Äù, ‚Äúyear‚Äù.\naggregate_space_fun: Character indicating the function to be used in the aggregation over space for type=\"cov\". Options are ‚Äúmean‚Äù (default), ‚Äúmedian‚Äù, ‚Äúsum‚Äù. For case counts and incidence, ‚Äúsum‚Äù is always applied.\naggregate_time_fun: Character indicating the function to be used in the aggregation over time for type=\"cov\". Options are ‚Äúmean‚Äù (default), ‚Äúmedian‚Äù, ‚Äúsum‚Äù. For case counts and incidence, ‚Äúsum‚Äù is always applied.\nalign: Options to align the two plots. Defaults to ‚Äúmin‚Äù, which forces the minimum of the two variables to be aligned. Other options include ‚Äúmean‚Äù and ‚Äúmedian‚Äù.\ntitle: Optional title of the plot.\nvar_label: A character vector of length 2 (left axis, right axis) with custom names for the case or covariate variable.\nlegend: Character with a custom name for the legend.\nylab: A character vector of length 2 (left, right) for the y-axes.\nxlab: Label for the x-axis.\nfree_y_scale: Logical, default FALSE. Allows different scales in the y_axis when facets are used.\npalette: A character vector of length 2 (left axis, right axis) indicating the colours (R or hex codes) to use for each of the two variables).\nalpha: Numerical between 0 and 1 determining the transparency of the lines."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_timeseries2.Rd.html#returns",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_timeseries2.Rd.html#returns",
    "title": "Time series plot of two variables in two different axes",
    "section": "",
    "text": "A ggplot2 time series plot."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_timeseries2.Rd.html#see-also",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_timeseries2.Rd.html#see-also",
    "title": "Time series plot of two variables in two different axes",
    "section": "",
    "text": "plot_timeseries for single axis time series plots."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_timeseries2.Rd.html#examples",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_timeseries2.Rd.html#examples",
    "title": "Time series plot of two variables in two different axes",
    "section": "",
    "text": "# Load data\ndata(\"dengue_MS\")\ndata(\"dengue_SP\")\n\n# Plotting two covariates with temporal aggregation, align using the mean\nplot_timeseries2(dengue_SP,\n                 var = c(\"temp_med\", \"precip_tot\"),\n                 time = \"date\",\n                 align = \"mean\",\n                 aggregate_time = \"month\")\n\n# Plotting case incidence and a covariate with temporal aggregation \n# and customized colours and labels\nplot_timeseries2(dengue_SP,\n                 var = c(\"cases\", \"precip_tot\"),\n                 type = c(\"inc\", \"cov\"),\n                 var_label = c(\"Incidence\", \"Precipitation\"),\n                 title = \"Precipitation and dengue incidence in Sao Paulo\",\n                 time = \"date\",\n                 pop = \"pop\",\n                 aggregate_time = \"month\",\n                 palette = c(\"darkgreen\", \"royalblue\"),\n                 alpha = 0.8)\n                 \n# Plotting case incidence and a covariate with spatial aggregation\nplot_timeseries2(dengue_MS,\n                 var = c(\"dengue_cases\", \"pdsi\"),\n                 type = c(\"inc\", \"cov\"),\n                 pop = \"population\",\n                 time = \"date\",\n                 area = \"micro_code\",\n                 aggregate_space = \"meso_code\")"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_compare.Rd.html",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_compare.Rd.html",
    "title": "Compare plots",
    "section": "",
    "text": "Combines multiple plots of several variables in a single graph.\nplot_compare(plot_function, data, var, type, ...)\n\n\n\n\nplot_function: Indicates which of the plot types to use. Options are: ‚Äòplot_timeseries‚Äô, ‚Äòplot_heatmap‚Äô, ‚Äòplot_seasonality‚Äô, ‚Äòplot_map‚Äô.\ndata: Data frame containing equally spaced (daily, weekly, monthly) covariate or disease case observations for one or multiple locations.\nvar: Character vector with the name of the variables to be plotted.\ntype: Character vector with the same length of var that specifies the types of variable for each element in var. Possible values include ‚Äòcov‚Äô (covariate, default), ‚Äòcounts‚Äô (case counts), and ‚Äòinc‚Äô (case incidence). If type='inc', pop is required.\n...: Additional arguments for plot_multiple, plot_combine, and the selected plot_function.\n\n\n\n\nThis function takes any input arguments from plot_combine() and plot_multiple() to customize the plots and their organization in a grid.\n\n\n\nA single (cow)plot containing plots of several variables.\n\n\n\nplot_multiple, plot_combine\n\n\n\n# Load data\nlibrary(\"sf\")\ndata(\"dengue_MS\")\ndata(\"map_MS\")\n\nplot_compare(\n  plot_function = plot_timeseries,\n  data = dengue_MS,\n  var = c(\"dengue_cases\",  \"pdsi\"),\n  type = c(\"inc\", \"cov\"),\n  pop = \"population\",\n  time = \"date\",\n  area = \"micro_code\",\n  var_label = c(\"Dengue inc\", \"PDSI\"), \n  combine_legend = TRUE, \n  ncol_legend = 1,\n  ncol = 1, \n  align = \"h\")\n\n# Comparing seasonality plots\nplot_compare(\n  plot_function = plot_seasonality,\n  data = dengue_MS,\n  var = c(\"dengue_cases\", \"dengue_cases\", \"pdsi\"),\n  type = c(\"counts\", \"inc\", \"cov\"),\n  pop = \"population\",\n  time = \"date\",\n  area = \"micro_code\",\n  aggregate_space = \"region_code\",\n  pt = 100,\n  var_label = c(\"Dengue Cases\", \"Dengue inc\", \"Min Temp\"), \n  ncol_legend = 1,\n  combine_legend = TRUE)\n\n# Comparing heatmaps plots\nplot_compare(\n  plot_function = plot_heatmap,\n  data = dengue_MS,\n  var = c(\"dengue_cases\", \"pdsi\"),\n  type = c(\"inc\", \"cov\"),   \n  pop = \"population\",\n  time = \"date\",\n  area = \"micro_code\",\n  var_label = c(\"Dengue Cases\", \"Min Temp\"), \n  palette = c(\"Reds\", \"Blues\"),\n  ncol_legend = 1,\n  combine_xaxis = TRUE)\n\n# Comparing map plots\nplot_compare(\n  plot_function = plot_map,\n  data = dengue_MS,\n  var = c(\"dengue_cases\", \"tmax\"),\n  type = c(\"inc\", \"cov\"),  \n  pop = \"population\",\n  time = \"date\",\n  area = \"micro_code\",\n  var_label= c(\"Dengue Incidence\", \"Max Temperature\"), \n  palette = c(\"Reds\", \"Blues\"),\n  map = map_MS,        \n  map_area = \"code\", \n  aggregate_time = \"all\",\n  ncol_legend = 1,\n  combine_xaxis =TRUE)"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_compare.Rd.html#description",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_compare.Rd.html#description",
    "title": "Compare plots",
    "section": "",
    "text": "Combines multiple plots of several variables in a single graph.\nplot_compare(plot_function, data, var, type, ...)"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_compare.Rd.html#arguments",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_compare.Rd.html#arguments",
    "title": "Compare plots",
    "section": "",
    "text": "plot_function: Indicates which of the plot types to use. Options are: ‚Äòplot_timeseries‚Äô, ‚Äòplot_heatmap‚Äô, ‚Äòplot_seasonality‚Äô, ‚Äòplot_map‚Äô.\ndata: Data frame containing equally spaced (daily, weekly, monthly) covariate or disease case observations for one or multiple locations.\nvar: Character vector with the name of the variables to be plotted.\ntype: Character vector with the same length of var that specifies the types of variable for each element in var. Possible values include ‚Äòcov‚Äô (covariate, default), ‚Äòcounts‚Äô (case counts), and ‚Äòinc‚Äô (case incidence). If type='inc', pop is required.\n...: Additional arguments for plot_multiple, plot_combine, and the selected plot_function."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_compare.Rd.html#details",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_compare.Rd.html#details",
    "title": "Compare plots",
    "section": "",
    "text": "This function takes any input arguments from plot_combine() and plot_multiple() to customize the plots and their organization in a grid."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_compare.Rd.html#returns",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_compare.Rd.html#returns",
    "title": "Compare plots",
    "section": "",
    "text": "A single (cow)plot containing plots of several variables."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_compare.Rd.html#see-also",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_compare.Rd.html#see-also",
    "title": "Compare plots",
    "section": "",
    "text": "plot_multiple, plot_combine"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_compare.Rd.html#examples",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_compare.Rd.html#examples",
    "title": "Compare plots",
    "section": "",
    "text": "# Load data\nlibrary(\"sf\")\ndata(\"dengue_MS\")\ndata(\"map_MS\")\n\nplot_compare(\n  plot_function = plot_timeseries,\n  data = dengue_MS,\n  var = c(\"dengue_cases\",  \"pdsi\"),\n  type = c(\"inc\", \"cov\"),\n  pop = \"population\",\n  time = \"date\",\n  area = \"micro_code\",\n  var_label = c(\"Dengue inc\", \"PDSI\"), \n  combine_legend = TRUE, \n  ncol_legend = 1,\n  ncol = 1, \n  align = \"h\")\n\n# Comparing seasonality plots\nplot_compare(\n  plot_function = plot_seasonality,\n  data = dengue_MS,\n  var = c(\"dengue_cases\", \"dengue_cases\", \"pdsi\"),\n  type = c(\"counts\", \"inc\", \"cov\"),\n  pop = \"population\",\n  time = \"date\",\n  area = \"micro_code\",\n  aggregate_space = \"region_code\",\n  pt = 100,\n  var_label = c(\"Dengue Cases\", \"Dengue inc\", \"Min Temp\"), \n  ncol_legend = 1,\n  combine_legend = TRUE)\n\n# Comparing heatmaps plots\nplot_compare(\n  plot_function = plot_heatmap,\n  data = dengue_MS,\n  var = c(\"dengue_cases\", \"pdsi\"),\n  type = c(\"inc\", \"cov\"),   \n  pop = \"population\",\n  time = \"date\",\n  area = \"micro_code\",\n  var_label = c(\"Dengue Cases\", \"Min Temp\"), \n  palette = c(\"Reds\", \"Blues\"),\n  ncol_legend = 1,\n  combine_xaxis = TRUE)\n\n# Comparing map plots\nplot_compare(\n  plot_function = plot_map,\n  data = dengue_MS,\n  var = c(\"dengue_cases\", \"tmax\"),\n  type = c(\"inc\", \"cov\"),  \n  pop = \"population\",\n  time = \"date\",\n  area = \"micro_code\",\n  var_label= c(\"Dengue Incidence\", \"Max Temperature\"), \n  palette = c(\"Reds\", \"Blues\"),\n  map = map_MS,        \n  map_area = \"code\", \n  aggregate_time = \"all\",\n  ncol_legend = 1,\n  combine_xaxis =TRUE)"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_combine.Rd.html",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_combine.Rd.html",
    "title": "Combine plots",
    "section": "",
    "text": "Combines plots, each representing one variable, into a single plot.\nplot_combine(\n  plot_list,\n  combine_legend = FALSE,\n  combine_xaxis = FALSE,\n  ncol = 1,\n  align = \"v\",\n  ...,\n  ncol_l = 2,\n  nrow_l = NULL,\n  rel_widths_l = c(3, 1),\n  rel_heights_l = c(1, 1),\n  ncol_legend = 1\n)\n\n\n\n\nplot_list: A list of plots to be combined.\ncombine_legend: Logical. If TRUE, assumes the legend of all plots is the same as the legend of the first plot in plot_list and final plot shows only one instance of the common legend. Default is FALSE.\ncombine_xaxis: Logical. If TRUE, removes x axis labels from all but the last plot. Default is FALSE.\nncol: (from cowplot) Number of colums in the plot grid. Default is 1.\nalign: (from cowplot) Specifies how plots should be aligned Options are ‚Äúnone‚Äù, ‚Äúhv‚Äù (align in both directions), ‚Äúh‚Äù, and ‚Äúv‚Äù (default).\n...: Additional arguments passed to cowplot::plot_grid.\nncol_l: When combine_legend = TRUE, number of colums in which to align plots and the common legend. Default is 2.\nnrow_l: When combine_legend = TRUE, number of rows in which to align plots and the common legend. Default is NULL.\nrel_widths_l: When combine_legend = TRUE, vector of widths in which to align plots and the common legend. Default is c(3, 1).\nrel_heights_l: When combine_legend = TRUE, vector of heights in which to align plots and the common legend. Default is c(1, 1).\nncol_legend: When combine_legend = TRUE, number of columns the legend should be distributed in. Default is one column.\n\n\n\n\nThis function takes any input from the cowplot::plot_grid function to customize the organization of the plots.\n\n\n\nA single (cow)plot including the provided multiple plots.\n\n\n\nplot_compare, plot_multiple\n\n\n\n# Load data\ndata(\"dengue_MS\")\n\n# Multiple time series plot\nplots &lt;- plot_multiple(\n  plot_function = plot_timeseries,\n  data = dengue_MS,\n  var = c(\"tmax\", \"tmin\", \"pdsi\"),\n  type = c(\"cov\", \"cov\", \"cov\"),\n  aggregate_space = \"meso_code\",\n  pop = \"population\",\n  var_label = c(\"Max Temp\", \"Min Temp\", \"PDSI\"),\n  time = \"date\",\n  area = \"micro_code\")\n\n# Combine them with a shared legend\nplot_combine(plot_list = plots, \n             ncol = 1,\n             align = \"v\",\n             combine_legend = TRUE,\n             combine_xaxis = TRUE,\n             rel_widths_l = c(7,1))"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_combine.Rd.html#description",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_combine.Rd.html#description",
    "title": "Combine plots",
    "section": "",
    "text": "Combines plots, each representing one variable, into a single plot.\nplot_combine(\n  plot_list,\n  combine_legend = FALSE,\n  combine_xaxis = FALSE,\n  ncol = 1,\n  align = \"v\",\n  ...,\n  ncol_l = 2,\n  nrow_l = NULL,\n  rel_widths_l = c(3, 1),\n  rel_heights_l = c(1, 1),\n  ncol_legend = 1\n)"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_combine.Rd.html#arguments",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_combine.Rd.html#arguments",
    "title": "Combine plots",
    "section": "",
    "text": "plot_list: A list of plots to be combined.\ncombine_legend: Logical. If TRUE, assumes the legend of all plots is the same as the legend of the first plot in plot_list and final plot shows only one instance of the common legend. Default is FALSE.\ncombine_xaxis: Logical. If TRUE, removes x axis labels from all but the last plot. Default is FALSE.\nncol: (from cowplot) Number of colums in the plot grid. Default is 1.\nalign: (from cowplot) Specifies how plots should be aligned Options are ‚Äúnone‚Äù, ‚Äúhv‚Äù (align in both directions), ‚Äúh‚Äù, and ‚Äúv‚Äù (default).\n...: Additional arguments passed to cowplot::plot_grid.\nncol_l: When combine_legend = TRUE, number of colums in which to align plots and the common legend. Default is 2.\nnrow_l: When combine_legend = TRUE, number of rows in which to align plots and the common legend. Default is NULL.\nrel_widths_l: When combine_legend = TRUE, vector of widths in which to align plots and the common legend. Default is c(3, 1).\nrel_heights_l: When combine_legend = TRUE, vector of heights in which to align plots and the common legend. Default is c(1, 1).\nncol_legend: When combine_legend = TRUE, number of columns the legend should be distributed in. Default is one column."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_combine.Rd.html#details",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_combine.Rd.html#details",
    "title": "Combine plots",
    "section": "",
    "text": "This function takes any input from the cowplot::plot_grid function to customize the organization of the plots."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_combine.Rd.html#returns",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_combine.Rd.html#returns",
    "title": "Combine plots",
    "section": "",
    "text": "A single (cow)plot including the provided multiple plots."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_combine.Rd.html#see-also",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_combine.Rd.html#see-also",
    "title": "Combine plots",
    "section": "",
    "text": "plot_compare, plot_multiple"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_combine.Rd.html#examples",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_combine.Rd.html#examples",
    "title": "Combine plots",
    "section": "",
    "text": "# Load data\ndata(\"dengue_MS\")\n\n# Multiple time series plot\nplots &lt;- plot_multiple(\n  plot_function = plot_timeseries,\n  data = dengue_MS,\n  var = c(\"tmax\", \"tmin\", \"pdsi\"),\n  type = c(\"cov\", \"cov\", \"cov\"),\n  aggregate_space = \"meso_code\",\n  pop = \"population\",\n  var_label = c(\"Max Temp\", \"Min Temp\", \"PDSI\"),\n  time = \"date\",\n  area = \"micro_code\")\n\n# Combine them with a shared legend\nplot_combine(plot_list = plots, \n             ncol = 1,\n             align = \"v\",\n             combine_legend = TRUE,\n             combine_xaxis = TRUE,\n             rel_widths_l = c(7,1))"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_bivariate.Rd.html",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_bivariate.Rd.html",
    "title": "Bivariate plot",
    "section": "",
    "text": "Plots a bivariate graph to visually assess associations. It will be a scatterplot if both variables are numeric and grouped boxplots if one of them is categorical.\nplot_bivariate(\n  data,\n  var,\n  area = NULL,\n  facet = FALSE,\n  free_x_scale = FALSE,\n  free_y_scale = FALSE,\n  title = NULL,\n  var_label = NULL,\n  legend = NULL,\n  palette = NULL\n)\n\n\n\n\ndata: Data frame containing equally spaced (daily, weekly, monthly) covariate or disease case observations for one or multiple locations.\nvar: Character vector of covariate names with length 2 (x, y). One of them can be a factor.\narea: Character, the name of the variable that identifies the different areal units or any other grouping of interest. If specified, results are grouped by this variable. Defaults to NULL (no grouping).\nfacet: If TRUE, plot each grouping in a different facet.\nfree_x_scale: If TRUE and facet=TRUE, the x-axis scale is free in each facet.\nfree_y_scale: If TRUE and facet=TRUE, the y-axis scale is free in each facet.\ntitle: Optional title of the plot.\nvar_label: A 2 character vector with a custom name for the variables.\nlegend: A character vector with a custom name for the legend.\npalette: GHR, RColorBrewer or colorspace palette (e.g.¬†‚ÄúPurp‚Äù). Single R colors in colors() or hex codes can be used when there is no grouping or facets are used. Use ‚Äú-‚Äù before the palette name (e.g., ‚Äú-Reds‚Äù) to reverse it. Defaults to a dark green when area is NULL or when facet is TRUE, otherwise defaults to the ‚ÄúIDE2‚Äù palette.\n\n\n\n\nA ggplot2 scatterplot or boxplot graph.\n\n\n\n# Load data\ndata(\"dengue_MS\")\n\n# Scatter (two numeric variables) - No grouping\nplot_bivariate(dengue_MS, \n               var = c(\"pop_density\", \"tmin\"), \n               palette = \"#d04a2d\")\n\n# Scatter (two numeric variables) - Grouping in the same graph\nplot_bivariate(dengue_MS, \n               var = c(\"pop_density\", \"tmin\"),\n               var_label = c(\"Pop. density\", \"Min temp.\"),\n               area = \"micro_code\")\n\n# Scatter  (two numeric variables) - Grouping in facets\nplot_bivariate(dengue_MS,\n               var = c(\"pop_density\", \"tmin\"),\n               var_label = c(\"Pop. density\", \"Min temp.\"),\n               area = \"micro_code\", facet = TRUE, \n               free_x_scale = TRUE)\n\n# Boxplots (one numeric, one categorical) - No grouping\nplot_bivariate(dengue_MS, \n               var = c(\"pop_density\", \"biome_name\"), \n               var_label = c(\"Pop. density\", \"Min temp.\"),\n               palette = \"royalblue\")\n\n# Boxplots (one numeric, one categorical) - Grouping\nplot_bivariate(dengue_MS, \n               var = c(\"biome_name\", \"tmin\"), \n               area = \"meso_code\",\n               palette = \"Accent\")"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_bivariate.Rd.html#description",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_bivariate.Rd.html#description",
    "title": "Bivariate plot",
    "section": "",
    "text": "Plots a bivariate graph to visually assess associations. It will be a scatterplot if both variables are numeric and grouped boxplots if one of them is categorical.\nplot_bivariate(\n  data,\n  var,\n  area = NULL,\n  facet = FALSE,\n  free_x_scale = FALSE,\n  free_y_scale = FALSE,\n  title = NULL,\n  var_label = NULL,\n  legend = NULL,\n  palette = NULL\n)"
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_bivariate.Rd.html#arguments",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_bivariate.Rd.html#arguments",
    "title": "Bivariate plot",
    "section": "",
    "text": "data: Data frame containing equally spaced (daily, weekly, monthly) covariate or disease case observations for one or multiple locations.\nvar: Character vector of covariate names with length 2 (x, y). One of them can be a factor.\narea: Character, the name of the variable that identifies the different areal units or any other grouping of interest. If specified, results are grouped by this variable. Defaults to NULL (no grouping).\nfacet: If TRUE, plot each grouping in a different facet.\nfree_x_scale: If TRUE and facet=TRUE, the x-axis scale is free in each facet.\nfree_y_scale: If TRUE and facet=TRUE, the y-axis scale is free in each facet.\ntitle: Optional title of the plot.\nvar_label: A 2 character vector with a custom name for the variables.\nlegend: A character vector with a custom name for the legend.\npalette: GHR, RColorBrewer or colorspace palette (e.g.¬†‚ÄúPurp‚Äù). Single R colors in colors() or hex codes can be used when there is no grouping or facets are used. Use ‚Äú-‚Äù before the palette name (e.g., ‚Äú-Reds‚Äù) to reverse it. Defaults to a dark green when area is NULL or when facet is TRUE, otherwise defaults to the ‚ÄúIDE2‚Äù palette."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_bivariate.Rd.html#returns",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_bivariate.Rd.html#returns",
    "title": "Bivariate plot",
    "section": "",
    "text": "A ggplot2 scatterplot or boxplot graph."
  },
  {
    "objectID": "docs/GHRexplore/GHRexplore-reference/plot_bivariate.Rd.html#examples",
    "href": "docs/GHRexplore/GHRexplore-reference/plot_bivariate.Rd.html#examples",
    "title": "Bivariate plot",
    "section": "",
    "text": "# Load data\ndata(\"dengue_MS\")\n\n# Scatter (two numeric variables) - No grouping\nplot_bivariate(dengue_MS, \n               var = c(\"pop_density\", \"tmin\"), \n               palette = \"#d04a2d\")\n\n# Scatter (two numeric variables) - Grouping in the same graph\nplot_bivariate(dengue_MS, \n               var = c(\"pop_density\", \"tmin\"),\n               var_label = c(\"Pop. density\", \"Min temp.\"),\n               area = \"micro_code\")\n\n# Scatter  (two numeric variables) - Grouping in facets\nplot_bivariate(dengue_MS,\n               var = c(\"pop_density\", \"tmin\"),\n               var_label = c(\"Pop. density\", \"Min temp.\"),\n               area = \"micro_code\", facet = TRUE, \n               free_x_scale = TRUE)\n\n# Boxplots (one numeric, one categorical) - No grouping\nplot_bivariate(dengue_MS, \n               var = c(\"pop_density\", \"biome_name\"), \n               var_label = c(\"Pop. density\", \"Min temp.\"),\n               palette = \"royalblue\")\n\n# Boxplots (one numeric, one categorical) - Grouping\nplot_bivariate(dengue_MS, \n               var = c(\"biome_name\", \"tmin\"), \n               area = \"meso_code\",\n               palette = \"Accent\")"
  },
  {
    "objectID": "docs/GHRpredict/GHRpredict.html",
    "href": "docs/GHRpredict/GHRpredict.html",
    "title": "GHRpredict",
    "section": "",
    "text": "Under construction."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_covariates.html#ghrmodel-formula-helper-functions",
    "href": "docs/GHRmodel/GHRmodel_covariates.html#ghrmodel-formula-helper-functions",
    "title": "Complex Covariate Structures in GHRmodel",
    "section": "GHRmodel formula helper functions",
    "text": "GHRmodel formula helper functions\nModel formulas in INLA follow a specific structure. The functions below streamline their construction by generating organized lists of INLA-compatible covariate terms.\n\n\n\n\n\n\n\n\n\nFunction\nPurpose\nInput\nOutput\n\n\n\n\nextract_names()\nSelects covariate names from a dataset\nData frame\nCharacter vector\n\n\ncov_uni()\nPrepares covariates for univariable INLA models\nCharacter vector\nList of linear covariates\n\n\ncov_multi()\nGenerates combinations of covariates for multivariable models.\nCharacter vector or a list of character vectors\nList with INLA nonlinear effect terms\n\n\ncov_nl()\nConvert covariates to nonlinear effect terms, with optional replication.\nCharacter vector or a list of character vectors\nList of multivariable covariate sets\n\n\ncov_interact()\nCreates interaction terms between 2 or 3 covariates (e.g., var1:var2).\nList of character vectors\nList including interaction terms\n\n\ncov_varying()\nCreates spatially or temporally varying effect terms using INLA‚Äôs f() structure.\nCharacter vector or a list of character vectors\nList including spatially/temporally varying terms\n\n\n\nOverview of helper functions to prepare covariate lists for INLA-compatible formulas.\nAfter extracting the potential covariate names from the dataset using extract_names(), functions with the prefix cov_* allow the user to generate lists of covariates to simplify building valid INLA formulas. These functions allow the user to include lagged, nonlinear or more complex covariate structures. Across all of these functions, a common structure is used:\nInput: For functions with the prefix cov_*, the input is a character vector and/or a list of character vectors representing covariate names specified in the covariate argument, with the exception of the extract_names() function, which accepts a data frame as input. The table above summarizes the required input type for each function.\nCovariate selection is done using the arguments:\n\npattern: for partial string matching, selecting groups of covariates that share a common prefix (e.g., ‚Äútmin‚Äù would match ‚Äútmin.l1‚Äù, ‚Äútmin.l2‚Äù, etc.).\nname: for exact matching of covariate names\n\nOutput: is a list of covariates that may be combined or transformed, formatted for INLA formulas. The exception is the extract_names() function, where the output is a character vector.\n\nadd: is a logical flag indicating whether to retain original covariates in addition to transformed or combined ones in the output.\n\nMoving forward, only arguments specific to each function will be described."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_covariates.html#load-libraries",
    "href": "docs/GHRmodel/GHRmodel_covariates.html#load-libraries",
    "title": "Complex Covariate Structures in GHRmodel",
    "section": "Load libraries",
    "text": "Load libraries\n# Load necessary package dependencies\nlibrary(dplyr)        # Data manipulation\nlibrary(tidyr)        # Data tidying\nlibrary(tidyselect)   # Helpers for selecting variables programmatically\nlibrary(rlang)        # Tools for tidy evaluation and non-standard evaluation in tidyverse code\nlibrary(ggplot2)      # Data visualization: creating plots and graphs\nlibrary(cowplot)      # Combining and arranging multiple ggplot2 plots into a single figure\nlibrary(grDevices)    # Base R graphics device functions (e.g., color palettes, saving plots)\nlibrary(RColorBrewer) # Predefined color palettes for plots\nlibrary(colorspace)   # Advanced color space manipulation and palettes\nlibrary(sf)           # Handling spatial vector data (simple features)\nlibrary(spdep)        # Spatial dependence and autocorrelation analysis\nlibrary(sn)           # Skew-normal and skew-t distributions (for modeling skewed data)\nlibrary(INLA)         # Integrated Nested Laplace Approximation for Bayesian models\nlibrary(GHRexplore)   # Exploratory analysis of health data\n\n# Load GHRmodel\nlibrary(GHRmodel)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_covariates.html#data-pre-processing",
    "href": "docs/GHRmodel/GHRmodel_covariates.html#data-pre-processing",
    "title": "Complex Covariate Structures in GHRmodel",
    "section": "Data pre-processing",
    "text": "Data pre-processing\nCreate numeric ID variables for categorical features (such as year, month, or spatial units) that may be included as random effects, in line with R-INLA‚Äôs requirements:\n#Load data \ndata(\"dengue_MS\")\ndf &lt;- dengue_MS\n\n# Create ID variables\ndf &lt;- df |&gt;  \n  # Filter out the year 2000 \n  filter(year &gt; 2000) |&gt;  \n  # Create numeric IDs for year, month and various spatial units.\n  mutate(\n    year_id = as.numeric(as.factor(year)),                # year numeric ID\n    year_id2 = as.numeric(as.factor(year)),               # year second numeric ID\n    month_id = as.numeric(as.factor(month)),              # month numeric ID\n    spat_id = as.numeric(as.factor(micro_code)),          # microregion numeric ID\n    spat_meso_id = as.numeric(as.factor(meso_code)),      # meso-region numeric ID\n    main_climate_f = as.numeric(as.factor(main_climate))  # climate zone numeric ID\n  )"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_covariates.html#spatial-data-and-graphs",
    "href": "docs/GHRmodel/GHRmodel_covariates.html#spatial-data-and-graphs",
    "title": "Complex Covariate Structures in GHRmodel",
    "section": "Spatial data and graphs",
    "text": "Spatial data and graphs\nTo perform spatial analysis, polygon geometries must be provided as an sf object. For the dengue_MS data set, the areal polygons are already included in the package in the map_MS object. In map_MS, the code variable corresponds to the micro_code area identifier in the dengue_MS object.\n# Load map included in package\ndata(\"map_MS\")\n\n# Create adjacency Matrix\nnb &lt;- spdep::poly2nb(map_MS)\ng &lt;- spdep::nb2mat(nb, style = \"B\")"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_covariates.html#pre-process-covariates",
    "href": "docs/GHRmodel/GHRmodel_covariates.html#pre-process-covariates",
    "title": "Complex Covariate Structures in GHRmodel",
    "section": "Pre-process covariates",
    "text": "Pre-process covariates"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_covariates.html#lagged-covariates",
    "href": "docs/GHRmodel/GHRmodel_covariates.html#lagged-covariates",
    "title": "Complex Covariate Structures in GHRmodel",
    "section": "Lagged covariates",
    "text": "Lagged covariates\nHere, we use lag_cov() to generate lagged values for the variables tmin (monthly average daily minimum temperature averaged across each micro-region) and pdsi (Self-calibrated Palmer Drought Severity Index for each micro-region) across 1- to 6-month lags using the lag_cov() function.\ndata &lt;- lag_cov(data = df,\n                name = c(\"tmin\", \"pdsi\"),  # variables to lag \n                time = \"date\",             # time variable \n                lag = c(1:6),              # 1 to 6-month lags\n                group = \"micro_code\",      # identify spatial units with independent time series\n                add = TRUE)                # lagged variables appended to original data\n\n# Visualize lagged variables\nhead(data[34:39])\n#&gt; # A tibble: 6 √ó 6\n#&gt;   tmin.l1 tmin.l2 tmin.l3 tmin.l4 tmin.l5 tmin.l6\n#&gt;     &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n#&gt; 1    NA      NA      NA      NA      NA        NA\n#&gt; 2    23.5    NA      NA      NA      NA        NA\n#&gt; 3    23.3    23.5    NA      NA      NA        NA\n#&gt; 4    22.7    23.3    23.5    NA      NA        NA\n#&gt; 5    21.9    22.7    23.3    23.5    NA        NA\n#&gt; 6    17.8    21.9    22.7    23.3    23.5      NA"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_covariates.html#define-priors",
    "href": "docs/GHRmodel/GHRmodel_covariates.html#define-priors",
    "title": "Complex Covariate Structures in GHRmodel",
    "section": "Define priors",
    "text": "Define priors\nBayesian models require priors to be assigned to parameters that the model will estimate. For more details regarding these prior choices, see GHRmodel_overview. For more details about priors in R-INLA, see this book chapter (G√≥mez-Rubio, 2020).\nThe monthly and yearly random effects are assigned weakly informative Gamma priors on the precision with parameters 0.01 and 0.01 (G√≥mez-Rubio, 2020).\n# Define Gamma priors for the precision of temporal random effects\nprior_t &lt;- list(prec = list(prior = 'loggamma', param = c(0.01, 0.01))) \nThe spatial random effect is specified using the BYM2 model, which facilitates assigning Penalized Complexity (PC) priors to its hyperparameters (Simpson et al., 2017). These priors are conservative and weakly informative, thus allowing the data to drive the inclusion of spatial structure (Moraga, 2019).\n# Define penalized complexity (PC) priors for spatial random effects using BYM2\nprior_sp &lt;- list(\n  prec = list(prior = 'pc.prec', param = c(0.5 / 0.31, 0.01)),  # Precision of spatial effect\n  phi  = list(prior = 'pc', param = c(0.5, 2 / 3))              # Mixing parameter: structured vs unstructured\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_covariates.html#model-development",
    "href": "docs/GHRmodel/GHRmodel_covariates.html#model-development",
    "title": "Complex Covariate Structures in GHRmodel",
    "section": "1. Model development",
    "text": "1. Model development\nIn this example we demonstrate how to use GHRmodel helper functions to streamline writing INLA-compatible formulas.\n\nSelect variables\nUsers can specify which variables from the data set to include as covariates using the extract_names() function.\nHere we select lags 1 through 6 for tmin and pdsi as well as the urban (percentage of inhabitants living in urban areas) and main_climate_f (a factor defining the climate zone) variables.\n# Extract variable names matching the specified patterns\ncov_names &lt;- extract_names(data = data,\n                           pattern = c(\"tmin.\",\n                                       \"pdsi.\", \n                                       \"urban\",\n                                       \"main_climate_f\"))\n# Visualize output: character vector of covariate names\nglimpse(cov_names)\n#&gt;  chr [1:14] \"tmin.l1\" \"tmin.l2\" \"tmin.l3\" \"tmin.l4\" \"tmin.l5\" \"tmin.l6\" \"pdsi.l1\" \"pdsi.l2\" \"pdsi.l3\" \"pdsi.l4\" \"pdsi.l5\" ...\n\n\nLinear covariates\nThe cov_uni() function returns a list where each element contains a single covariate. This structure is suitable for fitting separate univariable models.\n\n# Generate list of single linear covariate names\nuni_cov_lin &lt;- cov_uni(covariates = cov_names, # Input character vector of covariate names\n                       pattern = c(\"pdsi.l\",  # Select lagged pdsi and tmin from the vector of covariate names\n                                    \"tmin.l\"))\n\n# Visualize output: list of single linear covariate names\nhead(uni_cov_lin,2)\n#&gt; [[1]]\n#&gt; [1] \"pdsi.l1\"\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"pdsi.l2\"\n\n\nNon-linear covariates\nTo include nonlinear covariates in the model, the cov_nl() function generates nonlinear effect terms compatible with the INLA formula structure. The nonlinear transformation is defined using three main arguments that are passed into inla.group(), which bins data into groups (G√≥mez-Rubio, 2020):\n\nThe type of nonlinear effect is controlled by the model argument, which supports \"rw1\" (random walk of order 1) or \"rw2\" (random walk of order 2), and defaults to \"rw2\".\nThe method argument allows the user to specify how to discretize the linear covariate. Accepted values are \"cut\" (equal-width intervals) and \"quantile\" (equal-width intervals in the probability space). The default is \"quantile\".\nThe n argument sets the number of basis points (breaks) used to approximate the nonlinear effect and defaults to 10.\n\n\nüí° Tip: Choosing a low n will result in a smoother function (at the risk of underfitting) whereas a high n will lead into a more flexible function (at the risk of overfitting). Make sure to explore and plot your data and check goodness-of-fit metrics to get the best possible fit!\n\n\nüìù Note: In addition to cov_nl, GHRmodel provides the onebasis_inla() function for nonlinear covariate transformations. This function supports natural splines (\"ns\"), B-splines (\"bs\"), polynomial (\"poly\"), and other options from dlnm::onebasis(). For more information about one-basis terms see the Complex Covariate Structures in GHRmodel vignette by typing vignette(\"GHRmodel_covariates\").\n\nHere we transform the 1- to 6-month lagged tmin and pdsi variables into nonlinear terms using a random walk of order 2 (default). We apply 10 breaks to discretize the covariates using method = \"quantile\", which ensures each bin contains a similar number of observations. By setting add = FALSE, the resulting list only includes the transformed variables.\n\n# Generate list of single nonlinear covariate names\nuni_cov_nl &lt;- cov_nl(covariates = cov_names, \n                     method = \"quantile\",\n                     model = \"rw2\",\n                     pattern = c(\"pdsi\", \"tmin\"), \n                     n = 10,\n                     add =FALSE)\n\n# Visualize output: list of single nonlinear covariate names\nhead(uni_cov_nl,2)\n#&gt; [[1]]\n#&gt; [1] \"f(INLA::inla.group(tmin.l1, method='quantile', n=10), model='rw2')\"\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"f(INLA::inla.group(tmin.l2, method='quantile', n=10), model='rw2')\"\n\n\nNon-linear covariates replicated by group\nIf the user wants to replicate the structure of a nonlinear effect across another variable (e.g., administrative unit), the name of the replicating variable should be specified in the replicate argument in cov_nl(). Using this argument, a separate smooth (nonlinear) function will be fitted for each level of the grouping variable, allowing the model to estimate distinct nonlinear effects of the covariate for each group level.\nHere we transform the 1- to 6-month lagged pdsi variables into nonlinear terms using a random walk of order 2 replicated by the main_climate_f variable. This allows the model to estimate distinct nonlinear effects of pdsi for each climate zone, rather than assuming a single, pooled effect across all zones. By setting add = TRUE, the resulting list includes both the original linear terms and their corresponding nonlinear versions.\n# Generate list of replicated nonlinear covariate names\nuni_cov_nl_rep &lt;- cov_nl(covariates = uni_cov_lin, \n                          method = \"quantile\",\n                          pattern = c(\"pdsi\"),\n                          n = 10, \n                          replicate = \"main_climate_f\",\n                          add = TRUE)\n\n# Visualize output: list of replicated nonlinear covariate names\nhead(uni_cov_nl_rep[13:14])\n#&gt; [[1]]\n#&gt; [1] \"f(INLA::inla.group(pdsi.l1, method='quantile', n=10), model='rw2', replicate=main_climate_f)\"\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"f(INLA::inla.group(pdsi.l2, method='quantile', n=10), model='rw2', replicate=main_climate_f)\"\n\n\nCovariates for multivariate models\nThe cov_multi() function takes a character vector or a list of character vectors (e.g., output from cov_uni() or cov_nl()) and generates all possible combinations. This is useful for constructing multivariable models where the user wishes to explore joint effects of different covariates.\nHere we generate all two-way combinations of the nonlinear covariates containing ‚Äútmin‚Äù and ‚Äúpdsi‚Äù listed in the uni_cov_nl_rep object where the lagged pdsi variables were transformed to nonlinear terms replicated by the main_climate_f variable while the lagged tmin variables remained linear. Therefore, the output of the cov_multi() is all possible combinations of replicated nonlinear lagged pdsi variables with linear lagged tmin variables:\n# Create a list of combined predictors, some non linear and replicated\nmulti_cov_nl_rep &lt;- cov_multi(covariates = uni_cov_nl_rep, \n                              pattern =  c(\"pdsi\",\"tmin\"))\n\n# Visualize output: list of replicated nonlinear pdsi lagged terms combined with linear tmin lagged terms\nhead(multi_cov_nl_rep[7:8])\n#&gt; [[1]]\n#&gt; [1] \"f(INLA::inla.group(pdsi.l1, method='quantile', n=10), model='rw2', replicate=main_climate_f)\"\n#&gt; [2] \"tmin.l1\"                                                                                     \n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"f(INLA::inla.group(pdsi.l2, method='quantile', n=10), model='rw2', replicate=main_climate_f)\"\n#&gt; [2] \"tmin.l1\"\n\n\nAdd a covariate to all covariate lists\nThe cov_add() function appends one or more covariate names to each set of covariates in a list. This is useful for stepwise inclusion of covariates in models or to create lists with covariate combinations.\nHere we want to add the covariate urban to combinations of linear lagged tmin and pdsi covariates:\nFirst we generate a list of all combinations of the lagged linear tmin and pdsi covariates using cov_multi() :\n# Generate list of combinations of linear covariate names\nmulti_cov_lin &lt;- cov_multi(covariates = uni_cov_lin,\n                           pattern = c(\"pdsi\",\"tmin\"),\n                           add = FALSE)\n\n# Visualize output: list of combinations of linear covariate names\nhead(multi_cov_lin,2)\n#&gt; [[1]]\n#&gt; [1] \"pdsi.l1\" \"tmin.l1\"\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"pdsi.l2\" \"tmin.l1\"\nThen we add the term urban to each element of the bivariate covariate list using cov_add(), resulting in combinations of three covariates: lagged linear tmin and pdsi plus urban:\n# Add urban to each element of the bivariate covariate list \ntriple_cov_lin &lt;- cov_add(covariates = multi_cov_lin,\n                          name = \"urban\")\n\n# Visualize output: list of combinations of 3 linear covariate names\nhead(triple_cov_lin,2)\n#&gt; [[1]]\n#&gt; [1] \"pdsi.l1\" \"tmin.l1\" \"urban\"  \n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"pdsi.l2\" \"tmin.l1\" \"urban\"\n\n\nInteracting covariates\nInteraction terms capture the additional effect of two (or more) covariates acting together on the outcome, beyond their individual contributions. For example, a recent dengue modeling study in Barbados found that a three-way interaction among long-lag dry conditions (6-month SPI lagged by 5 months), mid-lag hot conditions (3-month temperature anomaly lagged by 3 months), and short-lag wet conditions (6-month SPI lagged by 1 month) best predicted outbreak risk (Fletcher et al., 2025). This result shows how drought, heat, and rainfall at different lags can cascade together, amplifying dengue outbreak likelihood.\nThe function cov_interact creates interaction terms between selected linear covariates. It takes as input a list of covariate combinations (like the output from cov_multi()) and returns interaction terms formatted for use in INLA formulas. If two variables or patterns are selected, it generates all two-way interactions. If three are selected, it generates all pairwise and three-way interactions. Currently GHRmodel only supports interactions between linear terms.\nHere we generate all two-way and three-way interactions of lagged linear tmin and pdsi and urban.\nWe use the covariate list triple_cov_lin (created above using cov_add()) where each element consists of three linear covariates to produce two and three-way interactions\n# Create a list of interacting linear predictors\ninteracting_cov &lt;- cov_interact(covariates = triple_cov_lin,\n                                pattern = c(\"pdsi\",\"tmin\", \"urban\"))\n\n# Visualize output: list of interactions between linear pdsi terms and linear tmin terms\nhead(interacting_cov, 2)\n#&gt; [[1]]\n#&gt; [1] \"pdsi.l1\"               \"tmin.l1\"               \"urban\"                 \"pdsi.l1:tmin.l1\"       \"pdsi.l1:urban\"        \n#&gt; [6] \"tmin.l1:urban\"         \"pdsi.l1:tmin.l1:urban\"\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"pdsi.l2\"               \"tmin.l1\"               \"urban\"                 \"pdsi.l2:tmin.l1\"       \"pdsi.l2:urban\"        \n#&gt; [6] \"tmin.l1:urban\"         \"pdsi.l2:tmin.l1:urban\"\n\n\nVarying covariates\nThe cov_varying() function generates spatially or temporally varying linear effect terms compatible with INLA formulas. It modifies covariate names to the INLA-compatible form f(unit, covariate, model = \"iid\"), where unit is the name of a grouping variable by which the covariate effect will vary (e.g., spat_id or year_id).\nHere we use the multi_cov_lin object (created above) that contains combinations of lagged linear tmin and pdsi covariates. By setting covariates = multi_cov_lin and pattern = \"pdsi\" in the cov_varying() function, we modify only the lagged pdsi variables, to create varying pdsi effects (slopes) per climate zone (by the main_climate_f variable), while leaving the lagged tmin variables unchanged in linear form. The result is a set of covariate combinations pairing climate zone‚Äìspecific lagged pdsi variables with linear lagged tmin:\n# Create a list of varying univariable predictors\nvarying_cov &lt;- cov_varying(covariates = multi_cov_lin,\n                            pattern = c(\"pdsi\"),\n                            unit = \"main_climate_f\")\n\n# Visualize output: list of combinations of lagged pdsi varying by main_climate_f and linear tmin terms\nhead(varying_cov,2)\n#&gt; [[1]]\n#&gt; [1] \"f(main_climate_f, pdsi.l1, model = 'iid', constr = FALSE)\" \"tmin.l1\"                                                  \n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"f(main_climate_f, pdsi.l2, model = 'iid', constr = FALSE)\" \"tmin.l1\"\n\n\nVarying vs.¬†Replicated Effects in INLA\nGHRmodel supports distinct methods to model group-level heterogeneity depending on whether the covariate is linear or nonlinear:\nVarying effects for linear covariates - use cov_varying() to produce f(group, covariate, model = \"iid\"): Different linear slopes across groups. Used when the effect (slope) of a linear covariate is different for each group, without assuming smoothness or shared structure. Think of it as a random slope model: each group gets its own coefficient for a covariate, and these are modeled as independent random effects.\nReplicated effects for nonlinear functions - use the replicate argument in cov_nl() to produce f(INLA::inla.group(covariate,...), model= \"rw2\", replicate = group): Used when the same smooth (nonlinear) functional form (e.g.¬†random walk order 2) is applied separately to different groups. Each level of the group gets its own smooth curve, but the curves share the same structure (e.g., same number of breaks and model), with separate coefficients. An example would be nonlinear functions of mean temperature that are independently repeated across climate zones.\n\n\n\n\n\n\n\n\nFeature\nVarying Effect\nReplicate Effect\n\n\n\n\nApplied to\nLinear terms\nNonlinear terms\n\n\nPurpose\nGroup-specific linear slopes\nGroup-specific nonlinear functions\n\n\nINLA syntax\nf(group, covariate, model = 'iid')\nf(covariate, model = ..., replicate = group)\n\n\nStructure assumption\nUnstructured (iid)\nSame structure (e.g., rw2), different curves\n\n\nExample use\nRegion-specific slopes of the linear effect of rainfall\nRegion-specific nonlinear effect of rainfall\n\n\n\nComparison of Replicate and Varying Effects in INLA\n\n\nWrite INLA-compatible model formulas\nThe write_inla_formulas() function simplifies the creation of multiple INLA models by automatically structuring fixed effects, random effects, and interactions.\n\nDefine covariate combinations\n\nHere we compile a list of covariate combinations previously generated using the cov_* family of functions. Each element in the list corresponds to a distinct model specification, enabling structured comparisons across modeling approaches.\n# Build a combined list of various transformations and combinations of pdsi.l1 \ncov_list &lt;- c(\n  list(\n    uni_cov_lin[[1]],             # [1] pdsi.l1 (linear)\n    uni_cov_nl_rep[[13]],         # [2] pdsi.l1 (nonlinear replicated by 'main_climate_f')\n    multi_cov_lin[[1]],           # [3] pdsi.l1 (linear) + tmin.l1 (linear)\n    triple_cov_lin[[1]],          # [4] pdsi.l1 (linear) + tmin.l1 (linear) + urban (linear)\n    multi_cov_nl_rep[[7]],        # [5] pdsi.l1 (nonlinear replicated by 'main_climate_f') + tmin.l1 (linear)\n    interacting_cov[[1]],         # [6] pdsi.l1, tmin.l1, urban (linear main effects + 2-way & 3-way interactions) \n    varying_cov[[1]]              # [7] pdsi.l1 (linear varying by 'main_climate_f') + tmin.l1 (linear)\n  ),  \n  uni_cov_nl[7:12]                # [8‚Äì13] pdsi.l1 through pdsi.l6 (nonlinear) \n)\n\nWrite model formulas from covariate list\n\nNext, we transform this list of covariates into a vector of INLA-compatible formulas using the write_inla_formulas() function:\nformulas_cov_list &lt;- write_inla_formulas(\n  outcome = \"dengue_cases\",\n  covariates = cov_list,\n  re1 = list(id =\"month_id\",\n             model =\"rw1\", cyclic = TRUE,\n             hyper = \"prior_t\",\n             replicate = \"spat_meso_id\" ),\n  re2 = list(id = \"year_id\",\n             model = \"iid\",\n             hyper = \"prior_t\"),\n  re3 = list(id = \"spat_id\",\n             model = \"bym2\",\n             graph = \"g\", \n             hyper = \"prior_sp\"),\n  baseline = TRUE)\n\n# Example of INLA formula generated\nformulas_cov_list[1]\n#&gt; [1] \"dengue_cases ~ 1 + f(month_id, model = 'rw1', replicate = spat_meso_id, cyclic = TRUE, hyper = prior_t) + f(year_id, model = 'iid', hyper = prior_t) + f(spat_id, model = 'bym2', graph = g, hyper = prior_sp)\"\n\nclass(formulas_cov_list)\n#&gt; [1] \"character\"\n\nConvert model formulas to a GHRformulas object\n\nFinally, we use the as_GHRformulas() function to convert the output from write_inla_formulas() into a standardized GHRformulas object:\nformulas_cov_list_ghr &lt;- as_GHRformulas(formulas = formulas_cov_list)\n\nclass(formulas_cov_list_ghr)\n#&gt; [1] \"GHRformulas\" \"list\""
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_covariates.html#model-fitting",
    "href": "docs/GHRmodel/GHRmodel_covariates.html#model-fitting",
    "title": "Complex Covariate Structures in GHRmodel",
    "section": "2. Model fitting",
    "text": "2. Model fitting\nTo evaluate the performance of multiple covariate model specifications using INLA, we can pass a list of predefined formulas as a GHRformulas object to fit_models(). After fitting, goodness-of-fit metrics can be extracted as a data frame directly through the GHRmodels$mod_gof element.\nThis example demonstrates fitting a set of negative binomial models that include different combinations of covariates constructed using GHRmodel helper functions, with an offset term to account for population at risk.\n\nmodel_cov_list &lt;- fit_models(\n  formulas = formulas_cov_list_ghr,\n  data = data,\n  family = \"nbinomial\",           # Negative binomial likelihood\n  name = \"mod\",                   # Label prefix for each model\n  offset = \"population\",          # Offset variable to account for population size\n  control_compute = list(\n    config = FALSE,               # Do not posterior predictive distribution\n    vcov = FALSE                  # Do not return variance-covariance matrix\n  ),\n  pb = TRUE,                      # Display progress bar\n  nthreads = 8                    # Use 8 threads for parallel computation\n)\n\nclass(model_cov_list)\n\nmodel_cov_list_gof &lt;- model_cov_list$mod_gof"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_covariates.html#model-evaluation",
    "href": "docs/GHRmodel/GHRmodel_covariates.html#model-evaluation",
    "title": "Complex Covariate Structures in GHRmodel",
    "section": "3. Model evaluation",
    "text": "3. Model evaluation\nThis section explains how to interpret the estimated coefficients from the complex covariate structures created above, including:\n\nInteraction effects\nVarying effects for linear covariates\nReplicated effects for nonlinear functions\n\nOutput plots return ggplot2 or cowplot objects that can be further customized by the user.\nFor guidance on evaluating covariates fitted as linear or nonlinear terms, as well as other model assessment tools in the package, see the GHRmodel_overview vignette.\n\nInteraction effects\nplot_coef_lin() can be used to evaluate interaction effects between linear covariates (the only interactions currently supported in GHRmodel).\nIn this plot we observe that there is no significant effect of two or three-way interactions between tmin.l1, pdsi.l1 and urban on dengue cases.\n# Plot linear effects and their interactions\nplot_coef_lin(\n  model = model_cov_list,                      # A list of fitted INLA models\n  mod_id = c(\"mod2\", \"mod4\", \"mod5\", \"mod7\"),  # Select models with linear effects to be plotted\n  # Custom labels for variables (applied only to non-interacting fixed effects)\n  var_label = c(\n    \"tmin.l1\" = \"Min. temp lag 1\",              # Rename 'tmin.l1' to a descriptive label\n    \"pdsi.l1\" = \"PDSI lag 1\",                   # Rename 'pdsi.l1' to a descriptive label\n    \"urban\"   = \"Prop. urban population\"        # Rename 'urban' to a descriptive label\n  ),\n  \n  title = \"Effects of linear and interacting covariates\"  \n  # Title for the plot summarizing what is being visualized\n)\n\n\n\nVarying linear coefficients\nThe plot_coef_varying() function generates a forest plot that visualizes varying coefficients ‚Äî often referred to as random slopes ‚Äî from a fitted GHRmodels object. These varying coefficients reflect how the effect of a covariate differs across different groups (e.g., regions, time points, climate zones) and are structured as f(group, covariate, model = \"iid\") in INLA formulas. Users specify the model ID and the name of the varying coefficient (the covariate corresponding to \"group\" in the formula). Each estimate is plotted along the x-axis, while the corresponding group (often spatial or temporal) units are displayed along the y-axis. The function supports optional customization of unit labels, axis titles, color palettes, and plot title.\nHere we show the four major K√∂ppen-Geiger climate regimes, the letter code they were originally assigned in the data set (main_climate) and the numeric ID they were assigned during data processing (main_climate_f). The variable main_climate_f was used to specify the varying effect:\n\n\n\n\n\n\n\n\nmain_climate_f\nmain_climate\nClimate Zone Description\n\n\n\n\n1\nAF\nTropical Rainforest Climate\n\n\n2\nAM\nTropical Monsoon Climate\n\n\n3\nAW\nTropical Savanna Climate with Dry Winter\n\n\n4\nCFA\nHumid Subtropical Climate\n\n\n\nMain K√∂ppen-Geiger Climate Regimes used in the varying coefficient analysis\nThis plot shows how a linear covariate (pdsi.l1) has different slopes (effects) depending on the climate zone. We observe that the 95% credible interval for the effect of PDSI at one month lag does not contain zero in humid subtropical climates.\n\n# Plot linear slopes varying by climate zone. \nplot_coef_varying(\n  models = model_cov_list, # A list of fitted INLA model objects\n  mod_id = \"mod8\",  # Select the model with varying slopes\n  palette = \"Blues\",   # Color palette for the plot (from RColorBrewer)\n  name = \"main_climate_f\", # The grouping variable (factor) \n  title = \"Effect of PDSI at one-month lag for each climate zone\",  # Plot title\n  ylab = \"Main climate zones\",  # Label for the y-axis (groups/climate zones)\n  unit_label = c( # Map factor levels to descriptive names \n    \"1\" = \"Tropical Rainforest Climate\", \n    \"2\" = \"Tropical Monsoon Climate\", \n    \"3\" = \"Tropical Savanna Climate with Dry Winter\",\n    \"4\" = \"Humid Subtropical Climate\"\n  )\n)\n\n\n\nReplicated nonlinear coefficients\nnonlinear covariates replicated by group can be evaluated with the plot_coef_nl() function. Replicated effects can only be displayed in grid mode (collapse = FALSE), which produces one plot per covariate‚Äìmodel combination, with effects in columns and models in rows. If only one model is provided and both name and pattern are left NULL, all nonlinear effects will be plotted automatically. When multiple models are specified in the mod_id argument, the user must explicitly choose which nonlinear covariates to plot by providing either name or pattern.\nHere we plot 2 models with replicated effects, the nonlinear term of PDSI at one-month lag replicated by climate zone, with and without an additional term for mean minimum temperature at one-month lag. We observe that the effect of wet conditions on dengue cases is strongest in regions 1 and 4, that is Humid Subtropical Climate and Tropical Rainforest Climate, which aligns with the results obtained from structuring PDSI at 1 month lag as a linear effect with a varying slope by climate (see plot above). The effects of pdsi.l1 do not change when a temperature covariate is added.\n# PLot replicated nonlinear effects\nplot_coef_nl(\n  models = model_cov_list, # List of fitted INLA model objects\n  mod_id = c(\"mod3\", \"mod6\"), # Select which models to include in the plot\n  mod_label = c( # Custom display labels for the selected models\n    \"mod3\" = \"pdsi.l1_rep_clim\",    \n    \"mod6\" = \"pdsi.l1_rep_clim + tmin.l1\"\n  ),\n  var_label = c( # Rename variables for clearer axis/legend labels\n    \"pdsi.l1\" = \"PDSI lag 1\"\n  ),\n  name = \"pdsi.l1\", # Variable to plot: nonlinear effect of pdsi.l1\n  title = \"Nonlinear effect of PDSI at one-month lag replicated by main climate\", \n  xlab = \"PDSI\", # X-axis label\n  palette = \"IDE2\", # Color palette for plotting the nonlinear curves\n  collapse = FALSE, # Display results in a grid (one plot per covariate-model pair)\n  rug = FALSE,  # Do not show rug plot for data density along the x-axis\n  histogram = TRUE, # Show histogram of covariate distribution instead of rug plot\n  legend = \"Climate zone\" # Add legend title\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_covariates.html#model-development-1",
    "href": "docs/GHRmodel/GHRmodel_covariates.html#model-development-1",
    "title": "Complex Covariate Structures in GHRmodel",
    "section": "1. Model development",
    "text": "1. Model development\nBelow, we provide a user-defined vector of INLA-compatible model formulas and convert it into a standardized GHRformulas object using the as_GHRformulas() function. This object can then be passed to the fit_models() function for model fitting.\n# Convert list of user-defined INLA formulas into a GHRformulas object \nformulas_user_ghr &lt;- as_GHRformulas(c(\n  \n  # Model 1: random effects only, where monthly random effect is replicated by meso region and the spatial random effect is replicated by year\n    \"dengue_cases ~ 1 +\n     f(month_id, model = 'rw1', replicate = spat_meso_id, cyclic = TRUE, constr = TRUE, hyper = prior_t) +\n     f(year_id, model = 'iid', constr = TRUE, hyper = prior_t) +\n     f(spat_id, model = 'bym2', graph = g, constr = TRUE, hyper = prior_sp, replicate = year_id2)\",\n    \n  # Model 2: random effects and a varying effect for pdsi lag 1 by climate zone\n  \"dengue_cases ~ 1 + f(main_climate_f, pdsi.l1, model = 'iid') +\n     f(month_id, model = 'rw1', replicate = spat_meso_id, cyclic = TRUE, constr = TRUE, hyper = prior_t) +\n     f(year_id, model = 'iid', constr = TRUE, hyper = prior_t) +\n     f(spat_id, model = 'bym2', graph = g, constr = TRUE, hyper = prior_sp, replicate = year_id2)\",\n\n  # Model 3: random effects and a 3-way interaction between different pdsi and tmin lags\n  \"dengue_cases ~ 1 + pdsi.l1 + tmin.l3 + pdsi.l6 + pdsi.l1:tmin.l3:pdsi.l6 +\n     f(month_id, model = 'rw1', replicate = spat_meso_id, cyclic = TRUE, constr = TRUE, hyper = prior_t) +\n     f(year_id, model = 'iid', constr = TRUE, hyper = prior_t) +\n     f(spat_id, model = 'bym2', graph = g, constr = TRUE, hyper = prior_sp, replicate = year_id2)\"\n))\n\n# Visualize output: GHRformulas object\nclass(formulas_user_ghr)\n#&gt; [1] \"GHRformulas\" \"list\""
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_covariates.html#model-fitting-1",
    "href": "docs/GHRmodel/GHRmodel_covariates.html#model-fitting-1",
    "title": "Complex Covariate Structures in GHRmodel",
    "section": "2. Model fitting",
    "text": "2. Model fitting\nFit the user-defined model formulas:\n# User-defined INLA-compatible formulas can be passed into fit_models() as a GHRformulas object\nmodel_user &lt;- fit_models(\n  formulas = formulas_user_ghr,\n  data = data,\n  family = \"nbinomial\",           # Negative binomial likelihood\n  name = \"mod\",                   # Label prefix for each model\n  offset = \"population\",          # Offset variable to account for population size\n  control_compute = list(\n    config = FALSE,               # Do not posterior predictive distribution\n    vcov = FALSE                  # Do not return variance-covariance matrix\n  ),\n  pb = TRUE,                      # Display progress bar\n  nthreads = 8                    # Use 8 threads for parallel computation\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel_covariates.html#model-evaluation-1",
    "href": "docs/GHRmodel/GHRmodel_covariates.html#model-evaluation-1",
    "title": "Complex Covariate Structures in GHRmodel",
    "section": "3. Model evaluation",
    "text": "3. Model evaluation\nThe GHRmodel Overview vignette describes the full set of functions available for model evaluation, which can be applied here to assess model performance.\nFor example we can evaluate the effect of the linear coefficients using plot_coef_lin():\n# Plot any linear coefficients found in the fitted model results. \nplot_coef_lin(\n  model = model_user,              # Provide fitted model GHRmodels object\n  exp = TRUE,                      # Exponentiate coefficients to relative risk scale\n  title = \"Relative Risk (RR)\"     # Plot title\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/dengue_SP.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/dengue_SP.Rd.html",
    "title": "Dengue cases from the ‚ÄúS√£o Paulo‚Äù state of Brazil",
    "section": "",
    "text": "The dengue_SP example data set reports the weekly number of notified dengue cases in the municipality of S√£o Paulo together with climatic covariates. Data was sourced from Infodengue (see @source).\ndengue_SP\n\n\n\nA data frame with 678 rows and 8 columns:\n\ndate: First day of the week, in date format (‚Äú%d-%m-%Y‚Äù)\ngeocode: Unique ID code for S√£o Paulo microregion\ncases: Number of notified dengue cases\nyear: Year 2000 - 2022\ntemp_med: Weekly average daily mean temperature\nprecip_tot: Weekly cumulative precipitation\nenso: El Ni√±o-Southern Oscillation Index\npop: Number of inhabitants\n\n\n\n\nInfodengue API"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/dengue_SP.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/dengue_SP.Rd.html#description",
    "title": "Dengue cases from the ‚ÄúS√£o Paulo‚Äù state of Brazil",
    "section": "",
    "text": "The dengue_SP example data set reports the weekly number of notified dengue cases in the municipality of S√£o Paulo together with climatic covariates. Data was sourced from Infodengue (see @source).\ndengue_SP"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/dengue_SP.Rd.html#format",
    "href": "docs/GHRmodel/GHRmodel-reference/dengue_SP.Rd.html#format",
    "title": "Dengue cases from the ‚ÄúS√£o Paulo‚Äù state of Brazil",
    "section": "",
    "text": "A data frame with 678 rows and 8 columns:\n\ndate: First day of the week, in date format (‚Äú%d-%m-%Y‚Äù)\ngeocode: Unique ID code for S√£o Paulo microregion\ncases: Number of notified dengue cases\nyear: Year 2000 - 2022\ntemp_med: Weekly average daily mean temperature\nprecip_tot: Weekly cumulative precipitation\nenso: El Ni√±o-Southern Oscillation Index\npop: Number of inhabitants"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/dengue_SP.Rd.html#source",
    "href": "docs/GHRmodel/GHRmodel-reference/dengue_SP.Rd.html#source",
    "title": "Dengue cases from the ‚ÄúS√£o Paulo‚Äù state of Brazil",
    "section": "",
    "text": "Infodengue API"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/subset_models.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/subset_models.Rd.html",
    "title": "Subset GHRmodels Objects",
    "section": "",
    "text": "This function subsets selected models from a GHRmodels object into a new reduced GHRmodels object.\nsubset_models(models, mod_id, new_name = NULL)\n\n\n\n\nmodels: A GHRmodels object.\nmod_id: A character vector of model IDs indicating which model(s) to keep. These must match models$mod_gof$model_id.\nnew_name: NULL (default) or a character used to build the new model IDs.\n\n\n\n\nA new GHRmodels object containing only the specified model(s).\n\n\n\nstack_models for combining GHRmodels objects, fit_models for fitting INLA models.\n\n\n\n## Not run:\n\n\n# Load example GHRmodels object from the package: \nmodel_list_file &lt;- system.file(\"examples\", \"model_list.rds\", package = \"GHRmodel\")\nmodel_list &lt;- readRDS(model_list_file)\n\n# Extract a vector with the moded IDs of the 2 best fitting models by WAIC\nbest_waic &lt;- rank_models(\n  models = model_list,  # GHRmodels object containing model fit results\n  metric = \"waic\",      # Metric used to rank models (lower WAIC is better)\n  n = 2                 # Number of top-ranked models to return\n)\n\n# The output is a vector \nbest_waic\n\n# Subset those specific models and assign new IDs\nmodel_waic &lt;- subset_models(\n  model = model_list,\n  mod_id = best_waic,\n  new_name = \"best_waic\"\n)\n\n# Check output subset model names\nmodel_waic$mod_gof$model_id  \n## End(Not run)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/subset_models.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/subset_models.Rd.html#description",
    "title": "Subset GHRmodels Objects",
    "section": "",
    "text": "This function subsets selected models from a GHRmodels object into a new reduced GHRmodels object.\nsubset_models(models, mod_id, new_name = NULL)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/subset_models.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/subset_models.Rd.html#arguments",
    "title": "Subset GHRmodels Objects",
    "section": "",
    "text": "models: A GHRmodels object.\nmod_id: A character vector of model IDs indicating which model(s) to keep. These must match models$mod_gof$model_id.\nnew_name: NULL (default) or a character used to build the new model IDs."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/subset_models.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/subset_models.Rd.html#returns",
    "title": "Subset GHRmodels Objects",
    "section": "",
    "text": "A new GHRmodels object containing only the specified model(s)."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/subset_models.Rd.html#see-also",
    "href": "docs/GHRmodel/GHRmodel-reference/subset_models.Rd.html#see-also",
    "title": "Subset GHRmodels Objects",
    "section": "",
    "text": "stack_models for combining GHRmodels objects, fit_models for fitting INLA models."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/subset_models.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/subset_models.Rd.html#examples",
    "title": "Subset GHRmodels Objects",
    "section": "",
    "text": "## Not run:\n\n\n# Load example GHRmodels object from the package: \nmodel_list_file &lt;- system.file(\"examples\", \"model_list.rds\", package = \"GHRmodel\")\nmodel_list &lt;- readRDS(model_list_file)\n\n# Extract a vector with the moded IDs of the 2 best fitting models by WAIC\nbest_waic &lt;- rank_models(\n  models = model_list,  # GHRmodels object containing model fit results\n  metric = \"waic\",      # Metric used to rank models (lower WAIC is better)\n  n = 2                 # Number of top-ranked models to return\n)\n\n# The output is a vector \nbest_waic\n\n# Subset those specific models and assign new IDs\nmodel_waic &lt;- subset_models(\n  model = model_list,\n  mod_id = best_waic,\n  new_name = \"best_waic\"\n)\n\n# Check output subset model names\nmodel_waic$mod_gof$model_id  \n## End(Not run)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/dengue_MS.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/dengue_MS.Rd.html",
    "title": "Dengue cases from the ‚ÄúMato Grosso do Sul‚Äù state of Brazil",
    "section": "",
    "text": "The dengue_MS example data set contains monthly counts of notified dengue cases by microregion, along with a range of spatial and spatiotemporal covariates (e.g., environmental, socio-economic and meteo-climatic factors). This data set represents a subset of a larger national data set that covers the entire territory of Brazil. The subset focuses on a specific region, Mato Grosso do Sul, for the purposes of illustration and computational efficiency. See @source for access to the complete data set.\ndengue_MS\n\n\n\nA data frame with 2,600 rows and 27 columns:\n\nmicro_code: Unique ID number to each micro region (11 units)\nmicro_name: Name of each micro region\nmicro_name_ibge: Name of each micro region following IBGE\nmeso_code: Unique ID number to each meso region (4 units)\nmeso_name: Name of each meso region\nstate_code: Unique ID number to each state (1 unit)\nstate_name: Name of each state\nregion_code: Unique ID number given to each Brazilian Region, In this data frame all observations come from the ‚ÄúSoutheast Region‚Äù\nregion_name: Name of each Brazilian Region, In this data frame all observations come from the ‚ÄúSoutheast Region‚Äù\nbiome_code: Biome code\nbiome_name: Biome name\necozone_code: Ecozone code\necozone_name: Ecozone name\nmain_climate: Most prevalent climate regime in the microregion. Based on Koppen Geiger climate regimes\nmonth: Calendar month index, 1 = January, 12 = December\nyear: Year 2000 - 2019\ntime: Time index starting at 1 for January 2000\ndengue_cases: Number of notified dengue cases registered in the notifiable diseases system in Brazil (SINAN) in the microregion of reference, at the month of first symptoms\npopulation: Estimated population, based on projections calculated using the 2000 and 2010 censuses, and counts taken in 2007 and 2017\npop_density: Population density (number of people per km2)\ntmax: Monthly average daily maximum temperature; gridded values (at a 0.5 deg resolution) averaged across each microregion\ntmin: Monthly average daily minimum temperature; gridded values (at a 0.5 deg resolution) averaged across each microregion\npdsi: Self-calibrated Palmer drought severity index for each microregion. It measures how wet or dry a region is relative to usual conditions. Negative values represent periods of drought, positive values represent wetter periods. Calculated by taking the mean value within each microregion\nurban: Percentage of inhabitants living in urban areas (2010 census)\nwater_network: Percentage of inhabitants with access to the piped water network according to the 2010 census\nwater_shortage: Frequency of reported water shortages per microregion between 2000 - 2016\ndate: First day of the Month, in date format (‚Äú%d-%m-%Y‚Äù)\n\n\n\n\nsource code on GitHub; source code on Zenodo);"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/dengue_MS.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/dengue_MS.Rd.html#description",
    "title": "Dengue cases from the ‚ÄúMato Grosso do Sul‚Äù state of Brazil",
    "section": "",
    "text": "The dengue_MS example data set contains monthly counts of notified dengue cases by microregion, along with a range of spatial and spatiotemporal covariates (e.g., environmental, socio-economic and meteo-climatic factors). This data set represents a subset of a larger national data set that covers the entire territory of Brazil. The subset focuses on a specific region, Mato Grosso do Sul, for the purposes of illustration and computational efficiency. See @source for access to the complete data set.\ndengue_MS"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/dengue_MS.Rd.html#format",
    "href": "docs/GHRmodel/GHRmodel-reference/dengue_MS.Rd.html#format",
    "title": "Dengue cases from the ‚ÄúMato Grosso do Sul‚Äù state of Brazil",
    "section": "",
    "text": "A data frame with 2,600 rows and 27 columns:\n\nmicro_code: Unique ID number to each micro region (11 units)\nmicro_name: Name of each micro region\nmicro_name_ibge: Name of each micro region following IBGE\nmeso_code: Unique ID number to each meso region (4 units)\nmeso_name: Name of each meso region\nstate_code: Unique ID number to each state (1 unit)\nstate_name: Name of each state\nregion_code: Unique ID number given to each Brazilian Region, In this data frame all observations come from the ‚ÄúSoutheast Region‚Äù\nregion_name: Name of each Brazilian Region, In this data frame all observations come from the ‚ÄúSoutheast Region‚Äù\nbiome_code: Biome code\nbiome_name: Biome name\necozone_code: Ecozone code\necozone_name: Ecozone name\nmain_climate: Most prevalent climate regime in the microregion. Based on Koppen Geiger climate regimes\nmonth: Calendar month index, 1 = January, 12 = December\nyear: Year 2000 - 2019\ntime: Time index starting at 1 for January 2000\ndengue_cases: Number of notified dengue cases registered in the notifiable diseases system in Brazil (SINAN) in the microregion of reference, at the month of first symptoms\npopulation: Estimated population, based on projections calculated using the 2000 and 2010 censuses, and counts taken in 2007 and 2017\npop_density: Population density (number of people per km2)\ntmax: Monthly average daily maximum temperature; gridded values (at a 0.5 deg resolution) averaged across each microregion\ntmin: Monthly average daily minimum temperature; gridded values (at a 0.5 deg resolution) averaged across each microregion\npdsi: Self-calibrated Palmer drought severity index for each microregion. It measures how wet or dry a region is relative to usual conditions. Negative values represent periods of drought, positive values represent wetter periods. Calculated by taking the mean value within each microregion\nurban: Percentage of inhabitants living in urban areas (2010 census)\nwater_network: Percentage of inhabitants with access to the piped water network according to the 2010 census\nwater_shortage: Frequency of reported water shortages per microregion between 2000 - 2016\ndate: First day of the Month, in date format (‚Äú%d-%m-%Y‚Äù)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/dengue_MS.Rd.html#source",
    "href": "docs/GHRmodel/GHRmodel-reference/dengue_MS.Rd.html#source",
    "title": "Dengue cases from the ‚ÄúMato Grosso do Sul‚Äù state of Brazil",
    "section": "",
    "text": "source code on GitHub; source code on Zenodo);"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/get_covariates.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/get_covariates.Rd.html",
    "title": "Retrieve Covariates from a GHRmodels Object as a List of Character Vectors",
    "section": "",
    "text": "Extracts covariates from a GHRmodels object and returns them as a list of character vectors. If unique = TRUE, the output contains unique covariates across models. If unique = FALSE, the output preserves the original combinations of covariates as specified in the GHRmodels object.\nget_covariates(model, unique = TRUE)\n\n\n\n\nmodel: A GHRmodels object containing fitted models.\nunique: Logical; if TRUE, returns unique covariates across models. If FALSE, returns vectors of covariate combinations as declared in the GHRmodels object.\n\n\n\n\nA list of character vectors.\n\n\n\n## Not run:\n\n# Load example dataset\ndata(dengueMS)\n\n# Declare formulas\nformulas &lt;- c(\n  \"dengue_cases ~ tmin +  f(year, model='rw1')\",\n  \"dengue_cases ~ pdsi +  f(year, model='rw1')\"\n)\n\n# Tranform formulas into a 'GHRformulas' object\nghr_formulas &lt;- as_GHRformulas(formulas)\n\n# Fit multiple models \nresults &lt;- fit_models(\n  formulas = ghr_formulas,\n  data     = dengue_MS,\n  family   = \"nbinomial\",\n  name     = \"TestModel\",\n  offset   = \"population\",\nnthreads = 2,\ncontrol_compute = list(config = FALSE),\npb       = TRUE\n)\n\n# Extract the list of covariates from the models \nget_covariates(results)\n## End(Not run)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/get_covariates.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/get_covariates.Rd.html#description",
    "title": "Retrieve Covariates from a GHRmodels Object as a List of Character Vectors",
    "section": "",
    "text": "Extracts covariates from a GHRmodels object and returns them as a list of character vectors. If unique = TRUE, the output contains unique covariates across models. If unique = FALSE, the output preserves the original combinations of covariates as specified in the GHRmodels object.\nget_covariates(model, unique = TRUE)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/get_covariates.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/get_covariates.Rd.html#arguments",
    "title": "Retrieve Covariates from a GHRmodels Object as a List of Character Vectors",
    "section": "",
    "text": "model: A GHRmodels object containing fitted models.\nunique: Logical; if TRUE, returns unique covariates across models. If FALSE, returns vectors of covariate combinations as declared in the GHRmodels object."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/get_covariates.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/get_covariates.Rd.html#returns",
    "title": "Retrieve Covariates from a GHRmodels Object as a List of Character Vectors",
    "section": "",
    "text": "A list of character vectors."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/get_covariates.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/get_covariates.Rd.html#examples",
    "title": "Retrieve Covariates from a GHRmodels Object as a List of Character Vectors",
    "section": "",
    "text": "## Not run:\n\n# Load example dataset\ndata(dengueMS)\n\n# Declare formulas\nformulas &lt;- c(\n  \"dengue_cases ~ tmin +  f(year, model='rw1')\",\n  \"dengue_cases ~ pdsi +  f(year, model='rw1')\"\n)\n\n# Tranform formulas into a 'GHRformulas' object\nghr_formulas &lt;- as_GHRformulas(formulas)\n\n# Fit multiple models \nresults &lt;- fit_models(\n  formulas = ghr_formulas,\n  data     = dengue_MS,\n  family   = \"nbinomial\",\n  name     = \"TestModel\",\n  offset   = \"population\",\nnthreads = 2,\ncontrol_compute = list(config = FALSE),\npb       = TRUE\n)\n\n# Extract the list of covariates from the models \nget_covariates(results)\n## End(Not run)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/onebasis_inla.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/onebasis_inla.Rd.html",
    "title": "Create a One-Dimensional Basis for INLA",
    "section": "",
    "text": "This function is a wrapper around onebasis to create a one-dimensional basis for spline modeling. This wrapper enhances the original function by allowing users to specify a custom prefix for the column names using the basis_name argument, such that each set of basis variables can be easily identified in the model formula by the INLA framework.\nonebasis_inla(covariate, fun, basis_name, ...)\n\n\n\n\ncovariate: A numeric vector representing the covariate\nfun: A character string specifying the shape function to be used by onebasis.\nbasis_name: A character string giving a base name for the columns in the resulting basis matrix. The default prefix (usually \"b\") is replaced by this string.\n...: Additional arguments passed to onebasis, such as degree, df, knots, etc.\n\n\n\n\nAn object of class \"onebasis\", as returned by onebasis, with column names modified according to basis_name.\n\n\n\n# Import example data set\ndata(\"dengue_MS\")\n\n# Build a one-dimensional spline basis with a custom name\nob_inla &lt;- onebasis_inla(\n covariate = dengue_MS$tmin,\n fun = \"bs\",\n basis_name = \"tempBasis\",\n degree = 2\n)\n\n# Check class of the one-basis object\nclass(ob_inla)\n\n# View first rows of the one-basis matrix\nhead(ob_inla)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/onebasis_inla.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/onebasis_inla.Rd.html#description",
    "title": "Create a One-Dimensional Basis for INLA",
    "section": "",
    "text": "This function is a wrapper around onebasis to create a one-dimensional basis for spline modeling. This wrapper enhances the original function by allowing users to specify a custom prefix for the column names using the basis_name argument, such that each set of basis variables can be easily identified in the model formula by the INLA framework.\nonebasis_inla(covariate, fun, basis_name, ...)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/onebasis_inla.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/onebasis_inla.Rd.html#arguments",
    "title": "Create a One-Dimensional Basis for INLA",
    "section": "",
    "text": "covariate: A numeric vector representing the covariate\nfun: A character string specifying the shape function to be used by onebasis.\nbasis_name: A character string giving a base name for the columns in the resulting basis matrix. The default prefix (usually \"b\") is replaced by this string.\n...: Additional arguments passed to onebasis, such as degree, df, knots, etc."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/onebasis_inla.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/onebasis_inla.Rd.html#returns",
    "title": "Create a One-Dimensional Basis for INLA",
    "section": "",
    "text": "An object of class \"onebasis\", as returned by onebasis, with column names modified according to basis_name."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/onebasis_inla.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/onebasis_inla.Rd.html#examples",
    "title": "Create a One-Dimensional Basis for INLA",
    "section": "",
    "text": "# Import example data set\ndata(\"dengue_MS\")\n\n# Build a one-dimensional spline basis with a custom name\nob_inla &lt;- onebasis_inla(\n covariate = dengue_MS$tmin,\n fun = \"bs\",\n basis_name = \"tempBasis\",\n degree = 2\n)\n\n# Check class of the one-basis object\nclass(ob_inla)\n\n# View first rows of the one-basis matrix\nhead(ob_inla)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_add.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_add.Rd.html",
    "title": "Add Covariates to All Combinations",
    "section": "",
    "text": "This function appends one or more covariate names to all elements (i.e., covariate sets) in a list of character vectors. This is useful when a covariate (like a confounder or control variable) needs to be included in every model. It also works with a single character vector input. The resulting list can be input into the covariates argument in write_inla_formulas.\ncov_add(covariates, name, add = FALSE)\n\n\n\n\ncovariates: A character vector or a list of character vectors, where each vector represents a set of covariates (e.g., from cov_multi).\nname: A character vector of covariate names to be added to each set.\nadd: Boolean that indicates if the original combinations in the covariates argument must be kept. Defaults to FALSE.\n\n\n\n\nA list of character vectors, with each vector containing the original covariates plus the additional ones specified in the name argument.\n\n\n\n# Multiple combinations\ncov_sets &lt;- list(\n  c(\"tmin\", \"pdsi\"),\n  c(\"tmin.l1\", \"pdsi\"),\n  c(\"tmin.l2\", \"pdsi\")\n)\ncov_add(cov_sets, name = \"urban\")"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_add.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_add.Rd.html#description",
    "title": "Add Covariates to All Combinations",
    "section": "",
    "text": "This function appends one or more covariate names to all elements (i.e., covariate sets) in a list of character vectors. This is useful when a covariate (like a confounder or control variable) needs to be included in every model. It also works with a single character vector input. The resulting list can be input into the covariates argument in write_inla_formulas.\ncov_add(covariates, name, add = FALSE)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_add.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_add.Rd.html#arguments",
    "title": "Add Covariates to All Combinations",
    "section": "",
    "text": "covariates: A character vector or a list of character vectors, where each vector represents a set of covariates (e.g., from cov_multi).\nname: A character vector of covariate names to be added to each set.\nadd: Boolean that indicates if the original combinations in the covariates argument must be kept. Defaults to FALSE."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_add.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_add.Rd.html#returns",
    "title": "Add Covariates to All Combinations",
    "section": "",
    "text": "A list of character vectors, with each vector containing the original covariates plus the additional ones specified in the name argument."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_add.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_add.Rd.html#examples",
    "title": "Add Covariates to All Combinations",
    "section": "",
    "text": "# Multiple combinations\ncov_sets &lt;- list(\n  c(\"tmin\", \"pdsi\"),\n  c(\"tmin.l1\", \"pdsi\"),\n  c(\"tmin.l2\", \"pdsi\")\n)\ncov_add(cov_sets, name = \"urban\")"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_nl.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_nl.Rd.html",
    "title": "Create Non-Linear Effects for INLA",
    "section": "",
    "text": "This function transforms selected covariates identified by pattern or name into non-linear terms using INLA‚Äôs f() syntax. It supports random walk models (rw1, rw2) and allows discretization by quantiles or equal intervals. Transformed covariates are returned as character vectors inside a list ready to be passed to the write_inla_formulas function.\ncov_nl(\n  covariates,\n  pattern = NULL,\n  name = NULL,\n  model = \"rw2\",\n  method = \"quantile\",\n  n = 10,\n  replicate = NULL,\n  add = FALSE\n)\n\n\n\n\ncovariates: A character vector or list of character vectors. Usually from cov_multi or cov_uni.\npattern: Character vector of patterns to match covariates for transformation (e.g., ‚Äútmin‚Äù matches ‚Äútmin‚Äù, ‚Äútmin.l1‚Äù, etc.).\nname: Character vector of exact covariate names to transform.\nmodel: Character; either \"rw1\" or \"rw2\" to specify the non-linear INLA model.\nmethod: Character; either \"cut\" or \"quantile\" for discretization. Default is \"quantile\".\nn: Integer; number of intervals or quantile bins. Must be &gt;= 2. Default is 10.\nreplicate: Optional character string indicating a replicate structure for non-linear effects.\nadd: Logical; if TRUE, adds the transformed covariates to the original ones. Default is FALSE.\n\n\n\n\n\nUse pattern or name (or both) to specify which variables to transform.\nThe method and n arguments discretize the covariate into evenly populated bins.\nThe function supports discretization with either equal-width (cut) or quantile-based (quantile) bins.\nThe model argument imposes smoothness on the grouped effect, capturing non-linear trends.\nNon-linear effects are created using .single_non_linear_eff_inla() (internal helper).\n\n\n\n\nA list of character vectors. This object can be passed to the covariates argument in write_inla_formulas.\n\n\n\nSee Bayesian inference with INLA: Smoothing\nfor more information on smoothing and non-linear effects in R-INLA models.\n\n\n\ndata &lt;- data.frame(tmin.l1 = rnorm(10), pdsi.l1 = rnorm(10))\n\ncovs &lt;- extract_names(data, pattern = c(\"tmin\", \"pdsi\"))\ncovlist &lt;- cov_multi(covs, pattern = c(\"tmin\", \"pdsi\"))\n\n# Apply non-linear transformation to tmin variables\ncov_nl(covlist, pattern = \"tmin\", model = \"rw2\")\n\n# Include original variables along with transformed ones\ncov_nl(covlist, pattern = \"tmin\", model = \"rw2\", add = TRUE)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_nl.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_nl.Rd.html#description",
    "title": "Create Non-Linear Effects for INLA",
    "section": "",
    "text": "This function transforms selected covariates identified by pattern or name into non-linear terms using INLA‚Äôs f() syntax. It supports random walk models (rw1, rw2) and allows discretization by quantiles or equal intervals. Transformed covariates are returned as character vectors inside a list ready to be passed to the write_inla_formulas function.\ncov_nl(\n  covariates,\n  pattern = NULL,\n  name = NULL,\n  model = \"rw2\",\n  method = \"quantile\",\n  n = 10,\n  replicate = NULL,\n  add = FALSE\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_nl.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_nl.Rd.html#arguments",
    "title": "Create Non-Linear Effects for INLA",
    "section": "",
    "text": "covariates: A character vector or list of character vectors. Usually from cov_multi or cov_uni.\npattern: Character vector of patterns to match covariates for transformation (e.g., ‚Äútmin‚Äù matches ‚Äútmin‚Äù, ‚Äútmin.l1‚Äù, etc.).\nname: Character vector of exact covariate names to transform.\nmodel: Character; either \"rw1\" or \"rw2\" to specify the non-linear INLA model.\nmethod: Character; either \"cut\" or \"quantile\" for discretization. Default is \"quantile\".\nn: Integer; number of intervals or quantile bins. Must be &gt;= 2. Default is 10.\nreplicate: Optional character string indicating a replicate structure for non-linear effects.\nadd: Logical; if TRUE, adds the transformed covariates to the original ones. Default is FALSE."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_nl.Rd.html#details",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_nl.Rd.html#details",
    "title": "Create Non-Linear Effects for INLA",
    "section": "",
    "text": "Use pattern or name (or both) to specify which variables to transform.\nThe method and n arguments discretize the covariate into evenly populated bins.\nThe function supports discretization with either equal-width (cut) or quantile-based (quantile) bins.\nThe model argument imposes smoothness on the grouped effect, capturing non-linear trends.\nNon-linear effects are created using .single_non_linear_eff_inla() (internal helper)."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_nl.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_nl.Rd.html#returns",
    "title": "Create Non-Linear Effects for INLA",
    "section": "",
    "text": "A list of character vectors. This object can be passed to the covariates argument in write_inla_formulas."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_nl.Rd.html#see-also",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_nl.Rd.html#see-also",
    "title": "Create Non-Linear Effects for INLA",
    "section": "",
    "text": "See Bayesian inference with INLA: Smoothing\nfor more information on smoothing and non-linear effects in R-INLA models."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_nl.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_nl.Rd.html#examples",
    "title": "Create Non-Linear Effects for INLA",
    "section": "",
    "text": "data &lt;- data.frame(tmin.l1 = rnorm(10), pdsi.l1 = rnorm(10))\n\ncovs &lt;- extract_names(data, pattern = c(\"tmin\", \"pdsi\"))\ncovlist &lt;- cov_multi(covs, pattern = c(\"tmin\", \"pdsi\"))\n\n# Apply non-linear transformation to tmin variables\ncov_nl(covlist, pattern = \"tmin\", model = \"rw2\")\n\n# Include original variables along with transformed ones\ncov_nl(covlist, pattern = \"tmin\", model = \"rw2\", add = TRUE)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_uni.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_uni.Rd.html",
    "title": "Build Univariable Covariate Sets",
    "section": "",
    "text": "This function returns a list where each element contains a single covariate, based on covariates specified in the pattern or name arguments. This structure is suitable for generating separate univariable model formulas using write_inla_formulas.\ncov_uni(covariates = NULL, pattern = NULL, name = NULL)\n\n\n\n\ncovariates: A character vector of covariate names. Typically the output from extract_names.\npattern: A character vector specifying the prefix pattern(s) to match (e.g., ‚Äútmin‚Äù matches ‚Äútmin‚Äù, ‚Äútmin.l1‚Äù, etc.).\nname: A character vector specifying exact variable name(s) to extract.\n\n\n\n\nA list of character vectors, each of length 1, containing the matched covariate name. The resulting list is suitable for use as the covariates argument in write_inla_formulas.\n\n\n\ndata &lt;- data.frame(tmin = rnorm(10), tmin.l1 = rnorm(10), urban = rnorm(10))\ncovs &lt;- extract_names(data, pattern = \"tmin\", name = \"urban\")\ncov_uni(covs, pattern = \"tmin\")\ncov_uni(covs, name = \"urban\")"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_uni.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_uni.Rd.html#description",
    "title": "Build Univariable Covariate Sets",
    "section": "",
    "text": "This function returns a list where each element contains a single covariate, based on covariates specified in the pattern or name arguments. This structure is suitable for generating separate univariable model formulas using write_inla_formulas.\ncov_uni(covariates = NULL, pattern = NULL, name = NULL)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_uni.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_uni.Rd.html#arguments",
    "title": "Build Univariable Covariate Sets",
    "section": "",
    "text": "covariates: A character vector of covariate names. Typically the output from extract_names.\npattern: A character vector specifying the prefix pattern(s) to match (e.g., ‚Äútmin‚Äù matches ‚Äútmin‚Äù, ‚Äútmin.l1‚Äù, etc.).\nname: A character vector specifying exact variable name(s) to extract."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_uni.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_uni.Rd.html#returns",
    "title": "Build Univariable Covariate Sets",
    "section": "",
    "text": "A list of character vectors, each of length 1, containing the matched covariate name. The resulting list is suitable for use as the covariates argument in write_inla_formulas."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_uni.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_uni.Rd.html#examples",
    "title": "Build Univariable Covariate Sets",
    "section": "",
    "text": "data &lt;- data.frame(tmin = rnorm(10), tmin.l1 = rnorm(10), urban = rnorm(10))\ncovs &lt;- extract_names(data, pattern = \"tmin\", name = \"urban\")\ncov_uni(covs, pattern = \"tmin\")\ncov_uni(covs, name = \"urban\")"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_coef_nl.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_coef_nl.Rd.html",
    "title": "Plot Nonlinear Effects from a GHRmodels Object",
    "section": "",
    "text": "Generates plots of nonlinear effects from one or more fitted models contained within a GHRmodels object. The function supports two main display modes:\n\nGrid (when collapse = FALSE): one plot per covariate and model, with effects by column and models by row.\n\nIf multiple models are specified, the user must provide either name or pattern to select which nonlinear effects to plot.\nIf only one model is selected and both name and pattern are NULL, all nonlinear effects in the model will be plotted.\n\nCollapsed (when collapse = TRUE): one non-linear effect combined across models into a single panel.\n\nThe user must explicitly specify the exact variable name using name. It only accepts one covariate name.\nCollapse mode can only be used when the selected effect is not replicated (that is, does not have the format f(covariate, model = ..., replicate = group)) If replication is detected, an error will be thrown.\n\n\nplot_coef_nl(\n  models,\n  mod_id,\n  mod_label = NULL,\n  name = NULL,\n  pattern = NULL,\n  title = NULL,\n  var_label = NULL,\n  palette = \"IDE2\",\n  xlim = NULL,\n  ylab = NULL,\n  xlab = NULL,\n  histogram = FALSE,\n  legend = NULL,\n  hist_fill = \"grey\",\n  rug = FALSE,\n  collapse = FALSE,\n  exp = FALSE\n)\n\n\n\n\nmodels: A GHRmodels object containing fitted model outputs.\nmod_id: Integer vector specifying which model(s) to plot (as indexed in model$models).\nmod_label: An optional named character vector mapping model names to custom labels, e.g.¬†c(‚Äúmod1‚Äù = ‚ÄúModel 1‚Äù). Any model not found in the vector names retains its original label.\nname: Optional character vector of variable names (as used in inla.group(...)) to select specific nonlinear effects. Required for collapse mode.\npattern: Optional regular expression pattern to match effect names. Used to select nonlinear effects when name is not provided.\ntitle: Optional overall title for the plot.\nvar_label: Optional named character vector providing custom labels for each nonlinear variable. Names must match the variable names (e.g., used in inla.group(x)), not full effect names.\npalette: Name of the color palette to use (passed to GHR_palette). Default is \"IDE2\".\nxlim: Optional named list specifying x-axis limits for each effect. Each element should be a numeric vector of length 2: list(var1 = c(min, max), var2 = c(min, max)). Variable names must match those used in inla.group().\nylab: Optional y-axis label. If NULL, defaults to \"Effect size\".\nxlab: Optional x-axis label. If NULL, defaults to \"&lt;variable&gt; values\". If explicitly set to NULL, no x-axis label will be shown.\nhistogram: Logical; if TRUE (default), includes a histogram below each partial-effect plot.\nlegend: Legend title for the replicate color scale (if multi-replicate effects are present). Default is \"Replicate\".\nhist_fill: Fill color for histogram bars. Default is \"grey\".\nrug: Include a rug plot in the x-axis. Default is FALSE.\ncollapse: Logical; if TRUE, attempts to collapse plots across models to show one plot per variable. This requires that selected nonlinear effect is not replicated (i.e.¬†the covariate is not in the format f(covariate, model = ‚Ä¶, replicate = group))\nexp: Logical,if TRUE the coefficients are exponentiated, Default is if FALSE.\n\n\n\n\nA ggplot or cowplot object, depending on the plotting mode.\n\n\n\n## Not run:\n\n\n# Load example GHRmodels object from the package: \nmodel_list_file &lt;- system.file(\"examples\", \"model_list.rds\", package = \"GHRmodel\")\nmodel_list &lt;- readRDS(model_list_file)\n\n# Plot 2 models with a non-linear term of PDSI at one month lag in collapsed mode: \nplot_coef_nl(\nmodels = model_list,\nmod_id = c( \"mod5\", \"mod6\") ,\nmod_label = c(\"mod6\" = \"pdsi.l1_nl\",\n              \"mod5\" = \"pdsi.l1_nl + tmin.l1_nl\"),\nvar_label = c(\"pdsi.l1\" = \"Drought index (PDSI)\"),\nname = c(\"pdsi.l1\"),\ntitle = \"Change in non-linear term for drought index (PDSI)\nwith and without mean min. temp lag 1\",\nxlab = \"PDSI\",\npalette = \"IDE2\",\ncollapse = TRUE    \n)\n## End(Not run)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_coef_nl.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_coef_nl.Rd.html#description",
    "title": "Plot Nonlinear Effects from a GHRmodels Object",
    "section": "",
    "text": "Generates plots of nonlinear effects from one or more fitted models contained within a GHRmodels object. The function supports two main display modes:\n\nGrid (when collapse = FALSE): one plot per covariate and model, with effects by column and models by row.\n\nIf multiple models are specified, the user must provide either name or pattern to select which nonlinear effects to plot.\nIf only one model is selected and both name and pattern are NULL, all nonlinear effects in the model will be plotted.\n\nCollapsed (when collapse = TRUE): one non-linear effect combined across models into a single panel.\n\nThe user must explicitly specify the exact variable name using name. It only accepts one covariate name.\nCollapse mode can only be used when the selected effect is not replicated (that is, does not have the format f(covariate, model = ..., replicate = group)) If replication is detected, an error will be thrown.\n\n\nplot_coef_nl(\n  models,\n  mod_id,\n  mod_label = NULL,\n  name = NULL,\n  pattern = NULL,\n  title = NULL,\n  var_label = NULL,\n  palette = \"IDE2\",\n  xlim = NULL,\n  ylab = NULL,\n  xlab = NULL,\n  histogram = FALSE,\n  legend = NULL,\n  hist_fill = \"grey\",\n  rug = FALSE,\n  collapse = FALSE,\n  exp = FALSE\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_coef_nl.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_coef_nl.Rd.html#arguments",
    "title": "Plot Nonlinear Effects from a GHRmodels Object",
    "section": "",
    "text": "models: A GHRmodels object containing fitted model outputs.\nmod_id: Integer vector specifying which model(s) to plot (as indexed in model$models).\nmod_label: An optional named character vector mapping model names to custom labels, e.g.¬†c(‚Äúmod1‚Äù = ‚ÄúModel 1‚Äù). Any model not found in the vector names retains its original label.\nname: Optional character vector of variable names (as used in inla.group(...)) to select specific nonlinear effects. Required for collapse mode.\npattern: Optional regular expression pattern to match effect names. Used to select nonlinear effects when name is not provided.\ntitle: Optional overall title for the plot.\nvar_label: Optional named character vector providing custom labels for each nonlinear variable. Names must match the variable names (e.g., used in inla.group(x)), not full effect names.\npalette: Name of the color palette to use (passed to GHR_palette). Default is \"IDE2\".\nxlim: Optional named list specifying x-axis limits for each effect. Each element should be a numeric vector of length 2: list(var1 = c(min, max), var2 = c(min, max)). Variable names must match those used in inla.group().\nylab: Optional y-axis label. If NULL, defaults to \"Effect size\".\nxlab: Optional x-axis label. If NULL, defaults to \"&lt;variable&gt; values\". If explicitly set to NULL, no x-axis label will be shown.\nhistogram: Logical; if TRUE (default), includes a histogram below each partial-effect plot.\nlegend: Legend title for the replicate color scale (if multi-replicate effects are present). Default is \"Replicate\".\nhist_fill: Fill color for histogram bars. Default is \"grey\".\nrug: Include a rug plot in the x-axis. Default is FALSE.\ncollapse: Logical; if TRUE, attempts to collapse plots across models to show one plot per variable. This requires that selected nonlinear effect is not replicated (i.e.¬†the covariate is not in the format f(covariate, model = ‚Ä¶, replicate = group))\nexp: Logical,if TRUE the coefficients are exponentiated, Default is if FALSE."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_coef_nl.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_coef_nl.Rd.html#returns",
    "title": "Plot Nonlinear Effects from a GHRmodels Object",
    "section": "",
    "text": "A ggplot or cowplot object, depending on the plotting mode."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_coef_nl.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_coef_nl.Rd.html#examples",
    "title": "Plot Nonlinear Effects from a GHRmodels Object",
    "section": "",
    "text": "## Not run:\n\n\n# Load example GHRmodels object from the package: \nmodel_list_file &lt;- system.file(\"examples\", \"model_list.rds\", package = \"GHRmodel\")\nmodel_list &lt;- readRDS(model_list_file)\n\n# Plot 2 models with a non-linear term of PDSI at one month lag in collapsed mode: \nplot_coef_nl(\nmodels = model_list,\nmod_id = c( \"mod5\", \"mod6\") ,\nmod_label = c(\"mod6\" = \"pdsi.l1_nl\",\n              \"mod5\" = \"pdsi.l1_nl + tmin.l1_nl\"),\nvar_label = c(\"pdsi.l1\" = \"Drought index (PDSI)\"),\nname = c(\"pdsi.l1\"),\ntitle = \"Change in non-linear term for drought index (PDSI)\nwith and without mean min. temp lag 1\",\nxlab = \"PDSI\",\npalette = \"IDE2\",\ncollapse = TRUE    \n)\n## End(Not run)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_gof.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_gof.Rd.html",
    "title": "Plot Models by Goodness-of-Fit",
    "section": "",
    "text": "Provides visualization of model performance using selected goodness-of-fit (GoF) metrics for one or more models. It is typically used with the mod_gof component of a GHRmodels object (produced by fit_models), but it can also accept any custom data frame ‚Äî provided it contains the same column names as the default mod_gof output (including model_id and the relevant metric column names). It supports visual grouping by aesthetics (color, shape, facet), arranging models by metric, and adding credible intervals for model differences.\nplot_gof(\n  mod_gof,\n  metric = \"dic\",\n  mod_id = NULL,\n  mod_label = NULL,\n  ci = FALSE,\n  var_arrange = NULL,\n  var_color = NULL,\n  var_shape = NULL,\n  var_facet = NULL,\n  palette = \"IDE2\"\n)\n\n\n\n\nmod_gof: A data frame containing goodness-of-fit statistics for each model. Typically this is the mod_gof component of a GHRmodels object. It must include at least a model_id column and the selected metric. Other columns can be used for aesthetics (e.g., color, shape).\nmetric: Character string specifying the GoF metric to plot. Common options include:\n\n\"dic\", \"waic\", \"lms\", \"mae\", \"rmse\", \"crps\", \"rsq\"\nDifferences from baseline: \"dic_vs_first\", \"waic_vs_first\", \"mae_vs_first\", etc.\nRandom effect variances: \"re_n_var\", \"re_n_var_change\", where n is an index.\n\nmod_id: Optional character vector of model IDs to include. If NULL, includes all in mod_gof.\nmod_label: Optional named or unnamed vector to customize display names for models. If unnamed, must match the order of mod_id.\nci: Logical. If TRUE, adds credible intervals for \"*_vs_first\" metrics (if available).\nvar_arrange: Character string for a column name used to order models along the x-axis. Defaults to \"model_id\" order if NULL.\nvar_color: Optional; name of a column in mod_gof to use for color grouping.\nvar_shape: Optional; name of a column in mod_gof to use for point shape grouping.\nvar_facet: Optional; name of a column in mod_gof to use for faceting the plot.\npalette: Character; name of a color palette to use if var_color is provided. Default is \"IDE2\".\n\n\n\n\nThis function helps interpret and visualize comparative model performance:\n\nRelative metrics (e.g., \"*_vs_first\") assume the first model is a reference.\nIf ci = TRUE, the function looks for columns like \"dic_vs_first_lci\" and \"_uci\".\nThe user can customize model order with var_arrange and legend groupings using var_color, etc.\n\n\n\n\nA ggplot2 object showing the specified metric for each model, optionally grouped and faceted. The plot supports:\n\nRanking or sorting models by a specified variable\nHighlighting credible intervals for relative metrics (e.g.¬†\"dic_vs_first\")\nGroup-level comparisons via color, shape, and facet aesthetics\n\n\n\n\nfit_models for fitting multiple INLA models.\n\n\n\n## Not run:\n\n# Load example GHRmodels object from the package: \nmodel_list_file &lt;- system.file(\"examples\", \"model_list.rds\", package = \"GHRmodel\")\nmodel_list &lt;- readRDS(model_list_file)\n\n# Plot models by difference in DIC\n        \nplot_gof(mod_gof = model_list$mod_gof,\n        metric = \"dic_vs_first\",\n        ci = TRUE,\n        var_arrange = \"dic\",\n        var_color = \"covariate_1\",\n        var_shape = \"covariate_2\",\n        palette= \"IDE2\")\n## End(Not run)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_gof.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_gof.Rd.html#description",
    "title": "Plot Models by Goodness-of-Fit",
    "section": "",
    "text": "Provides visualization of model performance using selected goodness-of-fit (GoF) metrics for one or more models. It is typically used with the mod_gof component of a GHRmodels object (produced by fit_models), but it can also accept any custom data frame ‚Äî provided it contains the same column names as the default mod_gof output (including model_id and the relevant metric column names). It supports visual grouping by aesthetics (color, shape, facet), arranging models by metric, and adding credible intervals for model differences.\nplot_gof(\n  mod_gof,\n  metric = \"dic\",\n  mod_id = NULL,\n  mod_label = NULL,\n  ci = FALSE,\n  var_arrange = NULL,\n  var_color = NULL,\n  var_shape = NULL,\n  var_facet = NULL,\n  palette = \"IDE2\"\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_gof.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_gof.Rd.html#arguments",
    "title": "Plot Models by Goodness-of-Fit",
    "section": "",
    "text": "mod_gof: A data frame containing goodness-of-fit statistics for each model. Typically this is the mod_gof component of a GHRmodels object. It must include at least a model_id column and the selected metric. Other columns can be used for aesthetics (e.g., color, shape).\nmetric: Character string specifying the GoF metric to plot. Common options include:\n\n\"dic\", \"waic\", \"lms\", \"mae\", \"rmse\", \"crps\", \"rsq\"\nDifferences from baseline: \"dic_vs_first\", \"waic_vs_first\", \"mae_vs_first\", etc.\nRandom effect variances: \"re_n_var\", \"re_n_var_change\", where n is an index.\n\nmod_id: Optional character vector of model IDs to include. If NULL, includes all in mod_gof.\nmod_label: Optional named or unnamed vector to customize display names for models. If unnamed, must match the order of mod_id.\nci: Logical. If TRUE, adds credible intervals for \"*_vs_first\" metrics (if available).\nvar_arrange: Character string for a column name used to order models along the x-axis. Defaults to \"model_id\" order if NULL.\nvar_color: Optional; name of a column in mod_gof to use for color grouping.\nvar_shape: Optional; name of a column in mod_gof to use for point shape grouping.\nvar_facet: Optional; name of a column in mod_gof to use for faceting the plot.\npalette: Character; name of a color palette to use if var_color is provided. Default is \"IDE2\"."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_gof.Rd.html#details",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_gof.Rd.html#details",
    "title": "Plot Models by Goodness-of-Fit",
    "section": "",
    "text": "This function helps interpret and visualize comparative model performance:\n\nRelative metrics (e.g., \"*_vs_first\") assume the first model is a reference.\nIf ci = TRUE, the function looks for columns like \"dic_vs_first_lci\" and \"_uci\".\nThe user can customize model order with var_arrange and legend groupings using var_color, etc."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_gof.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_gof.Rd.html#returns",
    "title": "Plot Models by Goodness-of-Fit",
    "section": "",
    "text": "A ggplot2 object showing the specified metric for each model, optionally grouped and faceted. The plot supports:\n\nRanking or sorting models by a specified variable\nHighlighting credible intervals for relative metrics (e.g.¬†\"dic_vs_first\")\nGroup-level comparisons via color, shape, and facet aesthetics"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_gof.Rd.html#see-also",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_gof.Rd.html#see-also",
    "title": "Plot Models by Goodness-of-Fit",
    "section": "",
    "text": "fit_models for fitting multiple INLA models."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_gof.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_gof.Rd.html#examples",
    "title": "Plot Models by Goodness-of-Fit",
    "section": "",
    "text": "## Not run:\n\n# Load example GHRmodels object from the package: \nmodel_list_file &lt;- system.file(\"examples\", \"model_list.rds\", package = \"GHRmodel\")\nmodel_list &lt;- readRDS(model_list_file)\n\n# Plot models by difference in DIC\n        \nplot_gof(mod_gof = model_list$mod_gof,\n        metric = \"dic_vs_first\",\n        ci = TRUE,\n        var_arrange = \"dic\",\n        var_color = \"covariate_1\",\n        var_shape = \"covariate_2\",\n        palette= \"IDE2\")\n## End(Not run)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_interact.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_interact.Rd.html",
    "title": "Generate Interaction Terms Between Covariates",
    "section": "",
    "text": "This function generates interaction terms between covariates specified in the pattern or name arguments. It requires a list of character vectors and appends interaction terms to each vector based on pairwise or three-way interactions. The resulting list can be input into the covariates argument in write_inla_formulas.\ncov_interact(covariates = NULL, pattern = NULL, name = NULL, add = FALSE)\n\n\n\n\ncovariates: A list of character vectors, each vector containing variable names. Typically an output of cov_multi or cov_uni.\npattern: A character vector of length 2 or 3 specifying prefixes of variables to interact (e.g., ‚Äútmin‚Äù matches ‚Äútmin‚Äù, ‚Äútmin.l1‚Äù, etc.).\nname: A character vector specifying the exact variable names to be included in the interactions.\nadd: Logical; if TRUE, appends the newly created formulas to the original list. Default is FALSE.\n\n\n\n\n\nIf two variables are matched, their pairwise interaction is added (var1:var2).\nIf three variables are matched, two-way and three-way interactions are generated.\nOnly variables that are expressed as linear terms can be used in interactions.\nUse either pattern, name, or both to identify variables for interaction.\n\n\n\n\nA list of character vectors, where each vector includes covariates and their corresponding interaction terms. This object can be passed to the covariates argument in write_inla_formulas.\n\n\n\n# Example dataset\ndata &lt;- data.frame(tmin.l1 = rnorm(10), pdsi.l1 = rnorm(10), urban = rnorm(10))\n\n# Extract names\ncovs &lt;- extract_names(data, pattern = c(\"tmin\", \"pdsi\", \"urban\"))\n\n# Create combinations\ncombos &lt;- cov_multi(covariates = covs, pattern = c(\"tmin\", \"pdsi\"))\n\n# Add interaction terms\ncov_interact(covariates = combos, pattern = c(\"tmin\", \"pdsi\"))\n\n# Output can be passed to write_inla_formulas()\nnew_covs &lt;- cov_interact(combos, pattern = c(\"tmin\", \"pdsi\"))\nformulas &lt;- write_inla_formulas(outcome = \"cases\", covariates = new_covs)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_interact.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_interact.Rd.html#description",
    "title": "Generate Interaction Terms Between Covariates",
    "section": "",
    "text": "This function generates interaction terms between covariates specified in the pattern or name arguments. It requires a list of character vectors and appends interaction terms to each vector based on pairwise or three-way interactions. The resulting list can be input into the covariates argument in write_inla_formulas.\ncov_interact(covariates = NULL, pattern = NULL, name = NULL, add = FALSE)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_interact.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_interact.Rd.html#arguments",
    "title": "Generate Interaction Terms Between Covariates",
    "section": "",
    "text": "covariates: A list of character vectors, each vector containing variable names. Typically an output of cov_multi or cov_uni.\npattern: A character vector of length 2 or 3 specifying prefixes of variables to interact (e.g., ‚Äútmin‚Äù matches ‚Äútmin‚Äù, ‚Äútmin.l1‚Äù, etc.).\nname: A character vector specifying the exact variable names to be included in the interactions.\nadd: Logical; if TRUE, appends the newly created formulas to the original list. Default is FALSE."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_interact.Rd.html#details",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_interact.Rd.html#details",
    "title": "Generate Interaction Terms Between Covariates",
    "section": "",
    "text": "If two variables are matched, their pairwise interaction is added (var1:var2).\nIf three variables are matched, two-way and three-way interactions are generated.\nOnly variables that are expressed as linear terms can be used in interactions.\nUse either pattern, name, or both to identify variables for interaction."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_interact.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_interact.Rd.html#returns",
    "title": "Generate Interaction Terms Between Covariates",
    "section": "",
    "text": "A list of character vectors, where each vector includes covariates and their corresponding interaction terms. This object can be passed to the covariates argument in write_inla_formulas."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/cov_interact.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/cov_interact.Rd.html#examples",
    "title": "Generate Interaction Terms Between Covariates",
    "section": "",
    "text": "# Example dataset\ndata &lt;- data.frame(tmin.l1 = rnorm(10), pdsi.l1 = rnorm(10), urban = rnorm(10))\n\n# Extract names\ncovs &lt;- extract_names(data, pattern = c(\"tmin\", \"pdsi\", \"urban\"))\n\n# Create combinations\ncombos &lt;- cov_multi(covariates = covs, pattern = c(\"tmin\", \"pdsi\"))\n\n# Add interaction terms\ncov_interact(covariates = combos, pattern = c(\"tmin\", \"pdsi\"))\n\n# Output can be passed to write_inla_formulas()\nnew_covs &lt;- cov_interact(combos, pattern = c(\"tmin\", \"pdsi\"))\nformulas &lt;- write_inla_formulas(outcome = \"cases\", covariates = new_covs)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/as_GHRformulas.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/as_GHRformulas.Rd.html",
    "title": "Convert R-INLA Model Formulas into a GHRformulas Object",
    "section": "",
    "text": "This function converts a character vector of suitable R-INLA formulas into a structured GHRformulas object. The GHRformulas object contains the standardized information about the fixed effects, the random effects, and the outcome variable, ensuring consistency across multiple models to be fitted using the fit_models function.\nas_GHRformulas(formulas)\n\n\n\n\nformulas: A character vector of model formulas formatted for R-INLA. Each formula must contain a single ~ separating the outcome variable from the predictors. Formulas generated with write_inla_formulas are compatible with this function.\n\n\n\n\nThe as_GHRformulas() function parses each input formula to extract the outcome variable, fixed effects (covariates), and random effects. The resulting GHRformulas object is designed to be used with the fit_models function for model fitting with R-INLA.\n\n\n\nA structured list of class GHRformulas with the following components:\n\nformulas: A character vector of the original INLA-compatible model formulas.\nvars: A data frame where each row corresponds to a formula and each column to a covariate. Entries indicate whether a covariate is included in the formula.\nre: A character vector listing the random effects specified across all formulas.\noutcome: A character string indicating the outcome variable (must be consistent across formulas).\n\n\n\n\nwrite_inla_formulas to generate R-INLA compatible input formulas\n\n\n\nformulas &lt;- c(\n\"dengue_cases ~ 1 + f(month_id, model = 'rw1')\", \n\"dengue_cases ~ 1 + f(month_id, model = 'rw1') + tmin.l1\") \n\n# Convert the formulas into a GHRformulas object\nformulas &lt;- as_GHRformulas(formulas)\n\n# Inspect the structured GHRformulas object\nprint(formulas)\n# Visualize output: GHRformulas object\nclass(formulas)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/as_GHRformulas.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/as_GHRformulas.Rd.html#description",
    "title": "Convert R-INLA Model Formulas into a GHRformulas Object",
    "section": "",
    "text": "This function converts a character vector of suitable R-INLA formulas into a structured GHRformulas object. The GHRformulas object contains the standardized information about the fixed effects, the random effects, and the outcome variable, ensuring consistency across multiple models to be fitted using the fit_models function.\nas_GHRformulas(formulas)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/as_GHRformulas.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/as_GHRformulas.Rd.html#arguments",
    "title": "Convert R-INLA Model Formulas into a GHRformulas Object",
    "section": "",
    "text": "formulas: A character vector of model formulas formatted for R-INLA. Each formula must contain a single ~ separating the outcome variable from the predictors. Formulas generated with write_inla_formulas are compatible with this function."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/as_GHRformulas.Rd.html#details",
    "href": "docs/GHRmodel/GHRmodel-reference/as_GHRformulas.Rd.html#details",
    "title": "Convert R-INLA Model Formulas into a GHRformulas Object",
    "section": "",
    "text": "The as_GHRformulas() function parses each input formula to extract the outcome variable, fixed effects (covariates), and random effects. The resulting GHRformulas object is designed to be used with the fit_models function for model fitting with R-INLA."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/as_GHRformulas.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/as_GHRformulas.Rd.html#returns",
    "title": "Convert R-INLA Model Formulas into a GHRformulas Object",
    "section": "",
    "text": "A structured list of class GHRformulas with the following components:\n\nformulas: A character vector of the original INLA-compatible model formulas.\nvars: A data frame where each row corresponds to a formula and each column to a covariate. Entries indicate whether a covariate is included in the formula.\nre: A character vector listing the random effects specified across all formulas.\noutcome: A character string indicating the outcome variable (must be consistent across formulas)."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/as_GHRformulas.Rd.html#see-also",
    "href": "docs/GHRmodel/GHRmodel-reference/as_GHRformulas.Rd.html#see-also",
    "title": "Convert R-INLA Model Formulas into a GHRformulas Object",
    "section": "",
    "text": "write_inla_formulas to generate R-INLA compatible input formulas"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/as_GHRformulas.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/as_GHRformulas.Rd.html#examples",
    "title": "Convert R-INLA Model Formulas into a GHRformulas Object",
    "section": "",
    "text": "formulas &lt;- c(\n\"dengue_cases ~ 1 + f(month_id, model = 'rw1')\", \n\"dengue_cases ~ 1 + f(month_id, model = 'rw1') + tmin.l1\") \n\n# Convert the formulas into a GHRformulas object\nformulas &lt;- as_GHRformulas(formulas)\n\n# Inspect the structured GHRformulas object\nprint(formulas)\n# Visualize output: GHRformulas object\nclass(formulas)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_coef_varying.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_coef_varying.Rd.html",
    "title": "Produce a Forest Plot for a Spatially or Temporally Varying Effects from a GHRmodels object.",
    "section": "",
    "text": "Generates a forest plot for a specified spatially or temporally varying coefficient (i.e.¬†a random slope) from a fitted GHRmodels object. The plot displays the effect estimates (x-axis) for each spatial/temporal unit (y-axis).\nplot_coef_varying(\n  models,\n  mod_id,\n  name,\n  unit_label = NULL,\n  palette = \"IDE2\",\n  title = NULL,\n  xlab = \"Effect size\",\n  ylab = NULL,\n  exp = FALSE\n)\n\n\n\n\nmodels: A GHRmodels object containing fitted model output.\nmod_id: A character specifying which model to be plotted (as in models$mod_gof$model_id).\nname: A character string naming the spatially or temporally varying coefficient to plot. This should match a random effect name in models$random[[mod_id]].\nunit_label: Optional named character vector providing custom labels for each spatial/temporal unit.\npalette: Character string for the GHR, RColorBrewer or colorspace palette (e.g.¬†‚ÄúPurp‚Äù) colour palette to use for the different models. See all available options by running GHR_palettes(), RColorBrewer::display.brewer.all() and colorspace::hcl_palettes(plot=TRUE). Single R colors in colors() or hex codes can also be used.\ntitle: Optional string for the plot title.\nxlab: Optional character string for the x-axis label (default = ‚ÄúEffect size‚Äù).\nylab: Optional character string for the y-axis label (default constructed from varying covariate name).\nexp: Logical,if TRUE the coefficients are exponentiated, Default is if FALSE.\n\n\n\n\nA ggplot2 forest plot object representing the spatially or temporally varying effect, with each line corresponding to a different spatial or temporal unit.\n\n\n\n## Not run:\n\n# Load example GHRmodels object from the package: \nmodel_cov_list_file &lt;- system.file(\"examples\", \"model_cov_list.rds\", package = \"GHRmodel\")\nmodel_cov_list &lt;- readRDS(model_cov_list_file)\n\n# Plot varying slopes of pdsi.l1 depending on the climate zone\nplot_coef_varying(\nmodels = model_cov_list,               # A list of fitted INLA model objects\nmod_id = \"mod8\",                       # Select the model with varying slopes\npalette = \"Blues\",                     # Color palette for the plot \nname = \"main_climate_f\",               # The grouping variable \ntitle = \"Effect of PDSI at one-month lag for each climate zone\",  # Plot title\nylab = \"Main climate zones\",           # Label for the y-axis \nunit_label = c(                        # Map factor levels to descriptive names \n  \"1\" = \"Tropical Rainforest Climate\", \n  \"2\" = \"Tropical Monsoon Climate\", \n  \"3\" = \"Tropical Savanna Climate with Dry Winter\",\n  \"4\" = \"Humid Subtropical Climate\"\n)\n)\n## End(Not run)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_coef_varying.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_coef_varying.Rd.html#description",
    "title": "Produce a Forest Plot for a Spatially or Temporally Varying Effects from a GHRmodels object.",
    "section": "",
    "text": "Generates a forest plot for a specified spatially or temporally varying coefficient (i.e.¬†a random slope) from a fitted GHRmodels object. The plot displays the effect estimates (x-axis) for each spatial/temporal unit (y-axis).\nplot_coef_varying(\n  models,\n  mod_id,\n  name,\n  unit_label = NULL,\n  palette = \"IDE2\",\n  title = NULL,\n  xlab = \"Effect size\",\n  ylab = NULL,\n  exp = FALSE\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_coef_varying.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_coef_varying.Rd.html#arguments",
    "title": "Produce a Forest Plot for a Spatially or Temporally Varying Effects from a GHRmodels object.",
    "section": "",
    "text": "models: A GHRmodels object containing fitted model output.\nmod_id: A character specifying which model to be plotted (as in models$mod_gof$model_id).\nname: A character string naming the spatially or temporally varying coefficient to plot. This should match a random effect name in models$random[[mod_id]].\nunit_label: Optional named character vector providing custom labels for each spatial/temporal unit.\npalette: Character string for the GHR, RColorBrewer or colorspace palette (e.g.¬†‚ÄúPurp‚Äù) colour palette to use for the different models. See all available options by running GHR_palettes(), RColorBrewer::display.brewer.all() and colorspace::hcl_palettes(plot=TRUE). Single R colors in colors() or hex codes can also be used.\ntitle: Optional string for the plot title.\nxlab: Optional character string for the x-axis label (default = ‚ÄúEffect size‚Äù).\nylab: Optional character string for the y-axis label (default constructed from varying covariate name).\nexp: Logical,if TRUE the coefficients are exponentiated, Default is if FALSE."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_coef_varying.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_coef_varying.Rd.html#returns",
    "title": "Produce a Forest Plot for a Spatially or Temporally Varying Effects from a GHRmodels object.",
    "section": "",
    "text": "A ggplot2 forest plot object representing the spatially or temporally varying effect, with each line corresponding to a different spatial or temporal unit."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/plot_coef_varying.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/plot_coef_varying.Rd.html#examples",
    "title": "Produce a Forest Plot for a Spatially or Temporally Varying Effects from a GHRmodels object.",
    "section": "",
    "text": "## Not run:\n\n# Load example GHRmodels object from the package: \nmodel_cov_list_file &lt;- system.file(\"examples\", \"model_cov_list.rds\", package = \"GHRmodel\")\nmodel_cov_list &lt;- readRDS(model_cov_list_file)\n\n# Plot varying slopes of pdsi.l1 depending on the climate zone\nplot_coef_varying(\nmodels = model_cov_list,               # A list of fitted INLA model objects\nmod_id = \"mod8\",                       # Select the model with varying slopes\npalette = \"Blues\",                     # Color palette for the plot \nname = \"main_climate_f\",               # The grouping variable \ntitle = \"Effect of PDSI at one-month lag for each climate zone\",  # Plot title\nylab = \"Main climate zones\",           # Label for the y-axis \nunit_label = c(                        # Map factor levels to descriptive names \n  \"1\" = \"Tropical Rainforest Climate\", \n  \"2\" = \"Tropical Monsoon Climate\", \n  \"3\" = \"Tropical Savanna Climate with Dry Winter\",\n  \"4\" = \"Humid Subtropical Climate\"\n)\n)\n## End(Not run)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/fit_models.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/fit_models.Rd.html",
    "title": "Fit Multiple INLA Models",
    "section": "",
    "text": "This function fits a set of INLA model formulas, provided in a GHRformulas object, to a specified dataset. For each fitted model, it extracts a range of outputs, including goodness-of-fit (GoF) metrics and other model outputs (fitted values, fixed effects, random effects). Results are extracted and stored in a GHRmodels object.\nfit_models(\n  formulas,\n  data,\n  family,\n  name,\n  offset = NULL,\n  control_compute = list(config = FALSE, vcov = FALSE),\n  nthreads = 8,\n  pb = FALSE\n)\n\n\n\n\nformulas: A GHRformulas object containing multiple INLA model formulas.\ndata: A data frame containing the variables used in the model formulas.\nfamily: A character string specifying the likelihood family (e.g., \"poisson\", \"nbinomial\", etc.).\nname: A character string to label each fitted model (e.g., \"mod\").\noffset: A character string specifying the name of the offset variable in data. If NULL, no offset is applied. Default is NULL. Internally, log(offset_values) is applied.\ncontrol_compute: A named list controlling additional computation options:\n\nconfig: Logical ; if TRUE, stores the Gaussian Markov Random Field (GMRF) and enables the computation of posterior predictive distribution (1,000 draws). Defaults to FALSE.\nvcov: Logical if TRUE, returns the variance-covariance (correlation) matrix of fixed effects. Defaults to FALSE.\n\nnthreads: An integer specifying the number of threads for parallel computation. Default is 8.\npb: Logical; if TRUE, displays a progress bar while fitting models. Default is FALSE.\n\n\n\n\nThis function iterates over each formula in the GHRformulas object and fits the corresponding INLA model using the internal function .fit_single_model(). For each fitted model, it extracts the fitted values, fixed effects, and random effects summaries. Then, it calculates a series of model evaluation metrics using the .gof_single_model() internal function.\nThe goodness-of-fit (GoF) metrics are organized into two categories:\n\nModel-Specific Goodness-of-Fit Metrics\n\nThese are computed separately for each model:\n\nDeviance Information Criterion (DIC)\nDIC = \\bar{D} + p_{D}\nwhere \\bar{D} is the posterior mean deviance and p_{D} is the effective number of parameters. Lower DIC values indicate a better model fit, balancing goodness-of-fit and model complexity.\nWatanabe-Akaike Information Criterion (WAIC)\nWAIC = -2\\left(\\mathrm{lppd} - p_{\\mathrm{WAIC}}\\right)\nWAIC evaluates predictive accuracy and penalizes model complexity through the log pointwise predictive density (\\mathrm{lppd}). Lower values imply better generalization.\nLog Mean Score (LMS)\nLMS = \\frac{1}{n} \\sum_{i=1}^n \\left( -\\log(\\mathrm{CPO}_i) \\right)\nLMS assesses the average negative log-predictive density using Conditional Predictive Ordinates (CPO). Lower LMS values indicate stronger predictive performance by penalizing models that assign low probability to observed outcomes.\nMean Absolute Error (MAE)\nMAE = \\frac{1}{n} \\sum_{i=1}^n \\left| y_i - \\hat{y}_i \\right|\nMeasures the average absolute deviation between observed values y_i and predicted values \\hat{y}_i. Lower MAE values indicate improved fit. If config = TRUE, MAE is computed using the full posterior predictive distribution (PPD); otherwise, it uses point estimates from INLA‚Äôs summary.fitted.values.\nRoot Mean Squared Error (RMSE)\nRMSE = \\sqrt{ \\frac{1}{n} \\sum_{i=1}^n (y_i - \\hat{y}_i)^2 }\nCaptures average squared deviation between observed and predicted values. RMSE penalizes larger errors more heavily. Lower values reflect better model fit. If config = TRUE, RMSE uses the PPD; otherwise, it uses point estimates.\nContinuous Ranked Probability Score (CRPS)\n\\mathrm{CRPS}(F, y) = \\int_{-\\infty}^{\\infty} \\left[F(t) - \\mathbf{1}\\{y \\leq t\\}\\right]^2 dt\nCRPS assesses how well the predictive cumulative distribution aligns with the observed outcome. Lower scores suggest better calibrated predictive distributions. Only available when config = TRUE.\n\n\nModel Comparison Metrics (relative to the first model)\n\nThe first model in the list is treated as the baseline for model comparisons. All other models are evaluated against it using the following metrics:\n\nDifference in DIC and WAIC\nStored as dic_vs_first and waic_vs_first. These represent how much higher (or lower) each model‚Äôs DIC/WAIC is compared to the first model. Additionally, 95% credible intervals for these differences are stored as *_vs_first_lci and *_vs_first_uci.\nDifference in MAE and RMSE\nStored as mae_vs_first and rmse_vs_first. These reflect the absolute difference in prediction error compared to the first model. No credible intervals are computed for these metrics.\nContinuous Ranked Probability Score Skill Score (CRPSS)\n\\mathrm{CRPSS} = 1 - \\frac{\\mathrm{CRPS}_{\\text{model}}}{\\mathrm{CRPS}_{\\text{baseline}}}\nIndicates how much better the predictive distribution of the current model is relative to the baseline model. Values closer to 1 indicate improvement; negative values imply worse performance. Available only when config = TRUE.\nPseudo R-squared based on deviance\nR^2 = 1 - \\exp\\left( \\frac{-2}{n} \\left( \\frac{dev_{\\text{model}}}{-2} - \\frac{dev_{\\text{base}}}{-2} \\right) \\right)\nCaptures relative deviance reduction compared to the baseline model. Values range from 0 (no improvement) to 1 (strong improvement).\nRandom Effect Variance\n\\mathrm{Var}_{re} = \\frac{1}{\\mathrm{precision}}\nQuantifies residual variance due to group- or cluster-level effects. Computed only when random effects are defined in the model formula.\nProportional Change in Random Effect Variance\n\\frac{\\mathrm{Var}_{re}}{\\mathrm{Var}_{re}^{(1)}} - 1\nRepresents the relative change in group-level variance compared to the baseline model. Helps assess how much variance is explained by added covariates.\n\n\n\n\nAn object of class GHRmodels containing:\n\n$mod_gof: A data frame of model-specific goodness-of-fit metrics.\n$fitted: A list of fitted values (one element per model). If config = TRUE, these are derived from the posterior predictive distribution (PPD); otherwise, they are extracted from INLA‚Äôs summary.fitted.values.\n$fixed: A list of summary tables for fixed effects (one element per model).\n$random: A list of summary tables for random effects (one element per model).\n$formulas: A character vector of the original model formulas used.\n$re: A character vector specifying any random effects defined in formulas.\n$outcome: A character string indicating the outcome variable used.\n$data: The original data frame passed to the function.\n\n\n\n\nas_GHRformulas converts a set of R-INLA-compatible formulas into a GHRformulas object.\n\n\n\n## Not run:\n\n# Load example dataset\ndata(dengueMS)\n\n# Declare formulas\nformulas &lt;- c(\n  \"dengue_cases ~ tmin +  f(year, model='rw1')\",\n  \"dengue_cases ~ pdsi +  f(year, model='rw1')\"\n)\n\n# Tranform formulas into a 'GHRformulas' object\nghr_formulas &lt;- as_GHRformulas(formulas)\n\n# Fit multiple models \nresults &lt;- fit_models(\n  formulas = ghr_formulas,\n  data     = dengue_MS,\n  family   = \"nbinomial\",\n  name     = \"TestModel\",\n  offset   = \"population\",\nnthreads = 2,\ncontrol_compute = list(config = FALSE),\npb       = TRUE\n)\n\n# Inspect goodness-of-fit metrics\n\nhead(results$mod_gof)\n## End(Not run)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/fit_models.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/fit_models.Rd.html#description",
    "title": "Fit Multiple INLA Models",
    "section": "",
    "text": "This function fits a set of INLA model formulas, provided in a GHRformulas object, to a specified dataset. For each fitted model, it extracts a range of outputs, including goodness-of-fit (GoF) metrics and other model outputs (fitted values, fixed effects, random effects). Results are extracted and stored in a GHRmodels object.\nfit_models(\n  formulas,\n  data,\n  family,\n  name,\n  offset = NULL,\n  control_compute = list(config = FALSE, vcov = FALSE),\n  nthreads = 8,\n  pb = FALSE\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/fit_models.Rd.html#arguments",
    "href": "docs/GHRmodel/GHRmodel-reference/fit_models.Rd.html#arguments",
    "title": "Fit Multiple INLA Models",
    "section": "",
    "text": "formulas: A GHRformulas object containing multiple INLA model formulas.\ndata: A data frame containing the variables used in the model formulas.\nfamily: A character string specifying the likelihood family (e.g., \"poisson\", \"nbinomial\", etc.).\nname: A character string to label each fitted model (e.g., \"mod\").\noffset: A character string specifying the name of the offset variable in data. If NULL, no offset is applied. Default is NULL. Internally, log(offset_values) is applied.\ncontrol_compute: A named list controlling additional computation options:\n\nconfig: Logical ; if TRUE, stores the Gaussian Markov Random Field (GMRF) and enables the computation of posterior predictive distribution (1,000 draws). Defaults to FALSE.\nvcov: Logical if TRUE, returns the variance-covariance (correlation) matrix of fixed effects. Defaults to FALSE.\n\nnthreads: An integer specifying the number of threads for parallel computation. Default is 8.\npb: Logical; if TRUE, displays a progress bar while fitting models. Default is FALSE."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/fit_models.Rd.html#details",
    "href": "docs/GHRmodel/GHRmodel-reference/fit_models.Rd.html#details",
    "title": "Fit Multiple INLA Models",
    "section": "",
    "text": "This function iterates over each formula in the GHRformulas object and fits the corresponding INLA model using the internal function .fit_single_model(). For each fitted model, it extracts the fitted values, fixed effects, and random effects summaries. Then, it calculates a series of model evaluation metrics using the .gof_single_model() internal function.\nThe goodness-of-fit (GoF) metrics are organized into two categories:\n\nModel-Specific Goodness-of-Fit Metrics\n\nThese are computed separately for each model:\n\nDeviance Information Criterion (DIC)\nDIC = \\bar{D} + p_{D}\nwhere \\bar{D} is the posterior mean deviance and p_{D} is the effective number of parameters. Lower DIC values indicate a better model fit, balancing goodness-of-fit and model complexity.\nWatanabe-Akaike Information Criterion (WAIC)\nWAIC = -2\\left(\\mathrm{lppd} - p_{\\mathrm{WAIC}}\\right)\nWAIC evaluates predictive accuracy and penalizes model complexity through the log pointwise predictive density (\\mathrm{lppd}). Lower values imply better generalization.\nLog Mean Score (LMS)\nLMS = \\frac{1}{n} \\sum_{i=1}^n \\left( -\\log(\\mathrm{CPO}_i) \\right)\nLMS assesses the average negative log-predictive density using Conditional Predictive Ordinates (CPO). Lower LMS values indicate stronger predictive performance by penalizing models that assign low probability to observed outcomes.\nMean Absolute Error (MAE)\nMAE = \\frac{1}{n} \\sum_{i=1}^n \\left| y_i - \\hat{y}_i \\right|\nMeasures the average absolute deviation between observed values y_i and predicted values \\hat{y}_i. Lower MAE values indicate improved fit. If config = TRUE, MAE is computed using the full posterior predictive distribution (PPD); otherwise, it uses point estimates from INLA‚Äôs summary.fitted.values.\nRoot Mean Squared Error (RMSE)\nRMSE = \\sqrt{ \\frac{1}{n} \\sum_{i=1}^n (y_i - \\hat{y}_i)^2 }\nCaptures average squared deviation between observed and predicted values. RMSE penalizes larger errors more heavily. Lower values reflect better model fit. If config = TRUE, RMSE uses the PPD; otherwise, it uses point estimates.\nContinuous Ranked Probability Score (CRPS)\n\\mathrm{CRPS}(F, y) = \\int_{-\\infty}^{\\infty} \\left[F(t) - \\mathbf{1}\\{y \\leq t\\}\\right]^2 dt\nCRPS assesses how well the predictive cumulative distribution aligns with the observed outcome. Lower scores suggest better calibrated predictive distributions. Only available when config = TRUE.\n\n\nModel Comparison Metrics (relative to the first model)\n\nThe first model in the list is treated as the baseline for model comparisons. All other models are evaluated against it using the following metrics:\n\nDifference in DIC and WAIC\nStored as dic_vs_first and waic_vs_first. These represent how much higher (or lower) each model‚Äôs DIC/WAIC is compared to the first model. Additionally, 95% credible intervals for these differences are stored as *_vs_first_lci and *_vs_first_uci.\nDifference in MAE and RMSE\nStored as mae_vs_first and rmse_vs_first. These reflect the absolute difference in prediction error compared to the first model. No credible intervals are computed for these metrics.\nContinuous Ranked Probability Score Skill Score (CRPSS)\n\\mathrm{CRPSS} = 1 - \\frac{\\mathrm{CRPS}_{\\text{model}}}{\\mathrm{CRPS}_{\\text{baseline}}}\nIndicates how much better the predictive distribution of the current model is relative to the baseline model. Values closer to 1 indicate improvement; negative values imply worse performance. Available only when config = TRUE.\nPseudo R-squared based on deviance\nR^2 = 1 - \\exp\\left( \\frac{-2}{n} \\left( \\frac{dev_{\\text{model}}}{-2} - \\frac{dev_{\\text{base}}}{-2} \\right) \\right)\nCaptures relative deviance reduction compared to the baseline model. Values range from 0 (no improvement) to 1 (strong improvement).\nRandom Effect Variance\n\\mathrm{Var}_{re} = \\frac{1}{\\mathrm{precision}}\nQuantifies residual variance due to group- or cluster-level effects. Computed only when random effects are defined in the model formula.\nProportional Change in Random Effect Variance\n\\frac{\\mathrm{Var}_{re}}{\\mathrm{Var}_{re}^{(1)}} - 1\nRepresents the relative change in group-level variance compared to the baseline model. Helps assess how much variance is explained by added covariates."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/fit_models.Rd.html#returns",
    "href": "docs/GHRmodel/GHRmodel-reference/fit_models.Rd.html#returns",
    "title": "Fit Multiple INLA Models",
    "section": "",
    "text": "An object of class GHRmodels containing:\n\n$mod_gof: A data frame of model-specific goodness-of-fit metrics.\n$fitted: A list of fitted values (one element per model). If config = TRUE, these are derived from the posterior predictive distribution (PPD); otherwise, they are extracted from INLA‚Äôs summary.fitted.values.\n$fixed: A list of summary tables for fixed effects (one element per model).\n$random: A list of summary tables for random effects (one element per model).\n$formulas: A character vector of the original model formulas used.\n$re: A character vector specifying any random effects defined in formulas.\n$outcome: A character string indicating the outcome variable used.\n$data: The original data frame passed to the function."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/fit_models.Rd.html#see-also",
    "href": "docs/GHRmodel/GHRmodel-reference/fit_models.Rd.html#see-also",
    "title": "Fit Multiple INLA Models",
    "section": "",
    "text": "as_GHRformulas converts a set of R-INLA-compatible formulas into a GHRformulas object."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/fit_models.Rd.html#examples",
    "href": "docs/GHRmodel/GHRmodel-reference/fit_models.Rd.html#examples",
    "title": "Fit Multiple INLA Models",
    "section": "",
    "text": "## Not run:\n\n# Load example dataset\ndata(dengueMS)\n\n# Declare formulas\nformulas &lt;- c(\n  \"dengue_cases ~ tmin +  f(year, model='rw1')\",\n  \"dengue_cases ~ pdsi +  f(year, model='rw1')\"\n)\n\n# Tranform formulas into a 'GHRformulas' object\nghr_formulas &lt;- as_GHRformulas(formulas)\n\n# Fit multiple models \nresults &lt;- fit_models(\n  formulas = ghr_formulas,\n  data     = dengue_MS,\n  family   = \"nbinomial\",\n  name     = \"TestModel\",\n  offset   = \"population\",\nnthreads = 2,\ncontrol_compute = list(config = FALSE),\npb       = TRUE\n)\n\n# Inspect goodness-of-fit metrics\n\nhead(results$mod_gof)\n## End(Not run)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/map_MS.Rd.html",
    "href": "docs/GHRmodel/GHRmodel-reference/map_MS.Rd.html",
    "title": "Administrative Map for Municipalities in the Mato Grosso do Sul",
    "section": "",
    "text": "A simple feature (sf) multipolygon object representing a map of Mato Grosso do Sul, Brazil, including 11 municipalities. See @source for access to the complete data set.\nmap_MS\n\n\n\nA simple feature (sf) object including 11 rows and 2 columns:\n\n$code: Unique ID number for each micro region (11 units)\n$geometry: geometries of the sf multipolygon\n\n\n\n\nsource code on GitHub; source code on Zenodo);"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/map_MS.Rd.html#description",
    "href": "docs/GHRmodel/GHRmodel-reference/map_MS.Rd.html#description",
    "title": "Administrative Map for Municipalities in the Mato Grosso do Sul",
    "section": "",
    "text": "A simple feature (sf) multipolygon object representing a map of Mato Grosso do Sul, Brazil, including 11 municipalities. See @source for access to the complete data set.\nmap_MS"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/map_MS.Rd.html#format",
    "href": "docs/GHRmodel/GHRmodel-reference/map_MS.Rd.html#format",
    "title": "Administrative Map for Municipalities in the Mato Grosso do Sul",
    "section": "",
    "text": "A simple feature (sf) object including 11 rows and 2 columns:\n\n$code: Unique ID number for each micro region (11 units)\n$geometry: geometries of the sf multipolygon"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-reference/map_MS.Rd.html#source",
    "href": "docs/GHRmodel/GHRmodel-reference/map_MS.Rd.html#source",
    "title": "Administrative Map for Municipalities in the Mato Grosso do Sul",
    "section": "",
    "text": "source code on GitHub; source code on Zenodo);"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel.html#overview",
    "href": "docs/GHRmodel/GHRmodel.html#overview",
    "title": "GHRmodel",
    "section": "Overview",
    "text": "Overview\n\n\nThe GHRmodel package supports modeling health outcomes using Bayesian hierarchical spatio-temporal models with complex covariate effects (e.g., linear, non-linear, interactions, distributed lag linear and non-linear models) in the R-INLA framework. It is designed to help users identify key drivers and predictors of disease risk by enabling streamlined model exploration, comparison, and visualization of complex covariate effects.\nThe image below shows the structure of the GHRmodel package, outlining its functions (in blue), GHRmodel-specific output objects (in purple), generic output objects (in grey), and general functionality. Generic output objects can be provided directly by the user or can be generated using GHRmodel helper functions.\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe GHRmodel package is designed to work in tandem with other packages of the GHRtools suite: GHRexplore, which facilitates data exploration and visualization, and GHRpredict, which computes out-of-sample probabilistic predictions of models developed in GHRmodel and enables predictive performance evaluation.\nMore information about the toolkit, with tutorials and published examples can be found at this website."
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel.html#installation",
    "href": "docs/GHRmodel/GHRmodel.html#installation",
    "title": "GHRmodel",
    "section": "Installation",
    "text": "Installation\nThe latest version of the GHRmodel package is hosted on CRAN and can by installed using the following commands:\n# Install from CRAN\ninstall.packages(\"GHRmodel\") \n\n# Get the development version from Gitlab\nlibrary(devtools)\ndevtools::install_git('https://earth.bsc.es/gitlab/ghr/ghrmodel.git')"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel.html#usage",
    "href": "docs/GHRmodel/GHRmodel.html#usage",
    "title": "GHRmodel",
    "section": "Usage",
    "text": "Usage\nTo fit a model with R-INLA, formulas need to follow its required syntax and structural conventions. INLA-compatible model formulas can be developed using either:\n\nUser-defined INLA-compatible input, which may consist of either user-defined covariate lists or user-defined formula lists.\nGHRmodel helper functions that allow the user to pre-process and transform covariates and streamline writing INLA-compatible formulas.\n\nIn this example the user provides a list of INLA-compatible model formulas. These are passed to the as_GHRformulas() function to be converted into a standardized GHRformulas object. This ensures consistent output structure and random effect specification across models that can be interpreted by the function fit_models() for model fitting.\nlibrary(\"GHRmodel\")\n\n# Convert list of user-defined INLA formulas into a GHRformulas object \nformulas_user_ghr &lt;- as_GHRformulas(c(\n  \n  # Model 1: random effects only, where monthly random effect is replicated by meso region and the spatial random effect is replicated by year\n    \"dengue_cases ~ 1 +\n     f(month_id, model = 'rw1', replicate = spat_meso_id, cyclic = TRUE, constr = TRUE, hyper = prior_t) +\n     f(year_id, model = 'iid', constr = TRUE, hyper = prior_t) +\n     f(spat_id, model = 'bym2', graph = g, constr = TRUE, hyper = prior_sp, replicate = year_id2)\",\n    \n  # Model 2: random effects and a varying effect for pdsi lag 1 by climate zone\n  \"dengue_cases ~ 1 + f(main_climate_f, pdsi.l1, model = 'iid') +\n     f(month_id, model = 'rw1', replicate = spat_meso_id, cyclic = TRUE, constr = TRUE, hyper = prior_t) +\n     f(year_id, model = 'iid', constr = TRUE, hyper = prior_t) +\n     f(spat_id, model = 'bym2', graph = g, constr = TRUE, hyper = prior_sp, replicate = year_id2)\",\n\n  # Model 3: random effects and a 3-way interaction between different pdsi and tmin lags\n  \"dengue_cases ~ 1 + pdsi.l1 + tmin.l3 + pdsi.l6 + pdsi.l1:tmin.l3:pdsi.l6 +\n     f(month_id, model = 'rw1', replicate = spat_meso_id, cyclic = TRUE, constr = TRUE, hyper = prior_t) +\n     f(year_id, model = 'iid', constr = TRUE, hyper = prior_t) +\n     f(spat_id, model = 'bym2', graph = g, constr = TRUE, hyper = prior_sp, replicate = year_id2)\"\n))\nThe fit_models() function allows users to fit a set of INLA-compatible model formulas defined by a GHRformulas object to a provided data set. It automates model fitting, extraction of outputs, and computation of a wide range of goodness-of-fit (GoF) metrics. The output is a GHRmodels object.\n# User-defined INLA-compatible formulas can be passed into fit_models() as a GHRformulas object\nmodel_user &lt;- fit_models(\n  formulas = formulas_user_ghr,\n  data = data,\n  family = \"nbinomial\",           # Negative binomial likelihood\n  name = \"mod\",                   # Label prefix for each model\n  offset = \"population\",          # Offset variable to account for population size\n  control_compute = list(\n    config = FALSE,               # Do not posterior predictive distribution\n    vcov = FALSE                  # Do not return variance-covariance matrix\n  ),\n  pb = TRUE,                      # Display progress bar\n  nthreads = 8                    # Use 8 threads for parallel computation\n)\nFor model evaluation, GHRmodel provides a range of functions for model diagnostics, interpretation and evaluation. Functions with the prefix plot_* return graphical ggplot2 or cowplot objects, allowing users to easily customize visual outputs.\n# Plot any linear coefficients found in the fitted model results. \nplot_coef_lin(\n  model = model_user,              # Provide fitted model GHRmodels object\n  exp = TRUE,                      # Exponentiate coefficients to relative risk scale\n  title = \"Relative Risk (RR)\"     # Plot title\n)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel.html#developers",
    "href": "docs/GHRmodel/GHRmodel.html#developers",
    "title": "GHRmodel",
    "section": "Developers",
    "text": "Developers\nGiovenale Moirano, PhD \nBarcelona Supercomputing Center\nGlobal Health Resilience\nCarles Mil√†, PhD \nBarcelona Supercomputing Center\nGlobal Health Resilience\nAnna B. Kawiecki, PhD \nBarcelona Supercomputing Center\nGlobal Health Resilience\nRachel Lowe, PhD \nBarcelona Supercomputing Center\nGlobal Health Resilience (Group leader)"
  },
  {
    "objectID": "docs/GHRmodel/GHRmodel-news.html#section",
    "href": "docs/GHRmodel/GHRmodel-news.html#section",
    "title": "GHRmodel changelog",
    "section": "0.1.0",
    "text": "0.1.0\n\nInitial CRAN submission."
  }
]